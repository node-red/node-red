/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

/**
 * An API for undo / redo history buffer
 * @namespace RED.history
*/
RED.history = (function () {
    /**
     * GLOBAL NOTE: Handle event and users ONLY for edit/change event
     * TODO: Import types from RED.nodes
     *
     * @typedef {object} Node
     * @typedef {{ source: Node; sourcePort: number; target: Node; }} Link
     * @typedef {Node & { env?: Array<object>; }} Group
     * @typedef {Node & {}} Junction
     * @typedef {Node & { in: Array<object>; out: Array<object>;
     * instances: Array<Node>; env?: Array<object>; }} Subflow
     * @typedef {Node & { type: "subflow"; direction: "in"|"out"; }} SubflowNode
     * @typedef {Node & {}} Workspace
     *
     * @typedef {"add"|"delete"|"edit"|"move"|"multi"|"reorder"|"replace"|
     * "createSubflow"|"deleteSubflow"|"addToGroup"|"createGroup"|"ungroup"|
     * "removeFromGroup"} HistoryType
     * @typedef {{ t: HistoryType; dirty: boolean; callback?: (ev: HistoryEvent) => void; }
     * & (AddEvent | DeleteEvent | EditEvent | MoveEvent | MultiEvent | ReorderEvent |
     * ReplaceEvent | CreateSubflowEvent | DeleteSubflowEvent | AddToGroupEvent |
     * CreateGroupEvent | UngroupEvent | RemoveFromGroupEvent) } HistoryEvent
     * @memberof RED.history
     */

    /**
     * @type {Array<HistoryEvent>}
     */
    let undoHistory = [];

    /**
     * @type {Array<HistoryEvent>}
     */
    let redoHistory = [];

    function nodeOrJunction(id) {
        const node = RED.nodes.node(id);
        if (node) {
            return node;
        }
        return RED.nodes.junction(id);
    }

    function ensureUnlocked(id, flowsToLock) {
        const flow = id && (RED.nodes.workspace(id) || RED.nodes.subflow(id) || null);
        const isLocked = flow ? flow.locked : false;
        if (flow && isLocked) {
            flow.locked = false;
            flowsToLock.add(flow)
        }
    }

    /**
     * Called on the `add` history event
     *
     * @typedef {object} AddEvent
     * @property {"add"} t The history event type
     * @property {Array<Group>} [groups] An array with added groups
     * @property {Array<Junction>} [junctions] An array with added junctions
     * @property {Array<Link>} [links] An array with added links
     * @property {Array<string>} [nodes] An array with added node ids
     * @property {Array<Link>} [removedLinks] An array with removed links
     * @property {{ id: string, changed: boolean | undefined,
     * instances: Array<Node> }} [subflow]
     * @property {Array<Subflow>} [subflows] An array with added subflows (tabs)
     * @property {Array<Workspace>} [workspaces] An array with added workspaces
     * @memberof RED.history
     *
     * @param {AddEvent} ev The history event to undo
     * @param {object} [modifiedTabs]
     * @returns {DeleteEvent} The generated history event to redo
     */
    function onAdd(ev, modifiedTabs) {
        const inverseEv = {
            t: "delete",
            dirty: RED.nodes.dirty()
        };

        // Remove each node and if the node is in a group remove it from the group
        if (ev.nodes) {
            inverseEv.nodes = [];
            for (let i = 0; i < ev.nodes.length; i++) {
                const node = RED.nodes.node(ev.nodes[i]);
                if (node.z) {
                    modifiedTabs[node.z] = true;
                }
                inverseEv.nodes.push(node);
                RED.nodes.remove(ev.nodes[i]);
                if (node.g) {
                    const group = RED.nodes.group(node.g);
                    const index = group.nodes.indexOf(node);
                    if (index !== -1) {
                        group.nodes.splice(index, 1);
                        RED.group.markDirty(group);
                        // TODO: no change event?
                    }
                }
            }
        }

        // Remove each link
        if (ev.links) {
            inverseEv.links = [];
            for (let i = 0; i < ev.links.length; i++) {
                inverseEv.links.push(ev.links[i]);
                RED.nodes.removeLink(ev.links[i]);
            }
        }

        // Remove each junction and if the junction is in a group remove it from the group
        if (ev.junctions) {
            inverseEv.junctions = [];
            for (let i = 0; i < ev.junctions.length; i++) {
                inverseEv.junctions.push(ev.junctions[i]);
                RED.nodes.removeJunction(ev.junctions[i]);
                if (ev.junctions[i].g) {
                    const group = RED.nodes.group(ev.junctions[i].g);
                    const index = group.nodes.indexOf(ev.junctions[i]);
                    if (index !== -1) {
                        group.nodes.splice(index, 1);
                        RED.group.markDirty(group);
                        // TODO: no change event?
                    }
                }
            }
        }

        // Remove each group
        if (ev.groups) {
            inverseEv.groups = [];
            for (let i = ev.groups.length - 1; i >= 0; i--) {
                const group = ev.groups[i];
                modifiedTabs[group.z] = true;
                // The order of groups is important
                //  - to invert the action, the order is reversed
                inverseEv.groups.unshift(group);
                RED.nodes.removeGroup(group);
            }
        }

        // Remove each workspace
        if (ev.workspaces) {
            inverseEv.workspaces = [];
            for (let i = 0; i < ev.workspaces.length; i++) {
                const workspaceOrder = RED.nodes.getWorkspaceOrder();
                // Save the current index for the redo event
                ev.workspaces[i]._index = workspaceOrder.indexOf(ev.workspaces[i].id);
                inverseEv.workspaces.push(ev.workspaces[i]);
                RED.nodes.removeWorkspace(ev.workspaces[i].id);
                RED.workspaces.remove(ev.workspaces[i]);
            }
        }

        // Remove each subflow (tab)
        if (ev.subflows) {
            inverseEv.subflows = [];
            for (let i = 0; i < ev.subflows.length; i++) {
                inverseEv.subflows.push(ev.subflows[i]);
                RED.nodes.removeSubflow(ev.subflows[i]);
                RED.workspaces.remove(ev.subflows[i]);
            }
        }

        // Mark each subflow node as changed (because node added)
        if (ev.subflow) {
            inverseEv.subflow = {};
            if (ev.subflow.instances) {
                inverseEv.subflow.instances = [];
                ev.subflow.instances.forEach(function (n) {
                    inverseEv.subflow.instances.push(n);
                    // TODO: no need getNode, n is the node
                    const node = RED.nodes.node(n.id);
                    if (node) {
                        node.changed = n.changed;
                        node.dirty = true;
                    }
                });
            }

            // Set the changed prop of subflow (tab)
            if (ev.subflow.hasOwnProperty("changed")) {
                const subflow = RED.nodes.subflow(ev.subflow.id);
                if (subflow) {
                    subflow.changed = ev.subflow.changed;
                }
            }
        }

        // Add links previously removed (in other delete event)
        if (ev.removedLinks) {
            inverseEv.createdLinks = [];
            for (let i = 0; i < ev.removedLinks.length; i++) {
                inverseEv.createdLinks.push(ev.removedLinks[i]);
                RED.nodes.addLink(ev.removedLinks[i]);
            }
        }

        return inverseEv;
    }

    /**
     * Called on the `delete` history event
     *
     * @typedef {object} DeleteEvent
     * @property {"delete"} t The history event type
     * @property {Record<string, object>} [changes] An object with changes.
     * The key is the id of a node and the value is an object with the changes
     * to apply
     * @property {Array<Link>} [createdLinks] An array with created links
     * @property {Array<Group>} [groups] An array with removed groups
     * @property {Array<Junction>} [junctions] An array with removed junctions
     * @property {Array<Link>} [links] An array with removed links
     * @property {Array<Node>} [nodes] An array with removed nodes
     * @property {{ id: string | undefined, instances: Array<Node> | undefined,
     * status: string | undefined }} [subflow]
     * @property {Array<SubflowNode>} [subflowInputs] An array with removed
     * subflow input
     * @property {Array<SubflowNode>} [subflowOutputs] An array with removed
     * subflow outputs
     * @property {Array<Subflow>} [subflows] An array with removed subflows (tabs)
     * @property {Array<Workspace>} [workspaces] An array with removed workspace
     * @memberof RED.history
     *
     * @param {DeleteEvent} ev The history event to undo
     * @param {object} [modifiedTabs]
     * @returns {AddEvent} The generated history event to redo
     */
    function onDelete(ev, modifiedTabs) {
        // TODO: check why global
        let subflow;
        const inverseEv = {
            t: "add",
            dirty: RED.nodes.dirty()
        };

        // Add each workspace
        if (ev.workspaces) {
            inverseEv.workspaces = [];
            for (let i = 0; i < ev.workspaces.length; i++) {
                inverseEv.workspaces.push(ev.workspaces[i]);
                RED.nodes.addWorkspace(ev.workspaces[i], ev.workspaces[i]._index);
                RED.workspaces.add(ev.workspaces[i], undefined, ev.workspaces[i]._index);
                delete ev.workspaces[i]._index;
            }
        }

        // Add each subflow (tab)
        if (ev.subflows) {
            inverseEv.subflows = [];
            for (let i = 0; i < ev.subflows.length; i++) {
                inverseEv.subflows.push(ev.subflows[i]);
                RED.nodes.addSubflow(ev.subflows[i]);
                // TODO: add to workspace?
            }
        }

        // Update the input array - 0 or one element
        if (ev.subflowInputs && ev.subflowInputs.length > 0) {
            subflow = RED.nodes.subflow(ev.subflowInputs[0].z);
            subflow.in.push(ev.subflowInputs[0]);
            subflow.in[0].dirty = true;
        }

        // Update the output array - 0 or more elements
        if (ev.subflowOutputs && ev.subflowOutputs.length > 0) {
            subflow = RED.nodes.subflow(ev.subflowOutputs[0].z);
            ev.subflowOutputs.sort(function (a, b) { return a.i - b.i });
            for (let i = 0; i < ev.subflowOutputs.length; i++) {
                const output = ev.subflowOutputs[i];
                subflow.out.splice(output.i, 0, output);
                for (let j = output.i + 1; j < subflow.out.length; j++) {
                    subflow.out[j].i++;
                    subflow.out[j].dirty = true;
                }
                RED.nodes.eachLink(function (l) {
                    if (l.source.type == "subflow:" + subflow.id) {
                        if (l.sourcePort >= output.i) {
                            l.sourcePort++;
                        }
                    }
                });
            }
        }

        if (ev.subflow) {
            inverseEv.subflow = {};
            // Mark each subflow node as changed
            if (ev.subflow.hasOwnProperty("instances")) {
                inverseEv.subflow.instances = [];
                ev.subflow.instances.forEach(function (n) {
                    inverseEv.subflow.instances.push(n);
                    // TODO: Use n instead of getNode
                    const node = RED.nodes.node(n.id);
                    if (node) {
                        node.changed = n.changed;
                        node.dirty = true;
                    }
                });
            }

            // Add the status (redo)
            if (ev.subflow.hasOwnProperty("status")) {
                const subflow = RED.nodes.subflow(ev.subflow.id);
                subflow.status = ev.subflow.status;
            }
        }

        if (subflow) {
            // TODO: use subflow.instances
            RED.nodes.filterNodes({ type: "subflow:" + subflow.id }).forEach(function (n) {
                n.inputs = subflow.in.length;
                n.outputs = subflow.out.length;
                n.resize = true;
                n.dirty = true;
            });
        }

        // For each group, create the group and add nodes to it
        if (ev.groups) {
            inverseEv.groups = [];
            const groupsToAdd = {};
            ev.groups.forEach(function (g) { groupsToAdd[g.id] = g; });
            for (let i = ev.groups.length - 1; i >= 0; i--) {
                RED.nodes.addGroup(ev.groups[i])
                modifiedTabs[ev.groups[i].z] = true;
                // The order of groups is important
                //  - to invert the action, the order is reversed
                inverseEv.groups.unshift(ev.groups[i]);
                if (ev.groups[i].g) {
                    let group;
                    if (!groupsToAdd[ev.groups[i].g]) {
                        group = RED.nodes.group(ev.groups[i].g);
                    } else {
                        group = groupsToAdd[ev.groups[i].g];
                    }
                    if (group.nodes.indexOf(ev.groups[i]) === -1) {
                        group.nodes.push(ev.groups[i]);
                    }
                    RED.group.markDirty(ev.groups[i])
                }
            }
        }

        // Add each nodes, if the node has a group add to it
        if (ev.nodes) {
            inverseEv.nodes = [];
            for (let i = 0; i < ev.nodes.length; i++) {
                RED.nodes.add(ev.nodes[i]);
                modifiedTabs[ev.nodes[i].z] = true;
                inverseEv.nodes.push(ev.nodes[i].id);
                if (ev.nodes[i].g) {
                    const group = RED.nodes.group(ev.nodes[i].g);
                    if (group.nodes.indexOf(ev.nodes[i]) === -1) {
                        group.nodes.push(ev.nodes[i]);
                    }
                    RED.group.markDirty(group)
                }
            }
        }

        // Add each junctions, if the junction has a group add to it
        if (ev.junctions) {
            inverseEv.junctions = [];
            for (let i = 0; i < ev.junctions.length; i++) {
                inverseEv.junctions.push(ev.junctions[i]);
                RED.nodes.addJunction(ev.junctions[i]);
                if (ev.junctions[i].g) {
                    const group = RED.nodes.group(ev.junctions[i].g);
                    if (group.nodes.indexOf(ev.junctions[i]) === -1) {
                        group.nodes.push(ev.junctions[i]);
                    }
                    RED.group.markDirty(group);
                }
            }
        }

        // Add each links
        if (ev.links) {
            inverseEv.links = [];
            for (let i = 0; i < ev.links.length; i++) {
                RED.nodes.addLink(ev.links[i]);
                inverseEv.links.push(ev.links[i]);
            }
        }

        // Remove each links
        if (ev.createdLinks) {
            inverseEv.removedLinks = [];
            for (let i = 0; i < ev.createdLinks.length; i++) {
                inverseEv.removedLinks.push(ev.createdLinks[i]);
                RED.nodes.removeLink(ev.createdLinks[i]);
            }
        }

        // Apply chanes to each nodes
        // { [nodeId]: object - changes to apply}
        if (ev.changes) {
            for (const i in ev.changes) {
                if (ev.changes.hasOwnProperty(i)) {
                    const node = RED.nodes.node(i);
                    if (node) {
                        for (const d in ev.changes[i]) {
                            if (ev.changes[i].hasOwnProperty(d)) {
                                node[d] = ev.changes[i][d];
                            }
                        }
                        node.dirty = true;
                    }
                    RED.events.emit("nodes:change", node);
                }
            }
        }

        if (subflow) {
            RED.events.emit("subflows:change", subflow);
        }

        return inverseEv;
    }

    /**
     * Called on the `move` history event
     *
     * @typedef {object} MoveEvent
     * @property {"move"} t The history event type
     * @property {Group} [addToGroup] The group in which the nodes were added
     * @property {Array<Link>} [links]
     * @property {Array<{ n: Node, ox: number, oy: number, dx: number,
     * dy: number }>} nodes An array with nodes moved
     * @property {Array<Link>} [removedLinks]
     * @property {Group} [removeFromGroup] The group in which the nodes were
     * removed
     * @memberof RED.history
     *
     * @param {MoveEvent} ev The history event to undo
     * @returns {MoveEvent} The generated history event to redo
     */
    function onMove(ev) {
        const inverseEv = {
            t: "move",
            nodes: [],
            dirty: RED.nodes.dirty()
        };

        // Move each node
        for (let i = 0; i < ev.nodes.length; i++) {
            const n = ev.nodes[i];
            const rn = { n: n.n, ox: n.n.x, oy: n.n.y, dirty: true, moved: n.n.moved };
            inverseEv.nodes.push(rn);
            n.n.x = n.ox;
            n.n.y = n.oy;
            n.n.dirty = true;
            n.n.moved = n.moved;
        }

        // A move could have caused a link splice
        // TODO: still used? Ctrl + X ?
        if (ev.links) {
            inverseEv.removedLinks = [];
            for (let i = 0; i < ev.links.length; i++) {
                inverseEv.removedLinks.push(ev.links[i]);
                RED.nodes.removeLink(ev.links[i]);
            }
        }

        if (ev.removedLinks) {
            inverseEv.links = [];
            for (let i = 0; i < ev.removedLinks.length; i++) {
                inverseEv.links.push(ev.removedLinks[i]);
                RED.nodes.addLink(ev.removedLinks[i]);
            }
        }

        // Remove each node from the group
        if (ev.addToGroup) {
            RED.group.removeFromGroup(ev.addToGroup, ev.nodes.map(function (n) { return n.n }), false);
            inverseEv.removeFromGroup = ev.addToGroup;
        }

        // Add each node to the group
        if (ev.removeFromGroup) {
            RED.group.addToGroup(ev.removeFromGroup, ev.nodes.map(function (n) { return n.n }));
            inverseEv.addToGroup = ev.removeFromGroup;
        }

        return inverseEv;
    }

    /**
     * Called on the `createSubflow` history event
     *
     * @typedef {object} CreateSubflowEvent
     * @property {"createSubflow"} t The history event type
     * @property {string} activeWorkspace The id of the active workspace
     * @property {Array<Link>} [links] An array with added links (during
     * conversion to Subflow - links inside the subflow)
     * @property {Array<string>} [nodes] An array with subflow node ids
     * @property {Array<Link>} [removedLinks] An array with removed links
     * (during conversion to Subflow - links from active workspace)
     * @property {{ subflow: Subflow, offsetX: number | undefined,
     * offsetY: number | undefined }} subflow The subflow created to delete
     * @memberof RED.history
     *
     * @param {CreateSubflowEvent} ev The history event to undo
     * @returns {DeleteSubflowEvent} The generated history event to redo
     */
    function onCreateSubflow(ev) {
        const inverseEv = {
            t: "deleteSubflow",
            activeWorkspace: ev.activeWorkspace,
            dirty: RED.nodes.dirty()
        };

        // Remove all subflow nodes and move all nodes from subflow definition
        // to the active workspace
        if (ev.nodes) {
            inverseEv.movedNodes = [];
            const z = ev.activeWorkspace;
            // Get all nodes from the subflow definition
            let fullNodeList = RED.nodes.filterNodes({ z: ev.subflow.subflow.id });
            fullNodeList = fullNodeList.concat(RED.nodes.groups(ev.subflow.subflow.id));
            fullNodeList = fullNodeList.concat(RED.nodes.junctions(ev.subflow.subflow.id));
            fullNodeList.forEach(function (n) {
                n.x += ev.subflow.offsetX;
                n.y += ev.subflow.offsetY;
                n.dirty = true;
                inverseEv.movedNodes.push(n.id);
                RED.nodes.moveNodeToTab(n, z);
            });
            inverseEv.subflows = [];
            for (let i = 0; i < ev.nodes.length; i++) {
                inverseEv.subflows.push(nodeOrJunction(ev.nodes[i]));
                RED.nodes.remove(ev.nodes[i]);
            }
        }

        // Remove each link (from the conversion - inside the subflow)
        if (ev.links) {
            inverseEv.links = [];
            for (let i = 0; i < ev.links.length; i++) {
                inverseEv.links.push(ev.links[i]);
                RED.nodes.removeLink(ev.links[i]);
            }
        }

        // Remove the subflow (tab)
        inverseEv.subflow = ev.subflow;
        RED.nodes.removeSubflow(ev.subflow.subflow);
        RED.workspaces.remove(ev.subflow.subflow);

        // Add each link (from the undo of conversion - active workspace)
        if (ev.removedLinks) {
            inverseEv.createdLinks = [];
            for (let i = 0; i < ev.removedLinks.length; i++) {
                inverseEv.createdLinks.push(ev.removedLinks[i]);
                RED.nodes.addLink(ev.removedLinks[i]);
            }
        }

        return inverseEv;
    }

    /**
     * Called on the `deleteSubflow` history event
     *
     * @typedef {object} DeleteSubflowEvent
     * @property {"deleteSubflow"} t The history event type
     * @property {string} activeWorkspace The id of the active workspace
     * @property {Array<Link>} [createdLinks] An array with added links
     * (during undo conversion to Subflow - links from active workspace)
     * @property {Array<Link>} [links] An array with removed links (during
     * undo conversion to Subflow - links inside the subflow)
     * @property {Array<Node>} [movedNodes] An array with nodes to move to the
     * subflow to create
     * @property {{ subflow: Subflow, offsetX: number | undefined,
     * offsetY: number | undefined }} subflow The deleted subflow to create
     * @property {Array<Subflow>} [subflows] An array with subflow nodes
     * (redo conversion to subflow)
     * @memberof RED.history
     *
     * @param {DeleteSubflowEvent} ev The history event to undo
     * @returns {CreateSubflowEvent} The generated history event to redo
     */
    function onDeleteSubflow(ev) {
        const inverseEv = {
            t: "createSubflow",
            activeWorkspace: ev.activeWorkspace,
            dirty: RED.nodes.dirty(),
        };

        // Add the subflow (tab)
        if (ev.subflow) {
            RED.nodes.addSubflow(ev.subflow.subflow);
            inverseEv.subflow = ev.subflow;
            if (ev.subflow.subflow.g) {
                // TODO: why?
                RED.group.addToGroup(RED.nodes.group(ev.subflow.subflow.g), ev.subflow.subflow);
            }
        }

        // Create all subflow nodes
        if (ev.subflows) {
            inverseEv.nodes = [];
            for (let i = 0; i < ev.subflows.length; i++) {
                RED.nodes.add(ev.subflows[i]);
                inverseEv.nodes.push(ev.subflows[i].id);
            }
        }

        // Move each node from the active workspace to the subflow created
        // Nodes selected for the conversion to subflow
        if (ev.movedNodes) {
            ev.movedNodes.forEach(function (nid) {
                let nn = RED.nodes.node(nid);
                if (!nn) {
                    nn = RED.nodes.group(nid);
                }
                nn.x -= ev.subflow.offsetX;
                nn.y -= ev.subflow.offsetY;
                nn.dirty = true;
                RED.nodes.moveNodeToTab(nn, ev.subflow.subflow.id);
            });
        }

        // Add each link (from redo of conversion - inside the subflow)
        if (ev.links) {
            inverseEv.links = [];
            for (let i = 0; i < ev.links.length; i++) {
                inverseEv.links.push(ev.links[i]);
                RED.nodes.addLink(ev.links[i]);
            }
        }

        // Remove each link (from redo of conversion - on active workspace)
        if (ev.createdLinks) {
            inverseEv.removedLinks = [];
            for (let i = 0; i < ev.createdLinks.length; i++) {
                inverseEv.removedLinks.push(ev.createdLinks[i]);
                RED.nodes.removeLink(ev.createdLinks[i]);
            }
        }

        return inverseEv;
    }

    /**
     * Called on the `reorder` history event
     *
     * @typedef {object} ReorderEvent
     * @property {"reorder"} t The history event type
     * @property {{ from: string, to: string, z: string }} [nodes]
     * @property {object} [workspaces]
     * @property {Array<string>} workspaces[].from Ordered array of workspace ids
     * @property {Array<string>} workspaces[].to Ordered array of workspace ids
     * @memberof RED.history
     *
     * @param {ReorderEvent} ev The history event to undo
     * @returns {ReorderEvent} The generated history event to redo
     */
    function onReoder(ev) {
        const inverseEv = {
            t: "reorder",
            dirty: RED.nodes.dirty()
        };

        if (ev.workspaces) {
            inverseEv.workspaces = {
                from: ev.workspaces.to,
                to: ev.workspaces.from
            }
            RED.workspaces.order(ev.workspaces.from);
        }

        // TODO: still used? Maybe replace by convertToSubflow
        if (ev.nodes) {
            inverseEv.nodes = {
                z: ev.nodes.z,
                from: ev.nodes.to,
                to: ev.nodes.from
            }
            RED.nodes.setNodeOrder(ev.nodes.z, ev.nodes.from);
        }

        return inverseEv;
    }

    /**
     * Called on the `createGroup` history event
     *
     * @typedef {object} CreateGroupEvent
     * @property {"createGroup"} t The history event type
     * @property {Array<Group>} [groups] An array with groups to remove
     * @memberof RED.history
     *
     * @param {CreateGroupEvent} ev The history event to undo
     * @returns {UngroupEvent} The generated history event to redo
     */
    function onCreateGroup(ev) {
        const inverseEv = {
            t: "ungroup",
            dirty: RED.nodes.dirty(),
            groups: []
        };

        // For each group, remove each node from the group then delete the group
        if (ev.groups) {
            for (let i = 0; i < ev.groups.length; i++) {
                inverseEv.groups.push(ev.groups[i]);
                RED.group.ungroup(ev.groups[i]);
            }
        }

        return inverseEv;
    }

    /**
     * Called on the `ungroup` history event
     *
     * @typedef {object} UngroupEvent
     * @property {"ungroup"} t The history event type
     * @property {Array<Group>} [groups] An array with groups to create
     * @memberof RED.history
     *
     * @param {UngroupEvent} ev The history event to undo
     * @returns {CreateGroupEvent} The generated history event to redo
     */
    function onUngroup(ev) {
        const inverseEv = {
            t: "createGroup",
            dirty: RED.nodes.dirty(),
            groups: []
        };

        if (ev.groups) {
            for (let i = 0; i < ev.groups.length; i++) {
                inverseEv.groups.push(ev.groups[i]);
                const nodes = ev.groups[i].nodes.slice();
                ev.groups[i].nodes = [];
                // Create the group
                RED.nodes.addGroup(ev.groups[i]);
                // Add each node to the created group
                RED.group.addToGroup(ev.groups[i], nodes);
                if (ev.groups[i].g) {
                    // If the created group has a parent group, add to it
                    const parentGroup = RED.nodes.group(ev.groups[i].g);
                    if (parentGroup) {
                        RED.group.addToGroup(parentGroup, ev.groups[i]);
                    }
                }
            }
        }

        return inverseEv;
    }

    /**
     * Called on the `addToGroup` history event
     *
     * @typedef {object} AddToGroupEvent
     * @property {"addToGroup"} t The history event type
     * @property {Group} group The group in which remove nodes
     * @property {Array<Node> | Node} [nodes] An array of nodes or one node
     * to remove from the group
     * @property {boolean} [reparent] Either to re-add to parent group
     * @memberof RED.history
     *
     * @param {AddToGroupEvent} ev The history event to undo
     * @returns {RemoveFromGroupEvent} The generated history event to redo
     */
    function onAddTogroup(ev) {
        const inverseEv = {
            t: "removeFromGroup",
            dirty: RED.nodes.dirty(),
            group: ev.group,
            nodes: ev.nodes,
            reparent: ev.reparent
        };

        // Remove each node from the group
        if (ev.nodes) {
            RED.group.removeFromGroup(ev.group, ev.nodes, (ev.hasOwnProperty("reparent") && ev.hasOwnProperty("reparent") !== undefined) ? ev.reparent : true);
        }

        return inverseEv;
    }

    /**
     * Called on the `removeFromGroup` history event
     *
     * @typedef {object} RemoveFromGroupEvent
     * @property {"removeFromGroup"} t The history event type
     * @property {Group} group The group in which add nodes
     * @property {Array<Node> | Node} [nodes] An array of nodes or one node
     * to add to the group
     * @property {boolean} [reparent] Either to re-add to parent group
     * @memberof RED.history
     *
     * @param {RemoveFromGroupEvent} ev The history event to undo
     * @returns {AddToGroupEvent} The generated history event to redo
     */
    function onRemoveFromgroup(ev) {
        const inverseEv = {
            t: "addToGroup",
            dirty: RED.nodes.dirty(),
            group: ev.group,
            nodes: ev.nodes,
            reparent: ev.reparent
        };

        // Add each node to the group
        if (ev.nodes) {
            RED.group.addToGroup(ev.group, ev.nodes);
        }

        return inverseEv;
    }

    /**
     * Called on the `edit` history event
     *
     * @typedef {object} EditEvent
     * @property {"edit"} t The history event type
     * @property {boolean} changed The changed node state before modifications
     * @property {object} changes An object with previous node properties value
     * @property {Array<Link>} [createdLinks] An array with links to create (redo)
     * @property {Array<Link>} [links] An array with removed links
     * @property {Node} node The current node/subflow
     * @property {object} [outputMap]
     * @property {{ instances: Array<Node> | undefined,
     * inputCount: number | undefined, outputCount: number | undefined,
     * status: string | undefined }} [subflow] Subflow properties
     * @memberof RED.history
     *
     * @param {EditEvent} ev The history event to undo
     * @returns {EditEvent} The generated history event to redo
     */
    function onEdit(ev) {
        const inverseEv = {
            t: "edit",
            changes: {},
            changed: ev.node.changed,
            dirty: RED.nodes.dirty(),
            node: ev.node
        };

        // Apply old values to the current node
        // And saves values ​​changed by old values for the redo
        // TODO: Create a function like `RED.editor.updateNodeproperties`?
        // => `RED.nodes.updateNodeproperties(node, changes)`
        for (const i in ev.changes) {
            if (ev.changes.hasOwnProperty(i)) {
                inverseEv.changes[i] = ev.node[i];
                if (ev.node._def.defaults && ev.node._def.defaults[i] && ev.node._def.defaults[i].type) {
                    // This property is a reference to another node or nodes.
                    let nodeList = ev.node[i];
                    if (!Array.isArray(nodeList)) {
                        nodeList = [nodeList];
                    }

                    // Remove the node from each config node users
                    // TODO: remove only if ot used
                    nodeList.forEach(function (id) {
                        const currentConfigNode = RED.nodes.node(id);
                        if (currentConfigNode && currentConfigNode._def.category === "config") {
                            currentConfigNode.users.splice(currentConfigNode.users.indexOf(ev.node), 1);
                            RED.events.emit("nodes:change", currentConfigNode);
                        }
                    });

                    nodeList = ev.changes[i];
                    if (!Array.isArray(nodeList)) {
                        nodeList = [nodeList];
                    }

                    // Add the node to each config node users
                    nodeList.forEach(function (id) {
                        const newConfigNode = RED.nodes.node(id);
                        if (newConfigNode && newConfigNode._def.category === "config") {
                            newConfigNode.users.push(ev.node);
                            RED.events.emit("nodes:change", newConfigNode);
                        }
                    });
                }
                ev.node[i] = ev.changes[i];
            }
        }

        // The value of ev.node.changed is true (setted before to add to the history)
        // During the undo, need to set the value the property had before it was set to true
        ev.node.dirty = true;
        ev.node.changed = ev.changed;

        let eventType;
        switch (ev.node.type) {
            case "tab": eventType = "flows"; break;
            case "group": eventType = "groups"; break;
            case "subflow": eventType = "subflows"; break;
            default: eventType = "nodes"; break;
        }

        // Trigger the event after modifying the node
        eventType += ":change";
        RED.events.emit(eventType, ev.node);

        // If it is a tab, show or hide the disabled icon
        if (ev.node.type === "tab" && ev.changes.hasOwnProperty("disabled")) {
            $("#red-ui-tab-" + (ev.node.id.replace(".", "-"))).toggleClass("red-ui-workspace-disabled", !!ev.node.disabled);
        }

        // If it is a tab, show or hide the locked icon
        if (ev.node.type === "tab" && ev.changes.hasOwnProperty("locked")) {
            $("#red-ui-tab-" + (ev.node.id.replace(".", "-"))).toggleClass("red-ui-workspace-locked", !!ev.node.locked);
        }

        if (ev.subflow) {
            inverseEv.subflow = {};
            // Update the input array - 0 or one element
            if (ev.subflow.hasOwnProperty("inputCount")) {
                inverseEv.subflow.inputCount = ev.node.in.length;
                if (ev.node.in.length > ev.subflow.inputCount) {
                    inverseEv.subflow.inputs = ev.node.in.slice(ev.subflow.inputCount);
                    ev.node.in.splice(ev.subflow.inputCount);
                } else if (ev.subflow.inputs.length > 0) {
                    ev.node.in = ev.node.in.concat(ev.subflow.inputs);
                }
            }

            // Update the outputs array - 0 or more elements
            if (ev.subflow.hasOwnProperty("outputCount")) {
                inverseEv.subflow.outputCount = ev.node.out.length;
                if (ev.node.out.length > ev.subflow.outputCount) {
                    inverseEv.subflow.outputs = ev.node.out.slice(ev.subflow.outputCount);
                    ev.node.out.splice(ev.subflow.outputCount);
                } else if (ev.subflow.outputs.length > 0) {
                    ev.node.out = ev.node.out.concat(ev.subflow.outputs);
                }
            }

            // Mark each subflow node as changed
            if (ev.subflow.hasOwnProperty("instances")) {
                inverseEv.subflow.instances = [];
                ev.subflow.instances.forEach(function (n) {
                    inverseEv.subflow.instances.push(n);
                    // TODO: why check if the node exist?
                    const node = RED.nodes.node(n.id);
                    if (node) {
                        node.changed = n.changed;
                        node.dirty = true;
                    }
                });
            }

            // Delete the current subflow status
            if (ev.subflow.hasOwnProperty("status")) {
                if (ev.subflow.status) {
                    delete ev.node.status;
                }
            }

            // Validate the subflow (tab)
            RED.editor.validateNode(ev.node);
            // Update each subflow node and validate it
            // TODO: instances prop can be used here
            RED.nodes.filterNodes({ type: "subflow:" + ev.node.id }).forEach(function (n) {
                n.inputs = ev.node.in.length;
                n.outputs = ev.node.out.length;
                RED.editor.updateNodeProperties(n);
                RED.editor.validateNode(n);
            });
        } else {
            let outputMap;
            if (ev.outputMap) {
                outputMap = {};
                inverseEv.outputMap = {};
                for (const port in ev.outputMap) {
                    if (ev.outputMap.hasOwnProperty(port) && ev.outputMap[port] !== "-1") {
                        outputMap[ev.outputMap[port]] = port;
                        inverseEv.outputMap[ev.outputMap[port]] = port;
                    }
                }
            }
            ev.node.__outputs = inverseEv.changes.outputs;
            RED.editor.updateNodeProperties(ev.node, outputMap);
            RED.editor.validateNode(ev.node);
        }

        // Add links previously removed (undo)
        if (ev.links) {
            inverseEv.createdLinks = [];
            for (let i = 0; i < ev.links.length; i++) {
                RED.nodes.addLink(ev.links[i]);
                inverseEv.createdLinks.push(ev.links[i]);
            }
        }

        // Remove links previously created (redo)
        if (ev.createdLinks) {
            inverseEv.links = [];
            for (let i = 0; i < ev.createdLinks.length; i++) {
                RED.nodes.removeLink(ev.createdLinks[i]);
                inverseEv.links.push(ev.createdLinks[i]);
            }
        }

        return inverseEv;
    }

    /**
     * Called on the `replace` history event
     *
     * @typedef {object} CompleteReplaceEvent
     * @property {"replace"} t The history event type
     * @property {Record<string, boolean>} changed An object with a node id
     * as key and the node changed property as value
     * @property {true} complete Either the {@link ReplaceEvent.config}
     * property contains the complete flows
     * @property {Array<Node>} config An array with the complete flows
     * @property {boolean} dirty The dirty state before replacement
     * @property {Record<string, boolean>} moved An object with a node id
     * as key and the node moved property as value
     * @property {string} rev A revision version
     * @memberof RED.history
     *
     * @typedef {object} IncompleteReplaceEvent
     * @property {"replace"} t The history event type
     * @property {false} [complete] Either the {@link ReplaceEvent.config}
     * property contains the complete flows
     * @property {Array<Node>} config An array with config nodes and/or
     * subflow definitions to replace.
     * @memberof RED.history
     *
     * @typedef {CompleteReplaceEvent|IncompleteReplaceEvent} ReplaceEvent
     * @memberof RED.history
     *
     * @param {ReplaceEvent} ev The history event to undo
     * @returns {ReplaceEvent} The generated history event to redo
     */
    function onReplace(ev) {
        let inverseEv;

        if (ev.complete) {
            // This is a replace of everything. We can short-cut
            // the logic by clearing everyting first, then importing
            // the ev.config.
            // Used by RED.diff.mergeDiff
            inverseEv = {
                t: "replace",
                config: RED.nodes.createCompleteNodeSet(),
                changed: {},
                moved: {},
                complete: true,
                rev: RED.nodes.version(),
                dirty: RED.nodes.dirty()
            };

            const selectedTab = RED.workspaces.active();
            inverseEv.config.forEach((n) => {
                const node = RED.nodes.node(n.id);
                if (node) {
                    inverseEv.changed[n.id] = node.changed;
                    // TODO: Why moved?
                    inverseEv.moved[n.id] = node.moved;
                }
            });

            RED.nodes.clear();
            const flowsToLock = new Set();
            const imported = RED.nodes.import(ev.config);
            // Clear all change flags from the import
            RED.nodes.dirty(false);

            imported.nodes.forEach(function (n) {
                if (ev.changed[n.id]) {
                    ensureUnlocked(n.z, flowsToLock)
                    n.changed = true;
                }
                if (ev.moved[n.id]) {
                    ensureUnlocked(n.z, flowsToLock)
                    n.moved = true;
                }
            });

            flowsToLock.forEach((flow) => {
                flow.locked = true;
            });

            RED.nodes.version(ev.rev);
            RED.view.redraw(true);
            RED.palette.refresh();
            RED.workspaces.refresh();
            RED.workspaces.show(selectedTab, true);
            RED.sidebar.config.refresh();
        } else {
            const importMap = {};

            ev.config.forEach(function (n) {
                importMap[n.id] = "replace";
            });

            const importedResult = RED.nodes.import(ev.config, { importMap: importMap });
            inverseEv = {
                t: "replace",
                config: importedResult.removedNodes,
                dirty: RED.nodes.dirty()
            };
        }

        return inverseEv;
    }

    /**
     * Called on the `multi` history event
     *
     * @typedef {object} MultiEvent
     * @property {"multi"} t The history event type
     * @property {Array<HistoryEvent>} events An array with events
     * @memberof RED.history
     *
     * @param {MultiEvent} ev The history event to undo
     * @returns {MultiEvent} The generated history event to redo
     */
    function onMultipleEvents(ev) {
        const inverseEv = {
            t: "multi",
            events: []
        };

        const len = ev.events.length;
        for (let i = len - 1; i >= 0; i--) {
            const redoEvent = undoEvent(ev.events[i]);
            inverseEv.events.push(redoEvent);
        }

        return inverseEv;
    }

    /**
     * Called to undo/redo the history event
     *
     * @param {HistoryEvent} ev The history event to undo
     * @returns {HistoryEvent} The generated history event to redo
     */
    function undoEvent(ev) {
        let modifiedTabs = {};
        let inverseEv;

        if (ev) {
            if (ev.t == "multi") {
                inverseEv = onMultipleEvents(ev);
            } else if (ev.t == "replace") {
                inverseEv = onReplace(ev);
            } else if (ev.t == "add") {
                inverseEv = onAdd(ev, modifiedTabs);
            } else if (ev.t == "delete") {
                inverseEv = onDelete(ev, modifiedTabs);
            } else if (ev.t == "move") {
                inverseEv = onMove(ev);
            } else if (ev.t == "edit") {
                inverseEv = onEdit(ev);
            } else if (ev.t == "createSubflow") {
                inverseEv = onCreateSubflow(ev);
            } else if (ev.t == "deleteSubflow") {
                inverseEv = onDeleteSubflow(ev);
            } else if (ev.t == "reorder") {
                inverseEv = onReoder(ev);
            } else if (ev.t == "createGroup") {
                inverseEv = onCreateGroup(ev);
            } else if (ev.t == "ungroup") {
                inverseEv = onUngroup(ev);
            } else if (ev.t == "addToGroup") {
                inverseEv = onAddTogroup(ev);
            } else if (ev.t == "removeFromGroup") {
                inverseEv = onRemoveFromgroup(ev);
            }

            if (ev.callback && typeof ev.callback === "function") {
                inverseEv = inverseEv || {};
                inverseEv.callback = ev.callback;
                ev.callback(ev);
            }

            Object.keys(modifiedTabs).forEach(function (id) {
                const subflow = RED.nodes.subflow(id);
                if (subflow) {
                    RED.editor.validateNode(subflow);
                }
            });

            RED.nodes.dirty(ev.dirty);
            RED.view.updateActive();
            RED.view.select(null);
            RED.workspaces.refresh();
            RED.sidebar.config.refresh();
            RED.subflow.refresh();

            return inverseEv;
        }
    }

    return {
        //TODO: this function is a placeholder until there is a 'save' event that can be listened to
        markAllDirty: function () {
            for (let i = 0; i < undoHistory.length; i++) {
                undoHistory[i].dirty = true;
            }
        },
        /**
         * Returns a list with undo events.
         * @returns {Array<HistoryEvent>} The list with undo events
         * @memberof RED.history
         */
        list: function () {
            return undoHistory;
        },
        /**
         * Returns a list with redo events.
         * @returns {Array<HistoryEvent>} The list with redo events
         * @memberof RED.history
         */
        listRedo: function () {
            return redoHistory;
        },
        /**
         * Returns the size of the list with redo events.
         * @returns {number} The size of the redo list
         * @memberof RED.history
         */
        depth: function () {
            return undoHistory.length;
        },
        /**
         * Pushes an event to the History. This event can be undo by
         * calling {@link RED.history.pop pop}.
         * @param {HistoryEvent} ev The event to push
         * @returns {void}
         * @memberof RED.history
         */
        push: function (ev) {
            undoHistory.push(ev);
            redoHistory = [];
            RED.menu.setDisabled("menu-item-edit-undo", false);
            RED.menu.setDisabled("menu-item-edit-redo", true);
        },
        /**
         * Called to undo an event.
         * Takes the last event of the undo list, do undo event and adds
         * the redo event generated to the redo list.
         * @returns {void}
         * @memberof RED.history
         */
        pop: function () {
            const ev = undoHistory.pop();
            const rev = undoEvent(ev);

            if (rev) {
                redoHistory.push(rev);
            }

            RED.menu.setDisabled("menu-item-edit-undo", undoHistory.length === 0);
            RED.menu.setDisabled("menu-item-edit-redo", redoHistory.length === 0);
        },
        /**
         * Returns the last event of undo list.
         * @returns {HistoryEvent}
         * @memberof RED.history
         */
        peek: function () {
            return undoHistory[undoHistory.length - 1];
        },
        /**
         * Replaces the last event of undo list by the event given
         * in parameter.
         * @param {HistoryEvent} ev The event to replace
         * @returns {void}
         * @memberof RED.history
         */
        replace: function (ev) {
            if (undoHistory.length === 0) {
                RED.history.push(ev);
            } else {
                undoHistory[undoHistory.length - 1] = ev;
            }
        },
        /**
         * Clears the undo list and redo list.
         * @returns {void}
         * @memberof RED.history
         */
        clear: function () {
            undoHistory = [];
            redoHistory = [];
            RED.menu.setDisabled("menu-item-edit-undo", true);
            RED.menu.setDisabled("menu-item-edit-redo", true);
        },
        /**
         * Called to redo an event.
         * Takes the last event of the redo list, do redo event and adds
         * the undo event generated to the undo list.
         * @returns {void}
         * @memberof RED.history
         */
        redo: function () {
            const ev = redoHistory.pop();

            if (ev) {
                const uev = undoEvent(ev);

                if (uev) {
                    undoHistory.push(uev);
                }
            }

            RED.menu.setDisabled("menu-item-edit-undo", undoHistory.length === 0);
            RED.menu.setDisabled("menu-item-edit-redo", redoHistory.length === 0);
        }
    };
})();
