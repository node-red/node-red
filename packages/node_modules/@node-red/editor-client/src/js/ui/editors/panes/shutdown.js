; (function () {
    const tabcontent = `
        <div class="form-row">
            <label for="node-input-timeout"><i class="fa fa-clock-o"></i> <span data-i18n="node-red:exec.label.timeout"></span></label>
            <input type="text" id="node-input-timeout" placeholder="10" style="width: 70px; margin-right: 5px;"> <span data-i18n="node-red:inject.seconds"></span>
        </div>
        <div class="form-row node-input-scope-row" style="margin-bottom: 0px;">
            <input type="checkbox" id="node-input-failFast" style="display: inline-block; width: auto; vertical-align: top; margin-left: 30px; margin-right: 5px;">
            <label for="node-input-failFast" style="width: auto;"><span data-i18n="editor.failFast"></span></label>
        </div>
        <div class="form-row node-input-scope-row" style="min-height: 100px; height: 10%;">
            <div id="node-input-scope-target-container-div"></div>
        </div>
        <div class="form-row">
            <label style="width: auto" data-i18n="editor:editor.initiatorNodes""></label>
        </div>
        <div class="form-row node-input-target-row">
            <button type="button" id="node-input-initiator-target-select" class="red-ui-button" data-i18n="node-red:common.label.selectNodes"></button>
        </div>
        <div class="form-row node-input-target-row node-input-initiator-list-row" style="position: relative; min-height: 200px;">
            <div style="position: absolute; top: -30px; right: 0;"><input type="text" id="node-input-initiator-target-filter"></div>
            <div id="node-input-initiator-target-container-div"></div>
        </div>`;

    RED.editor.registerEditPane("editor-tab-shutdown", function (node) {
        return {
            label: RED._("editor-tab.shutdown"),
            name: RED._("editor-tab.shutdown"),
            iconClass: "fa fa-power-off",

            create: function (container) {
                const dialogForm = $('<form class="dialog-form form-horizontal" autocomplete="off"></form>').appendTo(container);

                if (RED.settings.gracefulShutdownEnabled) {
                    $(tabcontent).appendTo(dialogForm);
                    buildScopeForm(dialogForm, node);
                    buildInitiatorForm(dialogForm, node);
                    $("#node-input-timeout").spinner({ min: 1 }).val((node.timeout || 10000) / 1000);
                    $("#node-input-failFast").prop("checked", node.failFast || false);
                    this._resize = function () {
                        const rows = $(dialogForm).find(">div:not(.node-input-initiator-list-row)");
                        let height = $(dialogForm).height();
                        for (let i = 0; i < rows.length; i++) {
                            height -= $(rows[i]).outerHeight(true);
                        }
                        $(dialogForm).find(">div.node-input-initiator-list-row").css("height", height + "px");
                    };
                } else {
                    $("<p>Graceful shutdown disabled</p>").appendTo(dialogForm);
                }
            },
            close: function () { },
            show: function () { },
            resize: function (_size) {
                if (this._resize) {
                    this._resize();
                }
            },
            /** @type {(editState: { changes?: Record<string, unknown>, changed?: boolean }) => void} */
            apply: function (editState) {
                const failFast = $("#node-input-failFast").prop("checked");
                if (node.failFast != failFast) {
                    editState.changes = editState.changes || {};
                    editState.changes.failFast = node.failFast;
                    editState.changed = true;
                    node.failFast = failFast;
                }

                let timeout = parseFloat($("#node-input-timeout").val() || "10") * 1000;
                if (Number.isNaN(timeout)) {
                    timeout = 10000;
                }
                if (node.timeout !== timeout) {
                    editState.changes = editState.changes || {};
                    editState.changes.timeout = node.timeout;
                    editState.changed = true;
                    node.timeout = timeout;
                }

                const initiatorNodes = $("#node-input-initiator-target-container-div").treeList("selected").map((i) => i.node.id);
                if (JSON.stringify(initiatorNodes) !== JSON.stringify(node.initiatorNodes || [])) {
                    editState.changes = editState.changes || {};
                    editState.changes.initiatorNodes = node.initiatorNodes;
                    editState.changed = true;
                    node.initiatorNodes = initiatorNodes;
                }
            }
        }
    });

    /** @type {(node: object) => JQuery} */
    function getNodeLabel(node) {
        var div = $('<div>',{class:"red-ui-node-list-item red-ui-info-outline-item"});
        RED.utils.createNodeIcon(node, true).appendTo(div);
        div.find(".red-ui-node-label").addClass("red-ui-info-outline-item-label")
        return div;
    }

    /** @type {(container: JQuery, node: object) => void} */
    function buildScopeForm(container, node) {
        const scope = getScope(node);

        if (!scope.length) {
            $(container).find(".node-input-scope-row").hide();
            return;
        }

        const items = [];
        const flowItemMap = {};
        for (const id of scope) {
            if (id === node.id) {
                continue;
            }

            const isSuflow = id.startsWith("subflow:");
            const workspace = isSuflow ? RED.nodes.subflow(id.substring(8)) : RED.nodes.workspace(id);
            if (workspace) {
                flowItemMap[workspace.id] = {
                    element: getNodeLabel(workspace),
                    selected: true,
                };

                items.push(flowItemMap[workspace.id]);
            }
        }

        // TODO: filter items
        const dirList = $(container).find("#node-input-scope-target-container-div");
        dirList.css({ width: "100%", height: "100%" }).treeList({ multi: true, data: items });
    }

    /** @type {(container: JQuery, node: object) => void} */
    function buildInitiatorForm(container, node) {
        const dirList = $(container).find("#node-input-initiator-target-container-div");

        // We assume that a message initiator node must have at least one output
        const nodeFilter = function (n) {
            if (n.type.startsWith("link ")) {
                // Link nodes transmits messages, but does not generate them.
                return false;
            }
            if (n.hasOwnProperty("outputs")) {
                return n.outputs > 0;
            }
            return true;
        };
        const candidateNodes = RED.nodes.filterNodes({ z: node.id }).filter(nodeFilter);
        const search = $(container).find("#node-input-initiator-target-filter").searchBox({
            style: "compact",
            delay: 300,
            change: function () {
                const val = $(this).val().trim().toLowerCase();
                if (val === "") {
                    dirList.treeList("filter", null);
                    search.searchBox("count", "");
                } else {
                    const count = dirList.treeList("filter", function (item) {
                        return item.label.toLowerCase().indexOf(val) > -1 || item.node.type.toLowerCase().indexOf(val) > -1
                    });
                    search.searchBox("count", count + " / " + candidateNodes.length);
                }
            }
        });

        dirList.css({ width: "100%", height: "100%" })
            .treeList({ multi: true }).on("treelistitemmouseover", function (e, item) {
                item.node.highlighted = true;
                item.node.dirty = true;
                RED.view.redraw();
            }).on("treelistitemmouseout", function (e, item) {
                item.node.highlighted = false;
                item.node.dirty = true;
                RED.view.redraw();
            });

        const items = [];
        const nodeItemMap = {};
        const scope = node.initiatorNodes || [];
        candidateNodes.forEach(function (n) {
            const isChecked = scope.indexOf(n.id) !== -1;
            const nodeDef = RED.nodes.getType(n.type);
            let label, sublabel;
            if (nodeDef) {
                const l = nodeDef.label;
                label = (typeof l === "function" ? l.call(n) : l) || "";
                sublabel = n.type;
                if (sublabel.indexOf("subflow:") === 0) {
                    const subflowId = sublabel.substring(8);
                    const subflow = RED.nodes.subflow(subflowId);
                    sublabel = "subflow : " + subflow.name;
                }
            }
            if (!nodeDef || !label) {
                label = n.type;
            }
            nodeItemMap[n.id] = {
                node: n,
                label: label,
                sublabel: sublabel,
                selected: isChecked,
                checkbox: true
            };

            items.push(nodeItemMap[n.id]);
        });

        dirList.treeList("data", items);

        $(container).find("#node-input-initiator-target-select").on("click", function (event) {
            event.preventDefault();
            const preselected = dirList.treeList("selected").map((item) => item.node.id);
            RED.tray.hide();
            RED.view.selectNodes({
                selected: preselected,
                onselect: function (selection) {
                    RED.tray.show();
                    const newlySelected = {};
                    selection.forEach(function (n) {
                        newlySelected[n.id] = true;
                        if (nodeItemMap[n.id]) {
                            nodeItemMap[n.id].treeList.select(true);
                        }
                    });
                    preselected.forEach(function (id) {
                        if (!newlySelected[id]) {
                            nodeItemMap[id].treeList.select(false);
                        }
                    });
                },
                oncancel: function () {
                    RED.tray.show();
                },
                filter: nodeFilter,
            });
        });
    }

    /** @type {(flow: object) => string[]} */
    function getScope(flow) {
        // TODO: Scope = flows + initiator subflow
        const activeWorkspace = flow.id;
        /** @type {(node: object) => boolean} */
        const nodeFilter = (n) => n.type.startsWith("link ") || n.type.startsWith("subflow:");
        const nodes = RED.nodes.filterNodes({ z: activeWorkspace }).filter(nodeFilter);
        const seen = new Set();
        const scope = { [activeWorkspace]: true };
        seen.add(activeWorkspace);
        while (nodes.length) {
            const node = nodes.pop();
            if (seen.has(node.id)) {
                continue;
            }
            seen.add(node.id);
            if (node.links) {
                node.links.forEach((id) => {
                    const link = RED.nodes.node(id);
                    if (link && !scope[link.z]) {
                        scope[link.z] = true;
                        nodes.push(...RED.nodes.filterNodes({ z: link.z }).filter(nodeFilter));
                    }
                })
            } else if (node.type.startsWith("subflow:") && !scope[node.type]) {
                scope[node.type] = true;
                nodes.push(...RED.nodes.filterNodes({ z: node.type.substring(8) }).filter(nodeFilter));
            }
        }
        delete scope[activeWorkspace];
        return Object.keys(scope);
    }

})();
