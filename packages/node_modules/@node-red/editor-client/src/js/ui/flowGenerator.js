// Define the flow generator module
(function() {
    var availableNodeTypes = null;
    var baseFlow = null;
    
    // Public API
    var flowGenerator = {
        init: init,
        generateFlow: generateFlow,
        showGenerationDialog: showGenerationDialog,
        showFlowResult: showFlowResult
    };
    
    // Make it available globally
    RED.flowGenerator = flowGenerator;
    
    function init() {
        try {
            // Ensure nodes registry is available
            if (!RED.nodes || !RED.nodes.registry || typeof RED.nodes.registry.getNodeDefinitions !== 'function') {
                console.warn("Node registry not available yet, retrying...");
                setTimeout(init, 100);
                return;
            }
            
            // Initialize base flow
            baseFlow = {
                id: generateId(16),
                type: 'tab',
                label: 'Generated Flow',
                disabled: false,
                info: 'Auto-generated flow',
                env: []
            };
            
            // Check if the node registry is properly loaded
            const checkNodeRegistry = function() {
                const allNodeTypes = RED.nodes.registry.getNodeDefinitions();
                console.log('Checking node registry...');
                
                // Check if we have proper node definitions
                if (!allNodeTypes || typeof allNodeTypes !== 'object') {
                    console.warn('Node registry not fully loaded yet, retrying in 500ms...');
                    setTimeout(checkNodeRegistry, 500);
                    return;
                }
                
                const nodeTypeKeys = Object.keys(allNodeTypes);
                console.log('Total node types available:', nodeTypeKeys.length);
                
                // If we have no node types or they're not properly loaded yet, retry
                if (nodeTypeKeys.length <= 1) {
                    console.warn('Not enough node types loaded yet, retrying in 500ms...');
                    setTimeout(checkNodeRegistry, 500);
                    return;
                }
                
                // Check if the node types have proper structure
                const hasValidNodeTypes = nodeTypeKeys.some(key => {
                    const nodeDef = allNodeTypes[key];
                    return nodeDef && nodeDef.type && typeof nodeDef.type === 'string';
                });
                
                if (!hasValidNodeTypes) {
                    console.warn('Node types not properly structured yet, retrying in 500ms...');
                    setTimeout(checkNodeRegistry, 500);
                    return;
                }
                
                console.log('Node registry properly loaded with', nodeTypeKeys.length, 'node types');
                
                // Log a few sample node types for debugging
                const sampleNodes = nodeTypeKeys.slice(0, 5).map(key => {
                    const node = allNodeTypes[key];
                    return node ? { id: key, type: node.type, category: node.category } : 'undefined';
                });
                console.log('Sample node types:', sampleNodes);
                
                // Now proceed with filtering
                filterNodeTypes(allNodeTypes);
            };
            
            // Function to filter node types
            const filterNodeTypes = function(allNodeTypes) {
                // Filter node types to only include specific types or viso category
                availableNodeTypes = {};
                const targetTypes = new Set([
                    "video-feed-video-file", 
                    "object-detection-tracking", 
                    "visualization", 
                    "inject", 
                    "function", 
                    "switch", 
                    "change", 
                    "delay", 
                    "filter", 
                    "mqtt out", 
                    "http request", 
                    "join"
                ]);
                console.log('Target types we are looking for:', [...targetTypes]);
                
                let foundTargetTypes = 0;
                let foundVisoCategories = 0;
                
                Object.entries(allNodeTypes).forEach(([nodeId, nodeDef]) => {
                    if (!nodeDef) return;
                    
                    const nodeType = nodeDef.type;
                    if (!nodeType) return;
                    
                    const isTargetType = targetTypes.has(nodeType);
                    const isVisoCategory = nodeDef.category === 'viso';
                    
                    if (isTargetType) {
                        foundTargetTypes++;
                    }
                    
                    if (isVisoCategory) {
                        foundVisoCategories++;
                    }
                    
                    if (isTargetType || isVisoCategory) {
                        availableNodeTypes[nodeId] = nodeDef;
                    }
                });
                
                console.log(`Found ${foundTargetTypes} target types and ${foundVisoCategories} viso category nodes`);
                console.log('Filtered node types loaded:', Object.keys(availableNodeTypes).length);
                
                // If no filtered nodes, fall back to all nodes
                if (Object.keys(availableNodeTypes).length === 0) {
                    console.warn('No filtered node types found, falling back to all node types');
                    availableNodeTypes = allNodeTypes;
                    console.log('Using all node types instead:', Object.keys(availableNodeTypes).length);
                }
                
                // Continue with UI initialization
                completeInitialization();
            };
            
            // Function to complete initialization after node types are loaded
            const completeInitialization = function() {
                // Initialize UI
                initializeUI();
                
                console.log('Flow generator initialization completed successfully');
            };
            
            // Start the node registry check
            checkNodeRegistry();
        } catch (error) {
            console.error('Error initializing flow generator:', error);
            RED.notify('Error initializing flow generator: ' + error.message, 'error');
        }
    }

    function initializeUI() {
        console.log('Initializing flow generator UI...');
        
        // Create sidebar content
        const content = document.createElement('div');
        content.className = 'red-ui-sidebar-content';
        content.style.padding = '20px';
        
        const button = document.createElement('button');
        button.className = 'red-ui-button';
        button.innerHTML = '<i class="fa fa-magic"></i> Generate Flow';
        button.style.width = '100%';
        button.style.marginBottom = '10px';
        
        // Add click handler for the button
        button.addEventListener('click', showGenerationDialog);
        
        content.appendChild(button);
        
        // Add tab to sidebar
        RED.sidebar.addTab({
            id: "flow-generator",
            label: "Flow Gen",
            name: "Flow Generator",
            content: content,
            iconClass: "fa fa-magic",
            enableOnEdit: true
        });
        
        // Update the tab order to place the flow generator tab after chatbot
        var currentOrder = RED.settings.get("editor.sidebar.order", ["chatbot", "info", "help", "version-control", "debug"]);
        if (!currentOrder.includes("flow-generator")) {
            var chatbotIndex = currentOrder.indexOf("chatbot");
            if (chatbotIndex !== -1) {
                currentOrder.splice(chatbotIndex + 1, 0, "flow-generator");
            } else {
                currentOrder.unshift("flow-generator");
            }
            RED.settings.set("editor.sidebar.order", currentOrder);
        }
    }

    function showGenerationDialog() {
        console.log('showGenerationDialog called');
        try {
            // Create overlay first
            const overlay = document.createElement('div');
            overlay.className = 'red-ui-dialog-overlay';
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.right = '0';
            overlay.style.bottom = '0';
            overlay.style.backgroundColor = 'rgba(0,0,0,0.5)';
            overlay.style.zIndex = '999';
            document.body.appendChild(overlay);
            
            // Create dialog
            const dialog = document.createElement('div');
            dialog.className = 'red-ui-dialog';
            dialog.style.width = '600px';
            dialog.style.position = 'fixed';
            dialog.style.top = '50%';
            dialog.style.left = '50%';
            dialog.style.transform = 'translate(-50%, -50%)';
            dialog.style.zIndex = '1000';
            dialog.style.backgroundColor = 'white';
            dialog.style.borderRadius = '4px';
            dialog.style.boxShadow = '0 10px 20px rgba(0,0,0,0.2)';
            dialog.style.padding = '20px';
            
            dialog.innerHTML = `
                <div class="red-ui-dialog-content">
                    <div class="form-row">
                        <label for="streamCount">Number of Streams:</label>
                        <input type="number" id="streamCount" min="1" max="4" value="1">
                    </div>
                </div>
                <div class="red-ui-dialog-footer">
                    <button id="generate-cancel">Cancel</button>
                    <button id="generate-ok" class="primary">Generate</button>
                </div>
            `;

            document.body.appendChild(dialog);

            // Function to safely close dialog
            function closeDialog() {
                try {
                    if (dialog && dialog.parentNode) {
                        document.body.removeChild(dialog);
                    }
                    if (overlay && overlay.parentNode) {
                        document.body.removeChild(overlay);
                    }
                } catch (err) {
                    console.error('Error closing dialog:', err);
                }
            }

            // Cancel button handler
            dialog.querySelector('#generate-cancel').addEventListener('click', function(e) {
                e.preventDefault();
                console.log('Cancel button clicked');
                closeDialog();
            });
            
            // Close when clicking on overlay
            overlay.addEventListener('click', function() {
                closeDialog();
            });

            // Generate button handler
            dialog.querySelector('#generate-ok').addEventListener('click', function() {
                console.log('Generate button clicked');
                try {
                    const streamCount = parseInt(document.getElementById('streamCount').value) || 1;
                    
                    // Use empty options object since we removed those fields from the UI
                    const options = {};

                    console.log('Generating flow with options:', options);
                    
                    // Generate the flow
                    console.log('Calling generateFlow...');
                    const flow = RED.flowGenerator.generateFlow(streamCount, options);
                    
                    if (!flow) {
                        throw new Error('Failed to generate flow: result was empty');
                    }
                    
                    console.log('Flow generated successfully:', flow);
                    closeDialog();
                    showFlowResult(flow);
                } catch (error) {
                    console.error('Error in generate button click handler:', error);
                    RED.notify('Error generating flow: ' + (error.message || 'Unknown error'), 'error');
                    
                    // If there's an error, log the full error object
                    if (error.stack) {
                        console.error('Error stack:', error.stack);
                    }
                }
        });
    } catch (error) {
        console.error('Error showing generation dialog:', error);
        RED.notify('Error showing generation dialog: ' + (error.message || 'Unknown error'), 'error');
    }
}

    function showFlowResult(flow) {
        try {
            const dialog = document.createElement('div');
            dialog.className = 'red-ui-dialog';
            dialog.style.width = '600px';
            dialog.style.maxHeight = '80vh';
            dialog.style.padding = '20px';
            dialog.style.backgroundColor = 'white';
            dialog.style.borderRadius = '4px';
            dialog.style.boxShadow = '0 10px 20px rgba(0,0,0,0.2)';
            dialog.style.position = 'fixed';
            dialog.style.top = '50%';
            dialog.style.left = '50%';
            dialog.style.transform = 'translate(-50%, -50%)';
            dialog.style.zIndex = '1000';
            dialog.style.display = 'flex';
            dialog.style.flexDirection = 'column';
            dialog.style.overflow = 'hidden';

            // Create a unique ID for the dialog for cleanup
            const dialogId = 'flow-result-dialog-' + Date.now();
            dialog.id = dialogId;

            // Format the flow JSON
            const flowJson = JSON.stringify(flow, null, 2);
            
            dialog.innerHTML = `
                <div class="red-ui-dialog-content" style="flex-grow: 1; display: flex; flex-direction: column; overflow: hidden;">
                    <h3>Generated Flow</h3>
                    <div style="flex-grow: 1; overflow: auto; margin: 10px 0; border: 1px solid #ddd; padding: 10px; background: #f5f5f5; font-family: monospace; white-space: pre; word-wrap: break-word;">
                        ${flowJson}
                    </div>
                    <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px;">
                        <button id="copy-flow" class="red-ui-button" style="padding: 8px 16px;">Copy to Clipboard</button>
                        <button id="import-flow" class="red-ui-button red-ui-button-primary" style="padding: 8px 16px;">Import Flow</button>
                        <button id="close-dialog" class="red-ui-button" style="padding: 8px 16px;">Close</button>
                    </div>
                </div>
            `;

            // Add overlay
            const overlay = document.createElement('div');
            overlay.className = 'red-ui-dialog-overlay';
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.right = '0';
            overlay.style.bottom = '0';
            overlay.style.backgroundColor = 'rgba(0,0,0,0.5)';
            overlay.style.zIndex = '999';
            
            // Insert overlay and dialog
            document.body.appendChild(overlay);
            document.body.appendChild(dialog);
            
            // Function to close the dialog
            function closeDialog() {
                if (dialog && dialog.parentNode) {
                    document.body.removeChild(dialog);
                }
                if (overlay && overlay.parentNode) {
                    document.body.removeChild(overlay);
                }
            }
            
            // Copy to clipboard
            dialog.querySelector('#copy-flow').addEventListener('click', function() {
                try {
                    const textArea = document.createElement('textarea');
                    textArea.value = flowJson;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    RED.notify('Flow copied to clipboard', 'success');
                } catch (err) {
                    console.error('Failed to copy text:', err);
                    RED.notify('Failed to copy to clipboard', 'error');
                }
            });
            
            // Import flow
            dialog.querySelector('#import-flow').addEventListener('click', function() {
                try {
                    RED.view.importNodes([flow]);
                    RED.notify('Flow imported successfully', 'success');
                    closeDialog();
                } catch (err) {
                    console.error('Error importing flow:', err);
                    RED.notify('Error importing flow: ' + err.message, 'error');
                }
            });
            
            // Close button handler
            dialog.querySelector('#close-dialog').addEventListener('click', function() {
                closeDialog();
            });
            
            // Close when clicking on overlay
            overlay.addEventListener('click', function() {
                closeDialog();
            });
            
        } catch (error) {
            console.error('Error showing flow result:', error);
            RED.notify('Error showing flow result: ' + error.message, 'error');
        }
    }

    function generateId(length) {
        length = length || 16;
        return Array.from({length}, () => 
            Math.floor(Math.random() * 16).toString(16)
        ).join('');
    }

    function getNodeDefaults(nodeType) {
        // Find the node definition in availableNodeTypes
        let nodeDef = null;
        for (const key in availableNodeTypes) {
            if (availableNodeTypes[key] && availableNodeTypes[key].type === nodeType) {
                nodeDef = availableNodeTypes[key];
                break;
            }
        }
        
        if (!nodeDef) {
            console.warn(`Node type ${nodeType} not found in availableNodeTypes`);
            return {};
        }
        
        // Get the node definition from the registry to ensure we have the most up-to-date defaults
        const registryDef = RED.nodes.getType(nodeType);
        
        // Start with an empty object
        const defaults = {};
        
        // If we have registry definition with defaults, use those
        if (registryDef && registryDef.defaults) {
            // For each property in defaults
            for (const key in registryDef.defaults) {
                // Get the default value, which might be a function or a direct value
                const defaultProperty = registryDef.defaults[key];
                if (typeof defaultProperty === 'object' && defaultProperty !== null) {
                    if (defaultProperty.value !== undefined) {
                        // If it's an object with a value property, use that value
                        defaults[key] = defaultProperty.value;
                    }
                } else if (typeof defaultProperty === 'function') {
                    // If it's a function, try to call it to get the default value
                    try {
                        defaults[key] = defaultProperty();
                    } catch (e) {
                        console.warn(`Error getting default for ${key}:`, e);
                    }
                } else {
                    // Otherwise use the direct value
                    defaults[key] = defaultProperty;
                }
            }
        } else if (nodeDef.defaults) {
            // Fall back to the availableNodeTypes defaults if registry doesn't have them
            Object.assign(defaults, nodeDef.defaults);
        }
        
        return defaults;
    }

    function createVideoFeedNode(streamCount, cameraNames) {
        streamCount = streamCount || 1;
        cameraNames = cameraNames || [];
        const nodeType = 'video-feed-video-file';
        
        // Check if the node type exists in availableNodeTypes
        let nodeTypeFound = false;
        for (const key in availableNodeTypes) {
            if (availableNodeTypes[key] && availableNodeTypes[key].type === nodeType) {
                nodeTypeFound = true;
                break;
            }
        }
        
        if (!availableNodeTypes || !nodeTypeFound) {
            console.warn(`Node type ${nodeType} not found in availableNodeTypes`);
            // Create a mock node since the actual node type isn't available
            return {
                id: generateId(16),
                type: nodeType,
                z: baseFlow.id,
                name: 'Video Feed',
                x: 300,
                y: 300,
                wires: []
            };
        }
        
        // Get default values from node definition
        const defaults = getNodeDefaults(nodeType);
        
        // Create port labels for each stream
        const portLabels = Array(streamCount).fill().map((_, i) => `stream${i + 1}`);
        
        // Create video sources configuration for each stream
        const videoSources = Array(streamCount).fill().map((_, i) => ({
            camera_name: cameraNames[i] || `Camera ${i + 1}`,
            video_source: "workspace",
            video_file_path: "",
            video_file: "",
            video_mode: "loop",
            resize_stream: "720p",
            frame_rate: "native"
        }));

        // Start with the defaults from the node definition
        const node = {
            ...defaults,
            // Base node properties that must be set for the flow
            id: generateId(16),
            type: nodeType,
            z: baseFlow.id,
            name: defaults.name || "Video Feed - Video File",
            
            // Only override the specific fields that need to be customized
            port_labels: portLabels,
            video_counts: streamCount,
            video_source_info: videoSources,
            outputs: streamCount,
            
            // Position in the flow
            x: 290,
            y: 300 + (streamCount * 20),
            
            // Wire connections - must be initialized for the flow
            wires: Array(streamCount).fill().map(() => [])
        };
        
        console.log('Created video feed node with defaults and customizations:', node);
        return node;
    }

    function createObjectDetectionTrackingNode(index, yPosition, options) {
        options = options || {};
        const nodeType = 'object-detection-tracking';
        
        // Check if the node type exists in availableNodeTypes
        let nodeTypeFound = false;
        for (const key in availableNodeTypes) {
            if (availableNodeTypes[key] && availableNodeTypes[key].type === nodeType) {
                nodeTypeFound = true;
                break;
            }
        }
        
        if (!availableNodeTypes || !nodeTypeFound) {
            console.warn(`Node type ${nodeType} not found in availableNodeTypes`);
            // Create a mock node since the actual node type isn't available
            return {
                id: generateId(16),
                type: nodeType,
                z: baseFlow.id,
                name: `Object Detection Tracking ${index + 1}`,
                x: 590,
                y: yPosition,
                wires: [[]]
            };
        }
        
        // Get default values from node definition
        const defaults = getNodeDefaults(nodeType);
        
        // Start with the defaults from the node definition
        const node = {
            ...defaults,
            // Base node properties that must be set for the flow
            id: generateId(16),
            type: nodeType,
            z: baseFlow.id,
            name: `Object Detection Tracking ${index + 1}`,
            
            // Position in the flow
            x: 590,
            y: yPosition,
            
            // Wire connections - will be set when connecting to visualization node
            wires: [[]]
        };
        
        // Only override specific fields if provided in options
        if (options.framework) node.framework = options.framework;
        if (options.devices) node.devices = options.devices;
        if (options.detectionLabels) node.detection_labels = options.detectionLabels;
        if (options.scoreThreshold) node.detection_score_threshold = options.scoreThreshold;
        
        console.log(`Created object detection node ${index} with defaults and customizations:`, node);
        return node;
    }

    function createVisualizationNode(yPosition, inputCount) {
        inputCount = inputCount || 1;
        const nodeType = 'visualizations';
        
        // Check if the node type exists in availableNodeTypes
        let nodeTypeFound = false;
        for (const key in availableNodeTypes) {
            if (availableNodeTypes[key] && availableNodeTypes[key].type === nodeType) {
                nodeTypeFound = true;
                break;
            }
        }
        
        if (!availableNodeTypes || !nodeTypeFound) {
            console.warn(`Node type ${nodeType} not found in availableNodeTypes`);
            // Create a mock node since the actual node type isn't available
            return {
                id: generateId(16),
                type: nodeType,
                z: baseFlow.id,
                name: 'Visualizations',
                x: 880,
                y: yPosition,
                wires: [[]]
            };
        }
        
        // Get default values from node definition
        const defaults = getNodeDefaults(nodeType) || {};
        
        // Start with the defaults from the node definition
        const node = {
            ...defaults,
            // Base node properties that must be set for the flow
            id: generateId(16),
            type: nodeType,
            z: baseFlow.id,
            name: defaults.name || 'Visualizations',
            
            // Only override specific fields that need to be customized
            port_labels: Array(inputCount).fill().map((_, i) => `input${i+1}`),
            outputs: inputCount,  // Set the number of inputs based on the number of detection nodes
            
            // Position in the flow
            x: 880,
            y: yPosition,
            
            // Wire connections - must be initialized for the flow
            wires: [[]]
        };
        
        console.log('Created visualization node with defaults and customizations:', node);
        return node;
    }

    function generateFlow(streamCount, options) {
        console.log('generateFlow called with:', { streamCount, options });
        try {
            streamCount = streamCount || 1;
            options = options || {};
            
            if (streamCount < 1 || streamCount > 4) {
                throw new Error("Number of streams must be between 1 and 4");
            }

            if (!baseFlow || !baseFlow.id) {
                throw new Error("Base flow not initialized. Call init() first.");
            }

            const flow = [baseFlow];
            // Generate default camera names if not provided
            const cameraNames = [];
            for (let i = 0; i < streamCount; i++) {
                cameraNames.push(`Camera ${i + 1}`);
            }
            const detectionNodes = [];
            
            console.log('Creating video feed node...');
            const videoFeedNode = createVideoFeedNode(streamCount, cameraNames);
            if (!videoFeedNode) throw new Error("Failed to create video feed node");
            
            flow.push(videoFeedNode);
            console.log('Video feed node created:', videoFeedNode);

            // Create object detection nodes
            console.log('Creating detection nodes...');
            for (let i = 0; i < streamCount; i++) {
                const yPos = 300 + (i * 100); // Increased spacing between nodes
                const detectionTrackingNode = createObjectDetectionTrackingNode(i, yPos, {
                    framework: options.framework,
                    devices: options.devices,
                    detectionLabels: options.detectionLabels,
                    scoreThreshold: options.scoreThreshold
                });
                
                if (!detectionTrackingNode || !detectionTrackingNode.id) {
                    console.error('Invalid detection node created:', detectionTrackingNode);
                    continue;
                }
                
                if (!videoFeedNode.wires) videoFeedNode.wires = [];
                videoFeedNode.wires[i] = [detectionTrackingNode.id];
                detectionNodes.push(detectionTrackingNode);
                flow.push(detectionTrackingNode);
                console.log(`Detection tracking node ${i} created:`, detectionTrackingNode);
            }

            // Create visualization node and connect all detection nodes to it
            if (detectionNodes.length > 0) {
                console.log('Creating visualization node...');
                const visualizationNode = createVisualizationNode(300 + (streamCount * 100), detectionNodes.length);
                
                if (!visualizationNode || !visualizationNode.id) {
                    console.error('Failed to create visualization node');
                } else {
                    // Connect all detection nodes to the visualization node
                    detectionNodes.forEach((node) => {
                        if (node) {
                            node.wires = [[visualizationNode.id]];
                        }
                    });
                    
                    flow.push(visualizationNode);
                    console.log('Visualization node created:', visualizationNode);
                }
            }

            console.log('Flow generation completed');
            return flow;
        } catch (error) {
            console.error('Error in generateFlow:', error);
            throw error; // Re-throw to be caught by the caller
        }
    }
    
    // Initialize when loaded in Node-RED environment
    if (typeof RED !== 'undefined') {
        RED.events.on('runtime-event', function(event) {
            if (event.id === 'runtime-state' && event.payload.enabled) {
                flowGenerator.init();
            }
        });
    }
})();

// Initialize when loaded in Node-RED environment
if (typeof RED !== 'undefined') {
    RED.flowGenerator.init();
}