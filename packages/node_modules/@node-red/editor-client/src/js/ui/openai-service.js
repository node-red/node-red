// TODO: Call it anthropic service
RED.openAIService = (function() {
    // Configuration object
    const config = {
        apiKey: "",
        model: "gpt-4.1",  // Default to OpenAI's gpt-4o
        temperature: 0
    };

    // Function to load configuration from Node-RED settings
    function loadConfig() {
        // First try to load from localStorage
        const savedApiKey = localStorage.getItem('node-red-openai-api-key');
        if (savedApiKey && savedApiKey.trim().length > 0) {
            config.apiKey = savedApiKey;
        }
        
        // Then check Node-RED settings (will override localStorage if present)
        if (RED.settings?.openai) {
            const { apiKey, model, temperature } = RED.settings.openai;
            if (apiKey) config.apiKey = apiKey;
            if (model) config.model = model;
            if (temperature !== undefined) config.temperature = temperature;
        }
    }
    
    // Function to update API key
    function updateApiKey(apiKey) {
        if (apiKey && apiKey.trim().length > 0) {
            config.apiKey = apiKey;
            return true;
        }
        return false;
    }

    function getSystemPrompt(availableNodeTypes, nodesInWorkspace) {
        return {
            role: "system",
            content: `You are a Node-RED assistant with three primary functions:

1. ANSWER QUESTIONS
   When providing general information, use normal_reply function.
   - Provide Node-RED knowledge, concepts, and functionality explanations
   - Share best practices and optimization tips
   - Help troubleshoot common issues

2. CREATE NEW FLOWS
   When creating a new flow, use create_flow function with valid JSON.
   - Generate complete, importable Node-RED flow JSON from user descriptions
   - Include only necessary nodes from the available node types
   - Ensure all nodes have unique names and IDs
   - Ensure wires are correctly specified for all nodes
   - Changes that depend on other changes must be added after the changes they depend on. For example, if you want to add a debug node to see the output of an existing function node:
     1. First add the change to create the debug node
     2. Then add the change to update the function node's wires to connect to the new debug node

3. UPDATE EXISTING FLOWS
   When modifying existing flows, use update_flow function with valid JSON.
   - Preserve all existing node IDs
   - Generate a list of changes one by one as shown in the function definitions.
   - Ensure wires are correctly specified for all nodes
   - Preserve the position of the nodes if it wasn't explicitly changed.

AVAILABLE NODE TYPES:
${JSON.stringify(availableNodeTypes)}

WORKSPACE CONTEXT:
${nodesInWorkspace ? `Currently visible nodes: ${JSON.stringify(nodesInWorkspace)}` : 'No nodes currently in workspace'}

RULES FOR USING VISO CATEGORY NODES:
- We define a computer vision node to be either an object detection or object detection tracking node from the viso category
- All flows must begin with a video feed node
- If a region of interest (ROI) is required, a region selection node must be connected immediately after the video feed node
- A computer vision node must immediately follow video feed node or region selection node
- All computer vision nodes must immediately be followed by a visualization node from viso, then a video view node from viso
- If function nodes are required, they must be added after the computer vision node
- Video feed node properties
    - If the user specifies the number of video streams required, the video count property and the number of output ports should be adjusted accordingly
- Object detection node properties
    - Use this instead of object detection tracking if you only need detect objects in a single frame
    - Returns this: msg.payload.result = [{\"class_id\":0,\"label\":\"person\",\"confidence\":0.92,\"rect\":[0.532,0.518,0.041,0.205],\"roi_id\":\"giawnjgsor\",\"roi_name\":\"roi1\"},{\"class_id\":0,\"label\":\"person\",\"confidence\":0.91,\"rect\":[0.573,0.531,0.043,0.204],\"roi_id\":\"giawnjgsor\",\"roi_name\":\"roi2\"}]
- Object detection tracking node properties
    - Use this instead of object detection if you need to track objects over time
    - It must only have one input port and one output port
    - Returns this: msg.payload.result = [{\"confidence\":0.94,\"class_id\":-1,\"label\":\"vehicle\",\"rect\":[0.68,0.54,0.02,0.06],\"tid\":2,\"status\":1,\"roi_id\":\"q39rn4ipne\",\"roi_name\":\"roi1\"},{\"confidence\":0.94,\"class_id\":-1,\"label\":\"vehicle\",\"rect\":[0.43,0.11,0.01,0.05],\"tid\":3,\"status\":1,\"roi_id\":\"q39rn4ipne\",\"roi_name\":\"roi1\"}]


CRITICAL REQUIREMENTS:
- Only use node types from the available list above
- The node definitions should be used exactly as they are and not modified
- Do not create custom nodes when standard nodes will work
- Generate valid, properly formatted JSON
- Wire connections must be flat arrays of strings
- For new flows: generate unique IDs for all nodes
- For updates: preserve all existing node IDs
- Always verify wire connections are correctly specified`
        };
    }

    function prepareMessages(userMessage, conversationHistory, availableNodeTypes, nodesInWorkspace) {
        const recentHistory = conversationHistory.slice(-1000);
        return [...recentHistory, {
            role: "user",
            content: userMessage
        }];
    }

    function getFunctionDefinitions() {
        return [
            {
                type: "function",
                function: {
                    name: "normal_reply",
                    description: "Used for standard conversation when the user is not requesting a flow to be created",
                    parameters: {
                        type: "object",
                        properties: {
                            response: {
                                type: "string",
                                description: "The assistant's response to the user's query"
                            }
                        },
                        required: ["response"]
                    }
                }
            },
            {
                type: "function",
                function: {
                    name: "create_flow",
                    description: "Creates a Node-RED flow based on the user description",
                    parameters: {
                        type: "object",
                        properties: {
                            flow: {
                                type: "string",
                                description: "The stringified JSON representation of the Node-RED flow that can be imported directly. Must be a valid JSON string."
                            },
                            explanation: {
                                type: "string",
                                description: "A detailed explanation of the flow, how it works, and any special considerations"
                            }
                        },
                        required: ["flow", "explanation"]
                    }
                }
            },
            {
                type: "function",
                function: {
                    name: "update_flow",
                    description: "Updates an existing flow using git-like change operations",
                    parameters: {
                        type: "object",
                        properties: {
                            changes: {
                                type: "array",
                                description: "List of git-like operations to apply to the flow",
                                items: {
                                    type: "object",
                                    properties: {
                                        operation: {
                                            type: "string",
                                            enum: ["add", "modify", "remove"],
                                            description: "Type of change operation"
                                        },
                                        nodeId: {
                                            type: "string",
                                            description: "ID of the node being modified"
                                        },
                                        value: {
                                            type: "string",
                                            description: "Entire Stringified JSON of the node to be added or modified"
                                        },
                                        description: {
                                            type: "string",
                                            description: "Description of the change"
                                        }
                                    },
                                    required: ["operation", "nodeId", "value", "description"]
                                }
                            },
                            explanation: {
                                type: "string",
                                description: "Overall explanation of the changes shown to the user"
                            }
                        },
                        required: ["changes", "explanation"]
                    }
                }
            }
        ];
    }

    async function callOpenAIAPI(messages, availableNodeTypes, nodesInWorkspace) {
        if (!config.apiKey) {
            throw new Error("OpenAI API key not configured. Please set it in the settings.");
        }

        // Get system prompt
        const systemPrompt = getSystemPrompt(availableNodeTypes, nodesInWorkspace).content;

        // Format messages for OpenAI
        const openaiMessages = [
            { role: "system", content: systemPrompt },
            ...messages.map(msg => {
                // If message is a string, assume it's from the user
                if (typeof msg === "string") {
                    return { role: "user", content: msg };
                }
                // If it's already in the correct format, use as is
                if (msg.role && msg.content) {
                    return msg;
                }
                // Fallback: convert to string
                return { 
                    role: "user", 
                    content: typeof msg === "object" ? JSON.stringify(msg) : String(msg)
                };
            })
        ];

        // Add important instructions to the last user message
        if (openaiMessages.length > 0) {
            const lastMessage = openaiMessages[openaiMessages.length - 1];
            if (lastMessage.role === "user") {
                lastMessage.content += "\n\nIMPORTANT: Beautify always the workflow based on the position and subflows";
                lastMessage.content += "\n\nIMPORTANT: If a node red plugin is needed, ask the user to install it first before creating the flow. If the user already has it installed, just use it.";
                lastMessage.content += "\n\nIMPORTANT: Always make sure changes in the update flow is a list of changes not a string.";
            }
        }

        try {
            const functionDefinitions = getFunctionDefinitions();
            const requestBody = {
                model: config.model || "gpt-4o",
                messages: openaiMessages,
                temperature: config.temperature || 0.7,
                max_tokens: 4000
            };

            // Only add tools and tool_choice if we have function definitions
            if (functionDefinitions.length > 0) {
                requestBody.tools = functionDefinitions;
                requestBody.tool_choice = "auto";  // Let the model decide when to call functions
            }
            
            console.log('OpenAI Request:', JSON.stringify(requestBody, null, 2));
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${config.apiKey}`
                },
                body: JSON.stringify(requestBody)
            });

            const data = await response.json();
            console.log('OpenAI Response:', JSON.stringify(data, null, 2));

            
            if (!response.ok) {
                console.error('OpenAI API Error:', data);
                throw new Error(`OpenAI API Error: ${data.error?.message || 'Unknown error'}`);
            }

            // Return the full response to be handled by processMessage
            return data;
        } catch (error) {
            console.error("OpenAI API call failed:", error);
            throw error;
        }
    }

    // Add a new utility function for safe JSON parsing with sanitization
    function safeParseJSON(jsonString) {
        if (!jsonString || typeof jsonString !== 'string') {
            return null;
        }

        try {
            // First try straight parsing
            return JSON.parse(jsonString);
        } catch (e) {
            // If parsing fails, try to sanitize the string
            try {
                // Sanitize the string by removing control characters and fixing escapes
                const sanitizedString = jsonString
                    .replace(/[\u0000-\u0009\u000B-\u000C\u000E-\u001F\u007F-\u009F]/g, "") // Remove control chars but keep \n \r \t
                    .replace(/\\(?!["\\/bfnrt])/g, "\\\\"); // Escape backslashes properly
                
                // Try parsing again
                return JSON.parse(sanitizedString);
            } catch (err) {
                // If it still fails, throw the original error
                console.error("Failed to parse JSON after sanitization:", err);
                console.error("JSON string: ", jsonString);
                throw e;
            }
        }
    }

    function handleNormalReply(functionArgs, nodesInWorkspace) {
        return {
            success: true,
            isFlow: false,
            isUpdate: false,
            content: functionArgs.response
        };
    }

    function handleCreateFlow(functionArgs, nodesInWorkspace) {
        try {
            const flowJson = safeParseJSON(functionArgs.flow);
            if (!flowJson) {
                throw new Error("Invalid flow JSON");
            }
            return {
                success: true,
                isFlow: true,
                flow: flowJson,
                description: functionArgs.explanation
            };
        } catch (e) {
            console.error("Error parsing flow JSON:", e);
            return {
                success: false,
                isFlow: false,
                content: "I tried to create a flow but encountered an error in the JSON format. Please try again with a simpler description.",
                error: e.message
            };
        }
    }

    function handleUpdateFlow(functionArgs, nodesInWorkspace) {
        console.log(functionArgs.changes, "changes");

        if (!Array.isArray(functionArgs.changes)) {
            functionArgs.changes = safeParseJSON(functionArgs.changes);
        }

        try {
            // Ensure changes are properly sanitized before processing
            const sanitizedChanges = functionArgs.changes.map(change => {
                // Clone the change object to avoid modifying the original
                const sanitizedChange = {...change};
                
                // If value exists and is a string, ensure it's valid JSON
                if (sanitizedChange.value && typeof sanitizedChange.value === 'string') {
                    // We don't actually modify the value here anymore, just verify it can be parsed
                    safeParseJSON(sanitizedChange.value);
                }
                return sanitizedChange;
            });
            
            flow = applyFlowChanges(nodesInWorkspace, sanitizedChanges);
            console.log(flow, "flow");
            return {
                success: true,
                isFlow: false,
                isUpdate: true,
                flow: flow,
                changes: sanitizedChanges.map(change => ({
                    ...change,
                    timestamp: Date.now(),
                    status: 'pending'
                })),
                description: functionArgs.explanation
            };
        } catch (e) {
            console.error("Error in handleUpdateFlow:", e);
            return {
                success: false,
                isFlow: false,
                isUpdate: true,
                content: "Error processing flow updates: " + e.message
            };
        }
    }

    // Add new utility function to apply changes
    function applyFlowChanges(currentFlow, changes) {
        const newFlow = currentFlow;

        changes.forEach(change => {
            const { operation, nodeId } = change;
            let nodeValue;
            
            try {
                if (change.value && change.value !== "") {
                    nodeValue = safeParseJSON(change.value);
                } else {
                    nodeValue = "";
                }
            } catch (e) {
                console.error(`Error parsing value for node ${nodeId}:`, e);
                return; // Skip this change if parsing fails
            }

            switch (operation) {
                case 'add':
                    // Add new node to the flow
                    newFlow.push(nodeValue);
                    break;
                    
                case 'modify':
                    // Find and update existing node
                    const nodeIndex = newFlow.findIndex(node => node.id === nodeId);
                    if (nodeIndex !== -1) {
                        newFlow[nodeIndex] = { ...newFlow[nodeIndex], ...nodeValue };
                    } else {
                        console.log("Couldn't find node", nodeId);
                    }
                    break;
                    
                case 'remove':
                    // Remove node from flow
                    const deleteIndex = newFlow.findIndex(node => node.id === nodeId);
                    if (deleteIndex !== -1) {
                        newFlow.splice(deleteIndex, 1);
                    } else {
                        console.log("Couldn't find node", nodeId);
                    }
                    break;
            }
        });

        return newFlow;
    }

    async function processMessage(userMessage, conversationHistory, availableNodeTypes, nodesInWorkspace) {
        const messages = prepareMessages(userMessage, conversationHistory, availableNodeTypes, nodesInWorkspace);
        const data = await callOpenAIAPI(messages, availableNodeTypes, nodesInWorkspace);
        
        // Handle tool calls in OpenAI's response
        if (data.choices && data.choices[0].message.tool_calls) {
            for (const toolCall of data.choices[0].message.tool_calls) {
                if (toolCall.type === 'function') {
                    const { name, arguments: args } = toolCall.function;
                    let functionArgs;
                    
                    try {
                        functionArgs = JSON.parse(args);
                    } catch (e) {
                        console.error('Failed to parse function arguments:', e);
                        return {
                            success: false,
                            error: 'Failed to parse function arguments',
                            content: "I encountered an error processing your request."
                        };
                    }

                    const handlers = {
                        normal_reply: handleNormalReply,
                        create_flow: handleCreateFlow,
                        update_flow: handleUpdateFlow
                    };

                    return handlers[name]?.(functionArgs, nodesInWorkspace) || 
                           handleNormalReply({ response: "I couldn't process your request properly." }, nodesInWorkspace);
                }
            }
        }
        
        // Handle direct text response
        if (data.choices && data.choices[0].message.content) {
            return {
                success: true,
                isFlow: false,
                isUpdate: false,
                content: data.choices[0].message.content
            };
        }

        return {
            success: true,
            isFlow: false,
            isUpdate: false,
            content: data.content[0].text
        };
    }

    // Legacy support
    async function createFlow(userMessage, conversationHistory, availableNodeTypes) {
        return processMessage(userMessage, conversationHistory, availableNodeTypes);
    }

    function init() {
        loadConfig();
    }

    return {
        init,
        createFlow,
        processMessage,
        loadConfig,
        applyFlowChanges,
        updateApiKey
    };
})(); 
