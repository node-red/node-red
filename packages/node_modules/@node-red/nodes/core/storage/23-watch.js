/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

module.exports = function(RED) {
    "use strict";
    const watch = require('node-watch')
    const fs = require("fs")
    const path = require("path")

    function configureWatcher(node, n) {
        if (node.filesType != 'msg') node.files = (n.files || "");
        node.files = node.files.split(",");
        for (var f=0; f < node.files.length; f++) {
            node.files[f] = node.files[f].trim();
        }
        node.p = (node.files.length === 1) ? node.files[0] : JSON.stringify(node.files);

        node.watcher = watch(node.files, { recursive: node.recursive });

        node.watcher.on('change', function (event, fpath) {
            const file = path.basename(fpath)
            let stat;
            try {
                stat = fs.statSync(fpath);
            } catch(e) { }
            let type = "none";
            const msg = {
                payload:fpath,
                topic:node.p,
                file:file,
                filename:fpath,
                event: event
            };
            if (stat) {
                if (stat.isFile()) { type = "file"; msg.size = stat.size; }
                else if (stat.isBlockDevice()) { type = "blockdevice"; }
                else if (stat.isCharacterDevice()) { type = "characterdevice"; }
                else if (stat.isSocket()) { type = "socket"; }
                else if (stat.isFIFO()) { type = "fifo"; }
                else if (stat.isDirectory()) { type = "directory"; }
                else { type = "n/a"; }
            }
            msg.type = type;
            node.send(msg);
        });

        node.watcher.on('error', function (error) {
            const msg = { payload: "" };
            node.error(error,msg);
        });
    };
    
    function WatchNode(n) {
        RED.nodes.createNode(this,n);
        var node = this;
        node.recursive = n.recursive || false;
        node.files = n.files || "";
        node.filesType = n.filesType || "str";
        node.inputs = n.inputs || 0;
        // added to enable context setup
        // n.filesType env, get env variable value, use as path/files list
        if (n.filesType == 'env') n.files = RED.util.evaluateNodeProperty(n.files, 'env', node);
        // n.filesType not msg configure watcher immediately
        if (n.filesType != 'msg') configureWatcher(node, n)
        // if n.filesType msg reconfigure watcher on receiving a message
        else {
            node.on('input', function(msg) {
                switch (n.filesType) {
                    case "msg":
                        node.files = msg[n.files];
                    break;
                    default:
                        node.files = n.files;
                }
                if (n.files != node.files) {   // new path/files list received or variable changed
                    if (node.watcher) node.watcher.close(); // if watcher active close it
                    configureWatcher(node, n);      // reconfigure watcher
                };
            });
        }
        
        node.close = function() {
            if (node.watcher) node.watcher.close();
        }
    }
    RED.nodes.registerType("watch", WatchNode);
}