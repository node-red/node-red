{
    "common": {
        "label": {
            "payload": "Charge utile",
            "topic": "Sujet",
            "name": "Nom",
            "username": "Nom d'utilisateur",
            "password": "Mot de passe",
            "property": "Propriété",
            "selectNodes": "Sélectionner les noeuds...",
            "expand": "Développer"
        },
        "status": {
            "connected": "Connecté",
            "not-connected": "Pas connecté",
            "disconnected": "Déconnecté",
            "connecting": "Connexion",
            "error": "Erreur",
            "ok": "OK"
        },
        "notification": {
            "error": "<strong>Erreur</strong> : __message__",
            "errors": {
                "not-deployed": "noeud non déployé",
                "no-response": "pas de réponse du serveur",
                "unexpected": "erreur inattendue (__status__) __message__"
            }
        },
        "errors": {
            "nooverride": "Avertissement : les propriétés du msg ne peuvent plus remplacer les propriétés du noeud définies. Voir bit.ly/nr-override-msg-props"
        }
    },
    "inject": {
        "inject": "Injecter",
        "injectNow": "Injecter maintenant",
        "repeat": "répéter = __repeat__",
        "crontab": "crontab = __crontab__",
        "stopped": "arrêté",
        "failed": "Échec de l'injection : __error__",
        "label": {
            "properties": "Propriétés",
            "repeat": "Répéter",
            "flow": "contexte de flux",
            "global": "contexte global",
            "str": "chaîne de caractères",
            "num": "nombre",
            "bool": "booléen",
            "json": "objet",
            "bin": "tampon",
            "date": "horodatage",
            "env": "variable d'environnement",
            "object": "objet",
            "string": "chaîne de caractères",
            "boolean": "booléen",
            "number": "nombre",
            "Array": "tableau",
            "invalid": "Objet JSON non valide"
        },
        "timestamp": "horodatage",
        "none": "non",
        "interval": "intervalle",
        "interval-time": "intervalle entre les heures",
        "time": "à une heure précise",
        "seconds": "secondes",
        "minutes": "minutes",
        "hours": "heures",
        "between": "entre",
        "previous": "valeur précédente",
        "at": "à",
        "and": "et",
        "every": "chaque",
        "days": [
            "Lundi",
            "Mardi",
            "Mercredi",
            "Jeudi",
            "Vendredi",
            "Samedi",
            "Dimanche"
        ],
        "on": "les",
        "onstart": "Injecter une fois après",
        "onceDelay": "secondes, puis",
        "success": "Injecté avec succès : __label__",
        "errors": {
            "failed": "l'injection a échoué, voir le journal pour plus de détails",
            "toolong": "Intervalle trop grande",
            "invalid-expr": "Expression JSONata invalide : __error__",
            "invalid-jsonata": "__prop__: expression de propriété invalide : __error__",
            "invalid-prop": "__prop__: expression de propriété invalide : __error__",
            "invalid-json": "__prop__: données JSON invalides : __error__",
            "invalid-repeat": "Valeur de répétition invalide"
        }
    },
    "catch": {
        "catch": "catch : tout",
        "catchNodes": "catch : __number__",
        "catchUncaught": "catch : non capturé",
        "label": {
            "source": "Détecter les erreurs de",
            "selectAll": "Tout sélectionner",
            "uncaught": "Ignorer les erreurs gérées par les autres noeuds Catch"
        },
        "scope": {
            "all": "tous les noeuds",
            "group": "dans le même groupe",
            "selected": "noeuds sélectionnés"
        }
    },
    "status": {
        "status": "statut : tout",
        "statusNodes": "statut : __number__",
        "label": {
            "source": "Signaler l'état de",
            "sortByType": "Trier par type"
        },
        "scope": {
            "all": "tous les noeuds",
            "group": "dans le même groupe",
            "selected": "noeuds sélectionnés"
        }
    },
    "complete": {
        "completeNodes": "achevé : __number__",
        "errors": {
            "scopeUndefined": "portée indéfinie"
        }
    },
    "debug": {
        "output": "Sortie",
        "status": "statut",
        "none": "aucun",
        "invalid-exp": "Expression JSONata non valide : __error__",
        "msgprop": "propriété du message",
        "msgobj": "objet complet du message",
        "autostatus": "identique à la sortie de débogage",
        "messageCount": "nombre de messages",
        "to": "Vers",
        "debtab": "onglet de débogage",
        "tabcon": "onglet et console de débogage",
        "toSidebar": "fenêtre de débogage",
        "toConsole": "console du système",
        "toStatus": "état du noeud (32 caractères)",
        "severity": "Niveau",
        "node": "noeud",
        "notification": {
            "activated": "Activé avec succès : __label__",
            "deactivated": "Désactivé avec succès : __label__"
        },
        "sidebar": {
            "label": "Débogage",
            "name": "Messages de débogage",
            "filterAll": "Tous les noeuds",
            "filterSelected": "Noeuds sélectionnés",
            "filterCurrent": "Flux actuel",
            "debugNodes": "noeuds de débogage",
            "clearLog": "Tous les messages",
            "clearFilteredLog": "Les messages filtrés",
            "filterLog": "Filtrer les messages",
            "openWindow": "Ouvrir dans une nouvelle fenêtre",
            "copyPath": "Copier le chemin",
            "copyPayload": "Copier la valeur",
            "pinPath": "Épingler le chemin",
            "selectAll": "Tout sélectionner",
            "selectNone": "Ne rien sélectionner",
            "all": "Tout",
            "filtered": "Filtrés"
        },
        "messageMenu": {
            "collapseAll": "Réduire tous les chemins",
            "clearPinned": "Supprimer les chemins épinglés",
            "filterNode": "Filtrer ce noeud",
            "clearFilter": "Effacer le filtre"
        }
    },
    "link": {
        "linkIn": "Lien entrant",
        "linkOut": "Lien sortant",
        "linkCall": "Appel de lien",
        "linkOutReturn": "Retour de lien",
        "outMode": "Mode",
        "sendToAll": "Envoyer à tous les noeuds de liaison connectés",
        "returnToCaller": "Retour au noeud de liaison appelant",
        "timeout": "Temps mort",
        "linkCallType": "Type de liaison",
        "staticLinkCall": "Lien fixe",
        "dynamicLinkCall": "Lien dynamique (msg.target)",
        "dynamicLinkLabel": "Dynamique",
        "errors": {
            "missingReturn": "Informations manquantes sur le noeud de retour",
            "linkUndefined": "Lien indéfini"
        }
    },
    "tls": {
        "tls": "Paramétrage TLS",
        "label": {
            "use-local-files": "Utiliser la clé et les certificats depuis des fichiers locaux",
            "upload": "Charger",
            "cert": "Certificat",
            "key": "Clé Privée",
            "passphrase": "Phrase de passe",
            "ca": "Certificat CA",
            "verify-server-cert": "Vérifier le certificat du serveur",
            "servername": "Nom du Serveur",
            "alpnprotocol": "Protocole ALPN"
        },
        "placeholder": {
            "cert": "chemin d'accès au certificat (format PEM)",
            "key": "chemin vers la clé privée (format PEM)",
            "ca": "chemin d'accès au certificat CA (format PEM)",
            "passphrase": "phrase de passe de la clé privée (facultatif)",
            "servername": "à utiliser avec SNI",
            "alpnprotocol": "à utiliser avec ALPN"
        },
        "error": {
            "missing-file": "Aucun certificat/fichier de clé fourni",
            "invalid-cert": "Certificat non spécifié",
            "invalid-key": "Clé privée non spécifiée"
        }
    },
    "exec": {
        "exec": "exec",
        "spawn": "spawn",
        "label": {
            "command": "Commande",
            "append": "Joindre",
            "timeout": "Temps mort",
            "timeoutplace": "Facultatif",
            "return": "Sortie",
            "seconds": "secondes",
            "stdout": "stdout",
            "stderr": "stderr",
            "retcode": "code retourné",
            "winHide": "Masquer la console"
        },
        "placeholder": {
            "extraparams": "Paramètres d'entrée supplémentaires"
        },
        "opt": {
            "exec": "lorsque la commande est terminée - mode exec",
            "spawn": "pendant que la commande est en cours d'exécution - mode spawn"
        },
        "oldrc": "Utiliser l'ancien style de sortie (mode de compatibilité)"
    },
    "function": {
        "function": "fonction",
        "label": {
            "setup": "Configurations",
            "function": "Message reçu",
            "initialize": "Au démarrage",
            "finalize": "À l'arrêt",
            "outputs": "Sorties",
            "modules": "Modules"
        },
        "text": {
            "initialize": "// Le code ajouté ici sera exécuté une fois\n// à chaque démarrage du noeud.\n",
            "finalize": "// Le code ajouté ici sera exécuté lorsque le\n// noeud sera arrêté ou redéployé.\n"
        },
        "require": {
            "var": "variable",
            "module": "module",
            "moduleName": "Nom du module",
            "importAs": "Importé comme"
        },
        "error": {
            "externalModuleNotAllowed": "Le noeud de fonction n'est pas autorisé à charger des modules externes",
            "moduleNotAllowed": "Module __module__ non autorisé",
            "externalModuleLoadError": "Le noeud de fonction n'a pas réussi à charger les modules externes",
            "moduleLoadError": "Échec du chargement du module __module__ : __error__",
            "moduleNameError": "Nom de la variable du module invalide : __name__",
            "moduleNameReserved": "Nom de la variable réservée : __name__",
            "inputListener": "Impossible d'ajouter un écouteur à l'événement 'input' dans la fonction",
            "non-message-returned": "La fonction a tenté d'envoyer un message de type __type__",
            "invalid-js": "Erreur dans le code JavaScript",
            "missing-module": "Module __module__ manquant"
        }
    },
    "template": {
        "template": "modèle",
        "label": {
            "template": "Modèle",
            "property": "Propriété",
            "format": "Syntaxe Highlight",
            "syntax": "Format",
            "output": "Sortie comme",
            "mustache": "Modèle Mustache",
            "plain": "Texte brut",
            "json": "JSON analysé",
            "yaml": "YAML analysé",
            "none": "aucun"
        },
        "templatevalue": "C'est la charge utile : {{charge-utile}} !"
    },
    "delay": {
        "action": "Action",
        "for": "Pour",
        "delaymsg": "Retarder chaque message",
        "delayfixed": "Délai fixe",
        "delayvarmsg": "Remplacer le délai par msg.delay",
        "randomdelay": "Délai aléatoire",
        "limitrate": "Limite de débit",
        "limitall": "Tous les messages",
        "limittopic": "Pour chaque msg.topic",
        "fairqueue": "Envoyer chaque sujet à tour de rôle",
        "timedqueue": "Envoyer tous les sujets",
        "milisecs": "Millisecondes",
        "secs": "Secondes",
        "sec": "Seconde",
        "mins": "Minutes",
        "min": "Minute",
        "hours": "Heures",
        "hour": "Heure",
        "days": "Jours",
        "day": "Jour",
        "between": "Entre",
        "and": "et",
        "rate": "Débit",
        "msgper": "msg(s) par",
        "queuemsg": "Mettre en file d'attente les messages intermédiaires",
        "dropmsg": "Supprimer les messages intermédiaires",
        "sendmsg": "Envoyer les messages intermédiaires sur la 2ème sortie",
        "allowrate": "Autoriser msg.rate (en ms) à remplacer le débit",
        "label": {
            "delay": "retard",
            "variable": "variable",
            "limit": "limite",
            "limitTopic": "limiter le sujet",
            "random": "aléatoire",
            "rate": "débit",
            "random-first": "première valeur aléatoire",
            "random-last": "dernière valeur aléatoire",
            "units": {
                "second": {
                    "plural": "Secondes",
                    "singular": "Seconde"
                },
                "minute": {
                    "plural": "Minutes",
                    "singular": "Minute"
                },
                "hour": {
                    "plural": "Heures",
                    "singular": "Heure"
                },
                "day": {
                    "plural": "Jours",
                    "singular": "Jour"
                }
            }
        },
        "errors": {
            "too-many": "Trop de messages en attente dans le noeud 'Delay'",
            "invalid-timeout": "Valeur de délai invalide",
            "invalid-rate": "Valeur de taux invalide",
            "invalid-rate-unit": "Valeur de débit invalide",
            "invalid-random-first": "Première valeur aléatoire invalide",
            "invalid-random-last": "Dernière valeur aléatoire invalide"
        }
    },
    "trigger": {
        "send": "Envoyer",
        "then": "Puis",
        "then-send": "Puis envoyer",
        "output": {
            "string": "la chaîne",
            "number": "le nombre",
            "existing": "l'objet msg existant",
            "original": "l'objet msg d'origine",
            "latest": "le dernier objet msg",
            "nothing": "rien"
        },
        "wait-reset": "attendre d'être réinitialisé",
        "wait-for": "attendre",
        "wait-loop": "le renvoyer chaque",
        "for": "Pour",
        "bytopics": "chaque",
        "alltopics": "tous les messages",
        "duration": {
            "ms": "Millisecondes",
            "s": "Secondes",
            "m": "Minutes",
            "h": "Heures"
        },
        "extend": " Prolonger le délai si un nouveau message arrive",
        "override": "Remplacer le délai avec msg.delay",
        "second": " Envoyer un deuxième message à une sortie séparée",
        "label": {
            "trigger": "déclencher",
            "trigger-block": "déclencher et bloquer",
            "trigger-loop": "renvoyer chaque",
            "reset": "Réinitialiser le déclencheur si :",
            "resetMessage": "msg.reset est défini",
            "resetPayload": "msg.payload est le même",
            "resetprompt": "facultatif",
            "duration": "durée",
            "topic": "sujet"
        }
    },
    "comment": {
        "comment": "commentaire"
    },
    "unknown": {
        "label": {
            "unknown": "inconnu"
        },
        "tip": "<p>Ce noeud est un type inconnu de votre installation Node-RED.</p><p><i>Si vous déployez avec le noeud dans cet état, sa configuration sera préservée, mais le flux ne démarrera pas avant que le type manquant soit installé.</i></p><p>Consulter la barre latérale d'informations pour plus d'aide</p>"
    },
    "mqtt": {
        "label": {
            "broker": "Serveur",
            "example": "expl. localhost",
            "output": "Sortie",
            "qos": "QoS",
            "retain": "Conserver",
            "clientid": "Client ID",
            "port": "Port",
            "keepalive": "Rester en vie",
            "cleansession": "Utiliser une session propre",
            "autoUnsubscribe": "Se désabonner automatiquement lors de la déconnexion",
            "cleanstart": "Utiliser un démarrage propre",
            "use-tls": "Utiliser TLS",
            "tls-config": "Configuration TLS",
            "verify-server-cert": "Vérifier le certificat du serveur",
            "compatmode": "Utiliser la prise en charge héritée du MQTT 3.1",
            "userProperties": "Propriétés utilisateur",
            "subscriptionIdentifier": "ID d'abonnement",
            "flags": "Drapeaux",
            "nl": "Ne pas recevoir les messages publiés par ce client",
            "rap": "Conserver l'indicateur de conservation de la publication d'origine",
            "rh": "Gestion des messages conservés",
            "rh0": "Envoyer les messages retenus",
            "rh1": "Envoyer uniquement pour les nouveaux abonnements",
            "rh2": "Ne pas envoyer",
            "responseTopic": "Sujet de la réponse",
            "contentType": "Type de contenu",
            "correlationData": "Données de corrélation",
            "expiry": "Expiration (secs)",
            "sessionExpiry": "Expiration de la session (secondes)",
            "topicAlias": "Alias",
            "payloadFormatIndicator": "Formater",
            "payloadFormatIndicatorFalse": "Octets non spécifiés (par défaut)",
            "payloadFormatIndicatorTrue": "Charge utile encodée en UTF-8",
            "protocolVersion": "Protocole",
            "protocolVersion3": "MQTT V3.1 (hérité)",
            "protocolVersion4": "MQTT V3.1.1",
            "protocolVersion5": "MQTT V5",
            "topicAliasMaximum": "Alias Max",
            "maximumPacketSize": "Taille maximale des paquets",
            "receiveMaximum": "Recevoir Max",
            "session": "Session",
            "delay": "Retard",
            "action": "Action",
            "staticTopic": "S'abonner à un seul sujet",
            "dynamicTopic": "Abonnement dynamique",
            "auto-connect": "Se connecter automatiquement",
            "auto-mode-depreciated": "Cette option est dépréciée. Veuiller utiliser le nouveau mode de détection automatique.",
            "none": "aucun",
            "other": "autre"
        },
        "sections-label": {
            "birth-message": "Message envoyé à la connexion (message au démarrage)",
            "will-message": "Message envoyé lors d'une déconnexion inattendue (perte de connexion)",
            "close-message": "Message envoyé avant la déconnexion (message à la fermeture)"
        },
        "tabs-label": {
            "connection": "Connexion",
            "security": "Sécurité",
            "messages": "Messages"
        },
        "placeholder": {
            "clientid": "Laisser vide pour s'auto générer",
            "clientid-nonclean": "Doit être défini pour les sessions non propres",
            "will-topic": "Laisser vide pour désactiver le message perte de connexion",
            "birth-topic": "Laisser vide pour désactiver le message au démarrage",
            "close-topic": "Laisser vide pour désactiver le message de fermeture"
        },
        "state": {
            "connected": "Connecté au courtier : __broker__",
            "disconnected": "Déconnecté du courtier : __broker__",
            "connect-failed": "Échec de la connexion au courtier : __broker__",
            "broker-disconnected": "Client déconnecté du courtier __broker__ : __reasonCode__ __reasonString__"
        },
        "retain": "Conserver",
        "output": {
            "buffer": "un Tampon",
            "string": "une Chaîne",
            "base64": "une chaîne encodée en Base64",
            "auto": "détection automatique (chaîne ou tampon)",
            "auto-detect": "détection automatique (objet JSON analysé, chaîne ou tampon)",
            "json": "un objet JSON analysé"
        },
        "true": "vraie",
        "false": "faux",
        "tip": "Conseil : laisser le sujet, le qos ou le contenu vide si vous souhaitez les définir via les propriétés du msg.",
        "errors": {
            "not-defined": "Sujet non défini",
            "missing-config": "Configuration du courtier manquante",
            "invalid-topic": "Sujet invalide spécifié",
            "nonclean-missingclientid": "Aucun ID client défini, utilisation d'une session propre",
            "invalid-json-string": "Chaîne JSON invalide",
            "invalid-json-parse": "Échec de l'analyse de la chaîne JSON",
            "invalid-action-action": "Action invalide spécifiée",
            "invalid-action-alreadyconnected": "Déconnectez-vous du courtier avant de vous connecter",
            "invalid-action-badsubscription": "msg.topic est manquant ou invalide",
            "invalid-client-id": "Identifiant client manquant"
        }
    },
    "httpin": {
        "label": {
            "method": "Méthode",
            "url": "URL",
            "doc": "Docs",
            "return": "Retourne",
            "upload": "Accepter les téléchargements de fichiers ?",
            "status": "Code d'état",
            "headers": "En-têtes",
            "other": "Autre",
            "paytoqs": {
                "ignore": "Ignorer",
                "query": "Joindre aux paramètres de chaîne de requête",
                "body": "Envoyer en tant que corps de requête"
            },
            "utf8String": "chaîne UTF8",
            "binaryBuffer": "tampon binaire",
            "jsonObject": "objet JSON analysé",
            "authType": "Type",
            "bearerToken": "Jeton"
        },
        "setby": "- définir par msg.method -",
        "basicauth": "Utiliser l'authentification",
        "use-tls": "Activer la connexion sécurisée (SSL/TLS)",
        "tls-config": "Configuration TLS",
        "basic": "authentification de base",
        "digest": "authentification par résumé",
        "bearer": "authentification du porteur",
        "use-proxy": "Utiliser un proxy",
        "persist": "Activer le maintien de la connexion",
        "proxy-config": "Configuration du proxy",
        "use-proxyauth": "Utiliser l'authentification proxy",
        "noproxy-hosts": "Ignorer les hôtes",
        "senderr": "N'envoyer que des réponses non-2xx au noeud Catch",
        "utf8": "une chaîne UTF-8",
        "binary": "un tampon binaire",
        "json": "un objet JSON analysé",
        "tip": {
            "in": "L'url sera relative à ",
            "res": "Les messages envoyés à ce noeud <b>doivent</b> provenir d'un noeud <i>http in</i>",
            "req": "Astuce : si l'analyse JSON échoue, la chaîne récupérée est renvoyée telle quelle."
        },
        "httpreq": "requête http",
        "errors": {
            "not-created": "Impossible de créer un noeud http-in lorsque httpNodeRoot est défini sur faux",
            "missing-path": "chemin manquant",
            "no-response": "Aucun objet de réponse",
            "json-error": "Erreur d'analyse JSON",
            "no-url": "Aucune URL spécifiée",
            "deprecated-call": "Appel obsolète à __method__",
            "invalid-transport": "transport non-http demandé",
            "timeout-isnan": "La valeur du délai d'attente n'est pas un nombre valide, ignorée",
            "timeout-isnegative": "La valeur du délai d'attente est négative, ignorée",
            "invalid-payload": "Charge utile invalide",
            "invalid-url": "URL invalide"
        },
        "status": {
            "requesting": "en cours de demande"
        },
        "insecureHTTPParser": "Désactiver l'analyse HTTP stricte"
    },
    "websocket": {
        "label": {
            "type": "Type",
            "path": "Chemin",
            "url": "URL",
            "subprotocol": "Subprotocol"
        },
        "listenon": "Écoute sur",
        "connectto": "Se connecte à",
        "sendrec": "Envoyer/Recevoir",
        "payload": "msg.payload",
        "message": "message entier",
        "sendheartbeat": "Envoyer un ping",
        "tip": {
            "path1": "Par défaut, <code>payload</code> contiendra les données à envoyer ou à recevoir d'un websocket. L'écouteur peut être configuré pour envoyer ou recevoir l'intégralité de l'objet message sous forme de chaîne au format JSON.",
            "path2": "Ce chemin sera relatif à <code>__path__</code>.",
            "url1": "L'URL doit utiliser le schéma ws:&#47;&#47; ou wss:&#47;&#47; et pointer vers un écouteur websocket existant.",
            "url2": "Par défaut, <code>payload</code> contiendra les données à envoyer ou à recevoir d'un websocket. Le client peut être configuré pour envoyer ou recevoir l'intégralité de l'objet message sous forme de chaîne au format JSON."
        },
        "status": {
            "connected": "__count__ connecté",
            "connected_plural": "__count__ connectés"
        },
        "errors": {
            "connect-error": "Une erreur s'est produite lors de la connexion au ws : ",
            "send-error": "Une erreur s'est produite lors de l'envoi : ",
            "missing-conf": "Configuration du serveur manquante",
            "duplicate-path": "Impossible d'avoir deux écouteurs WebSocket sur le même chemin : __path__",
            "missing-server": "Configuration du serveur manquante",
            "missing-client": "Configuration client manquante"
        }
    },
    "watch": {
        "watch": "surveiller",
        "label": {
            "files": "Fichier(s)",
            "recursive": "Surveiller les sous-répertoires de manière récursive"
        },
        "placeholder": {
            "files": "Liste de fichiers et/ou répertoires séparés par des virgules"
        },
        "tip": "Sous Windows, vous devez utiliser des doubles barres obliques inverses \\\\ dans tous les noms de répertoire."
    },
    "tcpin": {
        "label": {
            "type": "Type",
            "output": "Sortie",
            "port": "port",
            "host": "chez l'hôte",
            "payload": "payload(s)",
            "delimited": "délimité par",
            "close-connection": "Fermer la connexion après l'envoi de chaque message ?",
            "decode-base64": "Décoder le message Base64 ?",
            "server": "Serveur",
            "return": "Retourne",
            "ms": "ms",
            "chars": "caractères",
            "close": "Fermer",
            "optional": "(facultatif)",
            "reattach": "Rattacher le délimiteur"
        },
        "type": {
            "listen": "Écoute sur",
            "connect": "Se connecte au",
            "reply": "Répondre sur TCP"
        },
        "output": {
            "stream": "Flux de",
            "single": "Unique",
            "buffer": "Tampon",
            "string": "Chaîne",
            "base64": "Chaîne en Base64"
        },
        "return": {
            "timeout": "après un délai fixe de",
            "character": "lorsque le caractère reçu est",
            "number": "après un nombre fixe de caractères",
            "never": "jamais - garder la connexion ouverte",
            "immed": "immédiatement - ne pas attendre de réponse"
        },
        "status": {
            "connecting": "connection à __host__:__port__",
            "connected": "connecté à __host__:__port__",
            "listening-port": "écoute sur le port __port__",
            "stopped-listening": "a cessé d'écouter sur le port",
            "connection-from": "connexion depuis __host__:__port__",
            "connection-closed": "connexion fermée depuis __host__:__port__",
            "connections": "__count__ connexion",
            "connections_plural": "__count__ connexions"
        },
        "errors": {
            "connection-lost": "Connexion perdue avec __host__:__port__",
            "timeout": "Délai d'expiration du port __port__ du socket fermé",
            "cannot-listen": "Impossible d'écouter sur le port __port__, erreur : __error__",
            "error": "Erreur : __error__",
            "socket-error": "Erreur de courtier depuis __host__:__port__",
            "no-host": "Hôte et/ou port non défini",
            "connect-timeout": "Délai de connexion",
            "connect-fail": "La connexion a échoué",
            "bad-string": "Échec de la conversion en chaîne",
            "invalid-host": "Hôte invalide",
            "invalid-port": "Port invalide"
        }
    },
    "udp": {
        "label": {
            "listen": "Écouter",
            "onport": "sur le port",
            "using": "utilisant",
            "output": "Sortie",
            "group": "Groupe",
            "interface": "IP Locale",
            "send": "Envoyer un",
            "toport": "au port",
            "address": "Adresse",
            "decode-base64": "Décoder la charge utile encodée en Base64 ?",
            "port": "port"
        },
        "placeholder": {
            "interface": "(facultatif) interface locale ou adresse à laquelle se lier",
            "interfaceprompt": "(facultatif) interface locale ou adresse à laquelle se lier",
            "address": "IP de destination"
        },
        "udpmsgs": "messages UDP",
        "mcmsgs": "messages multidiffusion",
        "udpmsg": "message UDP",
        "bcmsg": "message diffusé",
        "mcmsg": "message multidiffusion",
        "output": {
            "buffer": "un Tampon",
            "string": "une Chaîne",
            "base64": "une chaîne encodée en Base64"
        },
        "bind": {
            "random": "se lier à un port local aléatoire",
            "local": "se lier au port local",
            "target": "se lier au port cible"
        },
        "tip": {
            "in": "Conseil : Assurez-vous que votre pare-feu autorise l'entrée des données.",
            "out": "Conseil : laisser l'adresse et le port vides si vous souhaitez définir à l'aide de <code>msg.ip</code> et <code>msg.port</code>.",
            "port": "Ports déjà utilisés : "
        },
        "status": {
            "listener-at": "écouteur udp sur __host__:__port__",
            "mc-group": "groupe de multidiffusion udp __group__",
            "listener-stopped": "écouteur udp arrêté",
            "output-stopped": "sortie udp arrêtée",
            "mc-ready": "udp multicast prêt : __iface__:__outport__ -> __host__:__port__",
            "bc-ready": "udp broadcast prêt : __outport__ -> __host__:__port__",
            "ready": "udp prêt : __outport__ -> __host__:__port__",
            "ready-nolocal": "udp prêt : __host__:__port__",
            "re-use": "socket de réutilisation udp : __outport__ -> __host__:__port__"
        },
        "errors": {
            "access-error": "Erreur d'accès UDP, vous aurez peut-être besoin d'un accès root pour les ports inférieurs à 1024",
            "error": "Erreur : __erreur__",
            "bad-mcaddress": "Mauvaise adresse de multidiffusion",
            "interface": "Doit être l'adresse IP de l'interface requise",
            "ip-notset": "udp : adresse IP non définie",
            "port-notset": "udp : port non défini",
            "port-invalid": "udp : numéro de port non valide",
            "alreadyused": "udp : port __port__ déjà utilisé",
            "ifnotfound": "udp : interface __iface__ introuvable",
            "invalid-group": "Groupe de multidiffusion invalide"
        }
    },
    "switch": {
        "switch": "commuter",
        "label": {
            "property": "Propriété",
            "rule": "règle",
            "repair": "Recréer des séquences du messages",
            "value-rules": "Règles de valeur",
            "sequence-rules": "Règles de séquence"
        },
        "previous": "valeur précédente",
        "and": "et",
        "checkall": "Vérifier toutes les règles",
        "stopfirst": "Arrêter après la première concordance",
        "ignorecase": "Ignorer la casse",
        "rules": {
            "btwn": "est entre",
            "cont": "contient",
            "regex": "correspond au regex",
            "true": "est vrai",
            "false": "est faux",
            "null": "est nul",
            "nnull": "n'est pas nul",
            "istype": "est de type",
            "empty": "est vide",
            "nempty": "n'est pas vide",
            "head": "tête",
            "tail": "queue",
            "index": "index entre",
            "exp": "Exp JSONata",
            "else": "autrement",
            "hask": "a une clé"
        },
        "errors": {
            "invalid-expr": "Expression JSONata non valide : __error__",
            "too-many": "Trop de messages en attente dans le noeud de commutation"
        }
    },
    "change": {
        "label": {
            "rules": "Règles",
            "rule": "règle",
            "set": "définir __property__",
            "change": "remplacer __property__",
            "delete": "supprimer __property__",
            "move": "déplacer __property__",
            "changeCount": "remplacer : __count__ règles",
            "regex": "Utiliser des expressions régulières",
            "deepCopy": "Copie profonde de la valeur"
        },
        "action": {
            "set": "Définir",
            "change": "Remplacer",
            "delete": "Supprimer",
            "move": "Déplacer",
            "toValue": "sur la valeur",
            "to": "vers",
            "search": "Rechercher",
            "replace": "Remplacer par"
        },
        "errors": {
            "invalid-from": "Propriété 'depuis' invalide : __error__",
            "invalid-json": "Propriété JSON 'vers' invalide",
            "invalid-expr": "Expression JSONata invalide : __error__",
            "no-override": "Impossible de définir la propriété de type non objet : __property__",
            "invalid-prop": "Expression de propriété invalide : __property__",
            "invalid-json-data": "Données JSON invalides : __error__"
        }
    },
    "range": {
        "range": "intervalle",
        "label": {
            "action": "Action",
            "inputrange": "Mapper la plage d'entrée",
            "resultrange": "à la plage cible",
            "from": "depuis",
            "to": "vers",
            "roundresult": "Arrondir le résultat à l'entier le plus proche ?",
            "minin": "entrée minimale",
            "maxin": "entrée maximale",
            "minout": "sortie minimale",
            "maxout": "sortie maximale"
        },
        "placeholder": {
            "min": "expl. 0",
            "maxin": "expl. 99",
            "maxout": "expl. 255"
        },
        "scale": {
            "payload": "Mettre à l'échelle la propriété du message",
            "limit": "Mettre à l'échelle et limiter à la plage cible",
            "wrap": "Mettre à l'échelle et envelopper dans la plage cible",
            "drop": "Mettre à l'échelle, mais supprimer le message s'il est en dehors de la plage d'entrée"
        },
        "tip": "Remarque : Ce noeud fonctionne UNIQUEMENT avec des nombres.",
        "errors": {
            "notnumber": "Pas un nombre"
        }
    },
    "csv": {
        "label": {
            "columns": "Colonnes",
            "separator": "Séparateur",
            "c2o": "Options CSV vers objet",
            "o2c": "Options Objet vers CSV",
            "entrée": "Entrée",
            "skip-s": "Passer en premier",
            "skip-e": "lignes",
            "firstrow": "La première ligne contient les noms des colonnes",
            "output": "Sortie",
            "includerow": "Inclure la ligne du nom de la colonne",
            "newline": "Nouvelle ligne",
            "usestrings": "Analyser les valeurs numériques",
            "include_empty_strings": "Inclure les chaînes vides",
            "include_null_values": "Inclure les valeurs nulles"
        },
        "placeholder": {
            "columns": "noms de colonnes séparés par des virgules"
        },
        "separator": {
            "comma": "virgule",
            "tab": "tabulation",
            "space": "espace",
            "semicolon": "point-virgule",
            "colon": "colonne",
            "hashtag": "hashtag",
            "other": "autre..."
        },
        "output": {
            "row": "un message par ligne",
            "array": "un seul message [tableau]"
        },
        "newline": {
            "linux": "Linux (\\n)",
            "mac": "Mac (\\r)",
            "windows": "Windows (\\r\\n)"
        },
        "hdrout": {
            "none": "ne jamais envoyer d'en-têtes de colonne",
            "all": "toujours envoyer les en-têtes de colonne",
            "once": "envoyer les en-têtes une fois, jusqu'à msg.reset"
        },
        "errors": {
            "csv_js": "Ce noeud ne gère que les chaînes CSV ou les objets js.",
            "obj_csv": "Aucun modèle de colonnes spécifié pour l'objet -> CSV.",
            "bad_csv": "Données CSV mal formées - sortie probablement corrompue."
        }
    },
    "html": {
        "label": {
            "select": "Sélecteur",
            "output": "Sortie",
            "in": "dans"
        },
        "output": {
            "html": "le contenu html des éléments",
            "text": "uniquement le contenu textuel des éléments",
            "attr": "un objet de n'importe quel attribut des éléments"
        },
        "format": {
            "single": "comme un seul message contenant un tableau",
            "multi": "sous forme de messages multiples, un pour chaque élément"
        }
    },
    "json": {
        "errors": {
            "dropped-object": "Charge utile de type non objet ignorée",
            "dropped": "Type de charge utile non pris en charge ignorée",
            "dropped-error": "Échec de la conversion de la charge utile",
            "schema-error": "Erreur de schéma JSON",
            "schema-error-compile": "Erreur de schéma JSON : échec de la compilation du schéma"
        },
        "label": {
            "o2j": "Objet vers JSON",
            "pretty": "Formater la chaîne JSON",
            "action": "Action",
            "property": "Propriété",
            "actions": {
                "toggle": "Convertir entre chaîne JSON et objet",
                "str": "Toujours convertir en chaîne JSON",
                "obj": "Toujours convertir en objet JavaScript"
            }
        }
    },
    "yaml": {
        "errors": {
            "dropped-object": "Charge utile de type non objet ignorée",
            "dropped": "Type de charge utile non pris en charge ignoré",
            "dropped-error": "Échec de la conversion de la charge utile"
        }
    },
    "xml": {
        "label": {
            "represent": "Nom de la propriété pour les attributs de balise XML",
            "prefix": "Nom de la propriété pour le contenu du texte de la balise",
            "advanced": "Options avancées",
            "x2o": "Options XML vers objet"
        },
        "errors": {
            "xml_js": "Ce noeud ne gère que les chaînes XML ou les objets js."
        }
    },
    "file": {
        "label": {
            "write": "Écrire le fichier",
            "read": "Lire le fichier",
            "filename": "Nom du fichier",
            "path": "chemin",
            "action": "Action",
            "addnewline": "Ajouter une nouvelle ligne (\\n) à chaque charge ?",
            "createdir": "Créer un répertoire s'il n'existe pas ?",
            "outputas": "Sortie",
            "breakchunks": "Découper en morceaux",
            "breaklines": "Découper en lignes",
            "sendError": "Envoyer un message en cas d'erreur (mode hérité)",
            "encoding": "Encodage",
            "deletelabel": "supprimer __file__",
            "utf8String": "Chaîne UTF8",
            "utf8String_plural": "Chaînes UTF8",
            "binaryBuffer": "tampon binaire",
            "binaryBuffer_plural": "tampons binaires",
            "allProps": "inclure toutes les propriétés existantes dans chaque message"
        },
        "action": {
            "append": "ajouter au fichier",
            "overwrite": "écraser le fichier",
            "delete": "supprimer le fichier"
        },
        "output": {
            "utf8": "une seule chaîne UTF8",
            "buffer": "un seul objet Tampon",
            "lines": "un msg par ligne",
            "stream": "un flux de Tampons"
        },
        "status": {
            "wrotefile": "écrit dans le fichier : __file__",
            "deletedfile": "fichier supprimé : __file__",
            "appendedfile": "ajouté au fichier : __file__"
        },
        "encoding": {
            "none": "Par défaut",
            "setbymsg": "Défini par msg.encoding",
            "native": "Natif",
            "unicode": "Unicode",
            "japanese": "Japonais",
            "chinese": "Chinois",
            "korean": "Coréen",
            "taiwan": "Taïwan/Hong Kong",
            "windows": "Pages de codes Windows",
            "iso": "Pages de code ISO",
            "ibm": "Pages de codes IBM",
            "mac": "Pages de codes Mac",
            "koi8": "Pages de codes KOI8",
            "misc": "Divers"
        },
        "errors": {
            "nofilename": "Aucun nom de fichier spécifié",
            "invaliddelete": "Attention : suppression non valide. Veuiller utiliser une option de suppression spécifique dans la boîte de dialogue de configuration.",
            "deletefail": "Échec de la suppression du fichier : __error__",
            "writefail": "Échec de l'écriture dans le fichier : __error__",
            "appendfail": "Échec de l'ajout au fichier : __error__",
            "createfail": "Échec de la création du fichier : __error__"
        },
        "tip": "Astuce : Le nom du fichier doit être un chemin absolu, sinon il sera relatif au répertoire de travail du processus Node-RED."
    },
    "split": {
        "split": "diviser",
        "intro": "Diviser <code>msg.payload</code> en fonction du type :",
        "object": "<b>Objet</b>",
        "objectSend": "Envoie un message pour chaque paire clé/valeur",
        "strBuff": "<b>Chaîne</b> / <b>Tampon</b>",
        "array": "<b>Tableau</b>",
        "splitUsing": "Diviser en utilisant",
        "splitLength": "Longueur fixe de",
        "stream": "Gérer comme un flux de messages",
        "addname": " Copier la clé vers "
    },
    "join": {
        "join": "joindre",
        "mode": {
            "mode": "Mode",
            "auto": "automatique",
            "merge": "fusionner des séquences",
            "reduce": "réduire la séquence",
            "custom": "manuel"
        },
        "combine": "Combiner chaque",
        "completeMessage": "message complet",
        "create": "Créer",
        "type": {
            "string": "une Chaîne",
            "array": "un Tableau",
            "buffer": "un Tampon",
            "object": "un Objet clé/valeur",
            "merged": "un Objet fusionné"
        },
        "using": "En utilisant la valeur du",
        "key": "comme clé",
        "joinedUsing": "joint en utilisant",
        "send": "Envoyer le message :",
        "afterCount": "Après un nombre de parties du message",
        "count": "nombre",
        "subsequent": "Et tous les messages suivants.",
        "afterTimeout": "Après un délai d'attente après le premier message",
        "seconds": "secondes",
        "complete": "Après un message avec la propriété <code>msg.complete</code> définie",
        "tip": "Ce mode suppose que ce noeud est soit associé à un noeud <i>split</i> ou que les messages reçus auront une propriété <code>msg.parts</code> correctement configurée.",
        "too-many": "trop de messages en attente dans le noeud join",
        "message-prop": "propriété du message",
        "merge": {
            "topics-label": "Sujets fusionnés",
            "topics": "sujets",
            "topic": "sujet",
            "on-change": "Envoyer un message fusionné à l'arrivée d'un nouveau sujet"
        },
        "reduce": {
            "exp": "Réduire l'expression",
            "exp-value": "expression",
            "init": "Valeur initiale",
            "right": "Évaluer dans l'ordre inverse (du dernier au premier)",
            "fixup": "Fixer l'expression"
        },
        "errors": {
            "invalid-expr": "Expression JSONata non valide: __error__",
            "invalid-type": "Impossible de joindre __error__ au tampon"
        }
    },
    "sort": {
        "sort": "trier",
        "target": "Trier",
        "seq": "séquence de messages",
        "key": "Clé",
        "elem": "valeur de l'élément",
        "order": "Sens",
        "ascending": "croissant",
        "descending": "descendant",
        "as-number": "Comme nombre",
        "invalid-exp": "Expression JSONata invalide dans le noeud sort: __message__",
        "too-many": "Trop de messages en attente dans le noeud sort",
        "clear": "Effacer le message en attente dans le noeud sort"
    },
    "batch": {
        "batch": "Regrouper",
        "mode": {
            "label": "Mode",
            "num-msgs": "Regrouper par nombre de messages",
            "interval": "Regrouper par intervalle de temps",
            "concat": "Concaténer des séquences"
        },
        "count": {
            "label": "Nombre de messages",
            "overlap": "Chevauchement",
            "count": "nombre",
            "invalid": "Comptage et chevauchement invalides"
        },
        "interval": {
            "label": "Intervalle",
            "seconds": "secondes",
            "empty": "Envoyer un message vide lorsqu'aucun message n'arrive"
        },
        "concat": {
            "topics-label": "Sujets",
            "topic": "sujet"
        },
        "too-many": "Trop de messages en attente dans le noeud batch",
        "unexpected": "Mode inattendu",
        "no-parts": "Aucune propriété de pièces dans le message",
        "error": {
            "invalid-count": "Compte invalide",
            "invalid-overlap": "Recouvrement invalide",
            "invalid-interval": "Intervalle invalide"
        }
    },
    "rbe": {
        "rbe": "filtrer",
        "label": {
            "func": "Mode",
            "init": "Envoyer la valeur initiale",
            "start": "Valeur de départ",
            "name": "Nom",
            "septopics": "Appliquer le mode séparément pour chaque ",
            "gap": "changement de valeur",
            "property": "propriété",
            "topic": "sujet"
        },
        "placeholder": {
            "bandgap": "expl. 10 ou 5%",
            "start": "laisser vide pour utiliser les premières données reçues"
        },
        "opts": {
            "rbe": "bloquer sauf si la valeur change",
            "rbei": "bloquer sauf si la valeur change (ignorer la valeur initiale)",
            "deadband": "bloquer sauf si le changement de valeur est supérieur à",
            "deadbandEq": "bloquer sauf si le changement de valeur est supérieur ou égal à",
            "narrowband": "bloquer si le changement de valeur est supérieur à",
            "narrowbandEq": "bloquer si le changement de valeur est supérieur ou égal à",
            "in": "par rapport à la dernière valeur d'entrée",
            "out": "par rapport à la dernière valeur de sortie valide"
        },
        "warn": {
            "nonumber": "Aucun numéro trouvé dans la charge utile"
        }
    },
    "global-config": {
        "label": {
            "open-conf": "Ouvrir la configuration"
        }
    }
}
