{
    "common": {
        "label": {
            "payload": "Carga útil",
             "topic": "Tópico",
             "name": "Nome",
             "username": "Nome de usuário",
             "password": "Senha",
             "property": "Propriedade",
             "selectNodes": "Selecionar nós ...",
             "expand": "Expandir"
        },
        "status": {
            "connected": "conectado",
             "not-connected": "não conectado",
             "disconnected": "desconectado",
             "connecting": "conectando",
             "error": "erro",
             "ok": "OK"
        },
        "notification": {
            "error": "<strong> Erro </strong>: __message__",
             "errors": {
                 "not-deployed": "nó não implementado",
                 "no-response": "sem resposta do servidor",
                 "unexpected": "erro inesperado (__status__) __message__"
             }
        },
        "errors": {
            "nooverride": "Aviso: as propriedades do msg não podem mais substituir as propriedades do nó definido. Consulte bit.ly/nr-override-msg-props"
        }
    },
    "inject": {
        "inject": "injetar",
         "injectNow": "injetar agora",
         "repeat": "repita = __repeat__",
         "crontab": "crontab = __crontab__",
         "stopped": "parado",
         "failed": "Injeção falhou: __error__",
         "label": {
            "properties": "Propriedades",
             "repeat": "Repetir",
             "flow": "contexto de fluxo",
             "global": "contexto global",
             "str": "Cadeia de caracteres",
             "num": "número",
             "bool": "booliano",  
             "json": "objeto",
             "bin": "Armazenamento temporário",
             "date": "Carimbo de data/hora",
             "env": "variável env",
             "object": "objeto",
             "string": "Cadeia de caracteres",
             "boolean": "booliano",
             "number": "número",
             "Array": "matriz",
             "invalid": "Objeto JSON inválido"
        },
        "timestamp": "Carimbo de data/hora",
         "none": "nenhum",
         "interval": "intervalo",
         "interval-time": "intervalo entre tempos",
         "time": "em uma hora específica",
         "seconds": "segundos",
         "minutes": "minutos",
         "hours": "horas",
         "between": "entre",
         "previous": "valor anterior",
         "at": "a",
         "and": "e",
         "every": "todo",
        "days": [
            "Segunda-feira",
            "Terça-feira",
            "Quarta-feira",
            "Quinta-feira",
            "Sexta-feira",
            "Sábado",
            "Domingo"
        ],
         "on": "em",
         "onstart": "Injetar uma única vez depois",
         "onceDelay": "segundos, depois",
         "success": "Injetado com sucesso: __label__",
         "errors": {
             "failed": "injeção falhou, consulte o log para obter detalhes",
             "toolong": "Intervalo muito grande",
             "invalid-expr": "Expressão JSONata inválida: __error__",
             "invalid-jsonata": "__prop__: expressão de propriedade inválida: __error__",
             "invalid-prop": "__prop__: expressão de propriedade inválida: __error__",
             "invalid-json": "__prop__: Dados JSON inválidos: __error__",
             "invalid-repeat": "Valor de repetição inválido"
         }
    },
    "catch": {
        "catch": "capturar: todos",
        "catchNodes": "capturar: __number__",
        "catchUncaught": "capturar: não capturado",
        "label": {
            "source": "Capturar erros de",
            "selectAll": "selecionar tudo",
            "uncaught": "Ignorar erros manipulados por outros nós de captura"
        },
        "scope": {
            "all": "todos os nós",
            "selected": "nós selecionados"
        }
    },
    "status": {
        "status": "estado: todos",
        "statusNodes": "estado: __number__",
        "label": {
            "source": "Estado do relatório de",
            "sortByType": "ordenar por tipo"
        },
        "scope": {
            "all": "todos os nós",
            "selected": "nós selecionados"
        }
    },
    "complete": {
        "completeNodes": "completo: __number__"
    },
    "debug": {
        "output": "Saída",
        "status": "estados",
        "none": "Nenhum",
        "invalid-exp": "Expressão JSONata inválida: __error__",
        "msgprop": "propriedades da mensagem",
        "msgobj": "objeto msg completo",
        "autostatus": "igual à saída de depuração",
        "messageCount": "contador de mensagem",
        "to": "Para",
        "debtab": "aba de depuração",
        "tabcon": "guia de depuração e console",
        "toSidebar": "janela de depuração",
        "toConsole": "console do sistema",
        "toStatus": "estado do nó (32 caracteres)",
        "severity": "Nível",
        "node": "nó",
        "notification": {
            "activated": "Ativado com sucesso: __label__",
            "deactivated": "Desativado com sucesso: __label__"
        },
        "sidebar": {
            "label": "depurar",
            "name": "mensagens de depuração",
             "filterAll": "todos os nós",
             "filterSelected": "nós selecionados",
             "filterCurrent": "fluxo atual",
             "debugNodes": "Nós de depuração",
             "clearLog": "Remover mensagens",
             "clearFilteredLog": "Remover mensagens filtradas",
             "filterLog": "filtrar mensagens",
             "openWindow": "Abrir em uma nova janela",
             "copyPath": "Copiar caminho",
             "copyPayload": "Copiar valor",
             "pinPath": "Pin aberto",
             "selectAll": "selecionar todos",
             "selectNone": "selecionar nenhum",
             "all": "todos",
             "filtered": "filtrado"
        },
        "messageMenu": {
            "collapseAll": "Recolher todos os caminhos",
            "clearPinned": "Limpar caminhos fixados",
            "filterNode": "Filtrar este nó",
            "clearFilter": "Limpar filtro"
        }
    },
    "link": {
        "linkIn": "entrada de ligação",
        "linkOut": "saída de ligação",
        "linkCall": "chamada de ligação",
        "linkOutReturn": "retorno de ligação",
        "outMode": "Modo",
        "sendToAll": "Enviar para todos os nós de ligação conectados",
        "returnToCaller": "Retornar ao nó de ligação que chamou",
        "timeout": "tempo limite",
        "linkCallType": "Tipo de Ligação",
        "staticLinkCall": "Destino fixo",
        "dynamicLinkCall": "Destino dinâmico(msg.target)",
        "dynamicLinkLabel": "Dinâmico",
        "error": {
            "missingReturn": "Informação de retorno do nó ausente"
            }
    },
    "tls": {
        "tls": "Configuração TLS",
        "label": {
            "use-local-files": "Use a chave e os certificados dos arquivos locais",
             "upload": "Subir",
             "cert": "Certificado",
             "key": "Chave privada",
             "passphrase": "Frase de passe",
             "ca": "Certificado CA",
             "verify-server-cert": "Verifique o certificado do servidor",
             "servername": "Nome do servidor",
             "alpnprotocol": "Protocolo ALPN"
        },
        "placeholder": {
            "cert": "caminho para o certificado (formato PEM)",
            "key": "caminho para a chave privada (formato PEM)",
            "ca": "caminho para o certificado CA (formato PEM)",
            "passphrase": "frase de passe de chave privada (opcional)",
            "servername": "para uso com SNI",
            "alpnprotocol": "para uso com ALPN"
        },
        "error": {
            "missing-file": "Nenhum certificado/arquivo de chave fornecido",
            "invalid-cert": "Certificado não especificado",
            "invalid-key": "Chave privada não especificada"
        }
    },
    "exec": {
        "exec": "executa",
        "spawn": "gera",
        "label": {
            "command": "Comando",
            "append": "Acrescentar",
            "timeout": "Tempo esgotado",
            "timeoutplace": "opcional",
            "return": "Saída",
            "seconds": "segundos",
            "stdout": "stdout",
            "stderr": "stderr",
            "retcode": "código de retorno",
            "winHide": "Ocultar console"
        },
        "placeholder": {
            "extraparams": "parâmetros de entrada extras"
        },
        "opt": {
            "exec": "quando o comando estiver completo - modo execução",
            "spawn": "enquanto o comando está em execução - modo geração"
        },
        "oldrc": "Usar saída de estilo antigo(modo de compatibilidade)"
    },
    "function": {
        "function": "",
        "label": {
            "setup": "Configurar",
            "function": "Na mensagem",
            "initialize": "No início",
            "finalize": "Na parada",
            "outputs": "Saídas",
            "modules": "Módulos"
        },
        "text": {
            "initialize": "//O código adicionado aqui será executado uma vez\n// sempre que o nó for iniciado.\n",
             "finalize": "//O código adicionado aqui será executado quando o nó\n// for interrompido ou reimplementado.\n"
        },
        "require": {
            "var": "variável",
             "module": "módulo",
             "moduleName": "Nome do módulo",
             "importAs": "Importar como"
        },
        "error": {
            "externalModuleNotAllowed": "O nó de função não tem permissão para carregar módulos externos",
             "moduleNotAllowed": "Módulo __module__ não permitido",
             "externalModuleLoadError": "O nó de função falhou ao carregar módulos externos",
             "moduleLoadError": "Falha ao carregar o módulo __module__: __error__",
             "moduleNameError": "Nome da variável do módulo inválido: __name__",
             "moduleNameReserved": "Nome da variável reservada: __name__",
             "inputListener": "Não é possível adicionar um ouvinte ao evento de 'input' dentro da Função",
             "non-message-returned": "A função tentou enviar uma mensagem do tipo __type__",
             "invalid-js": "Erro no código JavaScript",
             "missing-module": "Modulo __module__ ausente"
        }
    },
    "template": {
        "template": "modelo",
        "label": {
            "template": "Modelo",
             "property": "Propriedade",
             "format": "Destaque de sintaxe",
             "syntax": "Formato",
             "output": "Saída como",
             "mustache": "Modelo de bigode",
             "plain": "Texto simples",
             "json": "JSON analisado",
             "yaml": "YAML analisado",
             "none": "nenhum"
        },
        "templatevalue": "Esta é a mensagem transmitida: {{payload}}!"
    },
    "delay": {
        "action": "Ação",
        "for": "Para",
        "delaymsg": "Atrasar cada mensagem",
        "delayfixed": "Atraso corrigido",
        "delayvarmsg": "Substituir atraso com msg.delay",
        "randomdelay": "Atraso aleatório",
        "limitrate": "Limite de taxa",
        "limitall": "Todas as mensagens",
        "limittopic": "Para cada msg.topic",
        "fairqueue": "Envie cada tópico por vez",
        "timedqueue": "Enviar todos os tópicos",
        "milisecs": "Milissegundos",
        "secs": "Segundos",
        "sec": "Segundo",
        "mins": "Minutos",
        "min": "Minuto",
        "hours": "Horas",
        "hour": "Hora",
        "days": "Dias",
        "day": "Dia",
        "between": "Entre",
        "and": "&",
        "rate": "Taxa",
        "msgper": "msg(s) por",
        "queuemsg": "Enfileirar mensagens intermediárias",
        "dropmsg": "descarte mensagens intermediárias",
        "sendmsg": "Enviar mensagens intermediárias na 2ª saída",
        "allowrate": "permitir msg.rate (em ms) para substituir a taxa",
        "label": {
            "delay": "atraso",
            "variable": "variável",
            "limit": "limite",
            "limitTopic": "limite de tópico",
            "random": "randômico",
            "rate": "taxa",
            "random-first": "primeiro valor randômico",
            "random-last": "último valor randômico",
            "units" : {
                "second": {
                    "plural" : "Segundos",
                    "singular": "Segundo"
                },
                "minute": {
                    "plural" : "Minutos",
                    "singular": "Minuto"
                },
                "hour": {
                    "plural" : "Horas",
                    "singular": "Hora"
                },
                "day": {
                    "plural" : "Dias",
                    "singular": "Dia"
                }
            }
        },
        "errors": {
            "too-many": "muitas mensagens pendentes no nó de atraso",
            "invalid-timeout": "Valor de atraso inválido",
            "invalid-rate": "Valor de taxa inválido",
            "invalid-rate-unit": "Valor de unidade de taxa inválido",
            "invalid-random-first": "Primeiro valor randômico inválido",
            "invalid-random-last": "Último valor randômico inválido"
        }
    },
    "trigger": {
        "send": "Enviar", 
        "then": "então", 
        "then-send": "então enviem",
        "output": {
            "string": "a cadeia de caracteres",
            "number": "o número",
            "existing": "o objeto msg existente",
            "original": "o objeto msg original",
            "latest": "o objeto de mensagem mais recente",
            "nothing": "nada"
        },
        "wait-reset": "aguarde para ser reiniciado",
        "wait-for": "esperar por",
        "wait-loop": "reenviar a cada",
        "for": "Manuseio",
        "bytopics": "cada",
        "alltopics": "todas as mensagens",
        "duration": {
            "ms": "Milissegundos",
            "s": "Segundos",
            "m": "Minutos",
            "h": "Horas"
        },
        "extend": "estender o atraso se uma nova mensagem chegar",
        "override": "anular o atraso com msg.delay",
        "second": "enviar segunda mensagem para saída separada",
        "label": {
            "trigger": "gatilho",
             "trigger-block": "gatilho & bloqueio",
             "trigger-loop": "reenviar a cada",
             "reset": "Reinicialize o gatilho se:",
             "resetMessage": "msg.reset está definida",
             "resetPayload": "msg.payload é igual a",
             "resetprompt": "opcional",
             "duration": "duração",
             "topic": "tópico"
        }
    },
    "comment": {
        "comment": "comentário"
    },
    "unknown": {
        "label": {
            "unknown": "desconhecido"
        },
        "tip": "<p>Este nó é desconhecido para a sua instalação do Node-RED.</p><p><i>Se você decidir implementar com o nó neste estado, sua configuração será preservada, mas o fluxo não será iniciado até que o tipo ausente seja instalado.</i></p><p>Consulte a barra lateral de informações para obter mais ajuda</p> "
    },
    "mqtt": {
        "label": {
            "broker": "Servidor",
            "example": "por exemplo, localhost",
            "output": "Saída",
            "qos": "QoS",
            "retain": "Reter",
            "clientid": "ID do cliente",
            "port": "Porta",
            "keepalive": "Mantenha-se vivo",
            "cleansession": "Usar sessão limpa",
            "cleanstart": "Usar um começo limpo",
            "use-tls": "Usar TLS",
            "tls-config": "Configuração TLS",
            "verify-server-cert": "Verifique o certificado do servidor",
            "compatmode": "Usar suporte MQTT 3.1 legado",
            "userProperties": "Propriedades do usuário",
            "subscriptionIdentifier": "ID de inscrição",
            "flags": "Bandeiras",
            "nl": "Não receber mensagens publicadas por este cliente",
            "rap": "Manter a bandeira de retenção da publicação original",
            "rh": "Tratamento de mensagens retidas",
            "rh0": "Enviar mensagens retidas",
            "rh1": "Enviar apenas para novas assinaturas",
            "rh2": "Não enviar",
            "responseTopic": "Tópico de resposta",
            "contentType": "Tipo de conteúdo",
            "correlationData": "Dados de Correlação",
            "expiry": "Expira (s)",
            "sessionExpiry": "Expiração da Sessão (s)",
            "topicAlias": "Apelido",
            "payloadFormatIndicator": "Formato",
            "payloadFormatIndicatorFalse": "bytes não especificados (padrão)",
            "payloadFormatIndicatorTrue": "Mensagem codificada em UTF-8",
            "protocolVersion": "Protocolo",
            "protocolVersion3": "MQTT V3.1 (legado)",
            "protocolVersion4": "MQTT V3.1.1",
            "protocolVersion5": "MQTT V5",
            "topicAliasMaximum": "Alias ​​Max",
            "maximumPacketSize": "Tamanho máximo do pacote",
            "receiveMaximum": "Recebimento Máximo",
            "session": "Sessão",
            "delay": "Atraso",
            "action": "Ação",
            "staticTopic": "Assinar um tópico único",
            "dynamicTopic": "Assinatura dinâmica",
            "auto-connect": "Conectar automaticamente",
            "auto-mode-depreciated": "Esta opção está deprecada. Favor utilizar o novo modo de auto-detecção."            
        },
        "sections-label": {
            "birth-message": "Mensagem enviada na conexão (mensagem de nascimento)",
            "will-message": "Mensagem enviada em uma desconexão inesperada (mensagem de dever)",
            "close-message": "Mensagem enviada antes de desconectar (mensagem de fechamento)"
        },
        "tabs-label": {
            "connection": "Conexão",
            "security": "Segurança",
            "messages": "Mensagens"
        },
        "placeholder": {
            "clientid": "Deixe em branco para geração automática",
            "clientid-nonclean": "Deve ser definido para sessões não limpas",
            "will-topic": "Deixe em branco para desativar a mensagem de dever",
            "birth-topic": "Deixe em branco para desativar a mensagem de nascimento",
            "close-topic": "Deixe em branco para desativar a mensagem de fechamento"
        },
        "state": {
            "connected": "Conectado ao negociante: _ broker _", 
            "disconnected": "Desconectado do negociante: _ broker _", 
            "connect-failed": "Falha na conexão com o negociante: __broker__",
            "broker-disconnected": "Cliente de negociante __broker__ desconectado: __reasonCode__ __reasonString__"
        },
        "retain": "Reter",
        "output": {
            "buffer": "um armazenamento temporário",
            "string": "uma cadeia de caracteres",
            "base64": "uma cadeia de caracteres codificada em Base64",
            "auto": "detecção automática (cadeia de caracteres ou armazenamento temporário)",
            "auto-detect": "auto-detecção(objeto JSON, cadeia de caracteres ou armazenamento temporário analisados sintaticamente)",
            "json": "um objeto JSON analisado sintaticamente"
        },
        "true": "verdadeiro",
        "false": "falso",
        "tip": "Dica: deixe o tópico, qos ou retenha em branco se quiser defini-los por meio das propriedades da mensagem.",
        "errors": {
            "not-defined": "tópico não definido",
            "missing-config": "configuração do corretor ausente",
            "invalid-topic": "Tópico inválido especificado",
            "nonclean-missingclientid": "Nenhum ID de cliente definido, usando sessão limpa",
            "invalid-json-string": "Cadeia de caracteres JSON inválida",
            "invalid-json-parse": "Falha ao analisar a cadeia de caracteres JSON",
            "invalid-action-action": "ação inválida especificada",
            "invalid-action-alreadyconnected": "Desconectado do agente antes de estar conectado",
            "invalid-action-badsubscription": "msg.topic não encontrado ou inválido",
            "invalid-client-id": "Faltando ID do cliente"
        }
    },
    "httpin": {
        "label": {
            "method": "Método",
            "url": "URL",
            "doc": "Documentos",
            "return": "Retorno",
            "upload": "Aceitar Subir arquivos?",
            "status": "Código de estado",
            "headers": "Cabeçalhos",
            "other": "outro",
            "paytoqs" : {
                "ignore": "Ignorar",
                "query": "Anexar aos parâmetros da cadeia de caracteres de consulta",
                "body": "Enviar como corpo de pedido"
            },
            "utf8String": "cadeia de caracteres UTF8",
            "binaryBuffer": "armazenamento temporário binário",
            "jsonObject": "objeto JSON analisado",
            "authType": "Tipo",
            "bearerToken": "Ficha"
        },
        "setby": "- definido por msg.method -",
        "basicauth": "Usar autenticação",
        "use-tls": "Ativar conexão segura (SSL / TLS)",
        "tls-config": "Configuração TLS",
        "basic": "autenticação básica",
        "digest": "processar autenticação",
        "bearer": "autenticação do portador",
        "use-proxy": "Use proxy",
        "persist": "Habilitar conexão mantenha-se vivo",
        "proxy-config": "Configuração de proxy",
        "use-proxyauth": "Usar autenticação de proxy",
        "noproxy-hosts": "Ignorar servidores",
        "senderr": "Somente envie respostas não-2xx para o nó de Captura",
        "utf8": "uma cadeia de caracteres UTF-8",
        "binary": "um armazenamento temporário binário",
        "json": "um objeto JSON analisado",
        "tip": {
            "in": "A url será relativa a",
            "res": "As mensagens enviadas para este nó <b>tem que</b> ser originadas a partir de um nó <i>http input</i>",
            "req": "Dica: Se a análise sintática JSON falhar, a cadeia de caracteres coletada é retornada assim como está."
        },
        "httpreq": "requisição http",
        "errors": {
            "not-created": "Não é possível criar o nó http-in quando o httpNodeRoot estiver definido como falso",
            "missing-path": "caminho ausente",
            "no-response": "Objeto sem resposta",
            "json-error": "Erro de análise sintática JSON",
            "no-url": "Nenhuma url especificada",
            "deprecated-call": "Chamada obsoleta para __method__",
            "invalid-transport": "transporte não-http solicitado",
            "timeout-isnan": "O valor do tempo de expiração não é um número válido, ignorando",
            "timeout-isnegative": "O valor do tempo de expiração é negativo, ignorando",
            "invalid-payload": "carga útil inválida",
            "invalid-url": "URL inválida"
        },
        "status": {
            "requesting": "solicitando"
        }
    },
    "websocket": {
        "label": {
            "type": "Tipo",
            "path": "Caminho",
            "url": "URL",
            "subprotocol": "Subprotocolo"
        },
        "listenon": "Ouvir em",
        "connectto": "Conectar-se a",
        "sendrec": "Enviar/Receber",
        "payload": "carga útil",
        "message": "mensagem inteira",
        "sendheartbeat": "Enviar batida de coração",
        "tip": {
            "path1": "Por padrão, a <code>carga útil</code> conterá os dados a serem enviados ou recebidos de um websocket. O ouvinte pode ser configurado para enviar ou receber todo o objeto de mensagem como uma cadeia de caracteres formatada em JSON.",
            "path2": "Este caminho será relativo a <code>__path__</code>.",
            "url1": "A URL deve usar o esquema ws:&#47;&#47; ou wss:&#47;&#47; e apontar para um ouvinte de websocket existente.",
            "url2": "Por padrão, <code>carga útil</code> conterá os dados a serem enviados ou recebidos de um websocket. O cliente pode ser configurado para enviar ou receber todo o objeto de mensagem como uma cadeia de caracteres formatada em JSON."
        },
        "status": {
            "connected": "conectado __count__",
            "connected_plural": "conectados __count__"
        },
        "errors": {
            "connect-error": "Ocorreu um erro na conexão ws:",
            "send-error": "Ocorreu um erro ao enviar:",
            "missing-conf": "Configuração do servidor ausente",
            "duplicate-path": "Não é possível ter dois ouvintes WebSocket no mesmo caminho: __path__",
            "missing-server": "Configuração de servidor não encontrada",
            "missing-client": "Configuração de cliente não encontrada"
        }
    },
    "watch": {
        "watch": "Observar",
        "label": {
            "files": "Arquivo(s)",
            "recursive": "Observe os subdiretórios recursivamente"
        },
        "placeholder": {
            "files": "Lista separada por vírgulas de arquivos e/ou diretórios"
        },
        "tip": "No Windows você deve usar barras invertidas duplas \\\\ em qualquer nome de diretório."
    },
    "tcpin": {
        "label": {
            "type": "Tipo",
            "output": "Saída",
            "port": "porta",
            "host": "no servidor",
            "payload": "carga(s) útil(eis)",
            "delimited": "delimitado por",
            "close-connection": "Fechar a conexão após o envio de cada mensagem?",
            "decode-base64": "Decodificar mensagem Base64?",
            "server": "Servidor",
            "return": "Retornar",
            "ms": "ms",
            "chars": "caracteres",
            "close": "Fechar",
            "optional": "(opcional)",
            "reattach": "Reanexar delimitador"
        },
        "type": {
            "listen": "Ouvindo na",
            "connect": "Conectar a",
            "reply": "Responder ao TCP"
        },
        "output": {
            "stream": "transmissão de",
            "single": "único",
            "buffer": "Armazenamento Temporário",
            "string": "Cadeia de caracteres",
            "base64": "Cadeia de caracteres Base64"
        },
        "return": {
            "timeout": "após um tempo de expiração fixo de",
            "character": "quando o caractere recebido é",
            "number": "depois de um número fixo de caracteres",
            "never": "nunca - mantenha a conexão aberta",
            "immed": "imediatamente - não espere por resposta"
        },
        "status": {
            "connecting": "conectando a __host __: __ port__",
            "connected": "conectado a __host __: __ port__",
            "listening-port": "escutando na porta __port__",
            "stopped-listening": "parou de ouvir na porta",
            "connection-from": "conexão de __host __: __ port__",
            "connection-closed": "conexão fechada de __host __: __ port__",
            "connections": "__count__ conexão",
            "connections_plural": "__count__ conexões"
        },
        "errors": {
            "connection-lost": "conexão perdida para __host __: __ port__",
             "timeout": "tempo limite fechado porta do soquete __port__",
             "cannot-listen": "não é possível escutar na porta __port__, erro: __error__",
             "error": "erro: __error__",
             "socket-error": "erro de soquete __host __: __ port__",
             "no-host": "Servidor e/ou porta não configurada",
             "connect-timeout": "tempo limite de conexão",
             "connect-fail": "falha de conexão",
             "bad-string": "falha ao converter para cadeia de caracteres",
             "invalid-host": "Servidor inválido",
             "invalid-port": "Porta inválida"
        }
    },
    "udp": {
        "label": {
            "listen": "Ouvindo ao",
             "onport": "na porta",
             "using": "usando",
             "output": "Saída",
             "group": "Grupo",
             "interface": "IF Local",
             "send": "Enviar um",
             "toport": "para a porta",
             "address": "Endereço",
             "decode-base64": "Decodificar carga útil codificada em Base64?",
             "port": "porta"
        },
        "placeholder": {
            "interface": "(opcional) interface local ou endereço para vincular a",
            "interfaceprompt": "(opcional) interface local ou endereço para vincular a",
            "address": "ip de destino"
        },
        "udpmsgs": "mensagens udp",
        "mcmsgs": "mensagens multidifusão",
        "udpmsg": "mensagem udp",
        "bcmsg": "mensagem de transmissão abrangente",
        "mcmsg": "mensagem multidifusão",
        "output": {
            "buffer": "um Armazenamento temporário",
            "string": "uma Cadeia de caracteres",
            "base64": "uma Cadeia de caracteres codificada em Base64"
        },
        "bind": {
            "random": "vincular a porta local aleatória",
            "local": "vincular à porta local",
            "target": "vincular à porta de destino"
        },
        "tip": {
            "in": "Dica: certifique-se de que seu dispositivo firewall permitirá a entrada de dados.",
            "out": "Dica: deixe o endereço e a porta em branco se quiser definir usando <code>msg.ip</code> e <code>msg.port</code>.",
            "port": "Portas já em uso:"
        },
        "status": {
            "listener-at": "ouvinte udp em __host __: __ port__",
             "mc-group": "grupo multidifusão udp __group__",
             "listener-stopped": "ouvinte udp parado",
             "output-stopped": "saída udp parada",
             "mc-ready": "multidifusão udp pronto: __iface __: __ outport__ -> __host __: __ port__",
             "bc-ready": "transmissão abrangente udp pronta: __outport__ -> __host __: __ port__",
             "ready": "udp pronto: __outport__ -> __host __: __ port__",
             "ready-nolocal": "udp pronto: __host __: __ port__",
             "re-use": "udp reutilizar soquete: __outport__ -> __host __: __ port__"
        },
        "errors": {
            "access-error": "Erro de acesso UDP, você pode precisar de acesso root para portas abaixo de 1024",
             "error": "erro: __error__",
             "bad-mcaddress": "Endereço multidifusão Ruim",
             "interface": "Deve ser o endereço IP da interface necessária",
             "ip-notset": "udp: endereço ip não definido",
             "port-notset": "udp: porta não configurada",
             "port-invalid": "udp: número da porta não é válido",
             "alreadyused": "udp: porta __port__ já em uso",
             "ifnotfound": "udp: interface __iface__ não encontrada",
             "invalid-group": "grupo multidifusão inválido"
        }
    },
    "switch": {
        "switch": "interruptor",
        "label": {
            "property": "Propriedade",
            "rule": "regra",
            "repair": "recriar sequências de mensagens",
            "value-rules": "regras de valores",
            "sequence-rules": "regras de sequencia"
        },
        "previous": "valor anterior",
        "and": "e",
        "checkall": "checando todas as regras",
        "stopfirst": "parando após a primeira correspondência",
        "ignorecase": "ignorar caso",
        "rules": {
            "btwn": "está entre",
            "cont": "contém",
            "regex": "corresponde a regex",
            "true": "é verdadeiro",
            "false": "é falso",
            "null": "é nulo",
            "nnull": "não é nulo",
            "istype": "é do tipo",
            "empty": "está vazio",
            "nempty": "não está vazio",
            "head": "topo",
            "tail": "final",
            "index": "índice entre",
            "exp": "JSONata exp",
            "else": "caso contrário",
            "hask": "tem chave"
        },
        "errors": {
            "invalid-expr": "Expressão JSONata inválida: __error__",
             "too-many": "muitas mensagens pendentes no nó interruptor"
        }
    },
    "change": {
        "label": {
            "rules": "Regras",
            "rule": "regra",
            "set": "definir __property__",
            "change": "alterar __property__",
            "delete": "apagar __property__",
            "move": "mover __property__",
            "changeCount": "alterar: __count__ regras",
            "regex": "Use expressões regulares",
            "deepCopy": "Valor de copia profunda"
        },
        "action": {
            "set": "Definir",
            "change": "Mudar",
            "delete": "Apagar",
            "move": "Mover",
            "toValue": "para o valor",
            "to": "para",
            "search": "Procurar por",
            "replace": "Substituir por"
        },
        "errors": {
            "invalid-from": "Propriedade 'from' inválida: __error__",
            "invalid-json": "Propriedade 'to' JSON inválida",
            "invalid-expr": "Expressão JSONata inválida: __error__",
            "no-override": "Não é possível definir a propriedade do tipo não objeto: __property__",
            "invalid-prop": "expressão de propriedade inválida: __property__",
            "invalid-json-data": " Dados JSON inválidos: __error__"
        }
    },
    "range": {
        "range": "alcance",
        "label": {
            "action": "Ação",
             "inputrange": "Mapeie o intervalo de entrada",
             "resultrange": "para o intervalo alvo",
             "from": "de",
             "to": "para",
             "roundresult": "Arredonda o resultado para o número inteiro mais próximo?",
             "minin": "entrada de",
             "maxin": "entrada para",
             "minout": "destino de",
             "maxout": "destino para"
        },
        "placeholder": {
            "min": "ex: 0",
            "maxin": "ex: 99",
            "maxout": "ex: 255"
        },
        "scale": {
            "payload": "Dimensione a propriedade da mensagem",
            "limit": "Escala e limite para o intervalo desejado",
            "wrap": "Escala e quebra dentro do intervalo desejado"
        },
        "tip": "Dica: Este nó SOMENTE funciona com números.",
        "errors": {
            "notnumber": "Não é um número"
        }
    },
    "csv": {
        "label": {
            "columns": "Colunas",
            "separator": "Separador",
            "c2o": "opções CSV para objeto",
            "o2c": "opções Objeto para CSV",
            "input": "Entrada",
            "skip-s": "Pular primeiro",
            "skip-e": "linhas",
            "firstrow": "a primeira linha contém os nomes das colunas",
            "output": "Saída",
            "includerow": "incluir linha de nome de coluna",
            "newline": "Nova linha",
            "usestrings": "analise sintática de valores numéricos",
            "include_empty_strings": "incluir cadeia de caracteres vazias",
            "include_null_values": "incluir valores nulos"
        },
        "placeholder": {
            "columns": "nomes de colunas separados por vírgulas"
        },
        "separator": {
            "comma": "vírgula",
             "tab": "tabulação",
             "space": "espaço",
             "semicolon": "ponto e vírgula",
             "colon": "dois pontos",
             "hashtag": "tralha",
             "other": "outro..."
        },
        "output": {
            "row": "uma mensagem por linha",
            "array": "uma única mensagem [matriz]"
        },
        "newline": {
            "linux": "Linux (\\n)",
            "mac": "Mac (\\r)",
            "windows": "Windows (\\r\\n)"
        },
        "hdrout": {
            "none": "nunca enviar cabeçalhos de coluna",
             "all": "sempre enviar cabeçalhos de coluna",
             "once": "envia cabeçalhos uma vez, até msg.reset"
        },
        "errors": {
            "csv_js": "Este nó lida apenas com cadeia de caracteres CSV ou objetos js.",
            "obj_csv": "Nenhum modelo de colunas especificado para o objeto -> CSV.",
            "bad_csv": "Dados CSV malformados - saída provavelmente corrompida."
        }
    },
    "html": {
        "label": {
            "select": "Seletor",
            "output": "Saída",
            "in": "entrada"
        },
        "output": {
            "html": "o conteúdo HTML dos elementos",
            "text": "apenas o conteúdo de texto dos elementos",
            "attr": "um objeto de quaisquer atributos dos elementos"
        },
        "format": {
            "single": "como uma única mensagem contendo uma matriz",
            "multi": "como mensagens múltiplas, uma para cada elemento"
        }
    },
    "json": {
        "errors": {
            "dropped-object": "Carga útil não objeto ignorada",
            "dropped": "Tipo de carga útil não suportada ignorada",
            "dropped-error": "Falha ao converter carga útil",
            "schema-error": "Erro de esquema JSON",
            "schema-error-compile": "Erro de esquema JSON: falha ao compilar o esquema"
        },
        "label": {
            "o2j": "Objeto para opções JSON",
            "pretty": "Formatar cadeia de caracteres JSON",
            "action": "Ação",
            "property": "Propriedade",  
            "actions": {
                "toggle": "Converter entre cadeia de caracteres JSON e Objeto",
                "str": "Sempre converter em cadeia de caracteres JSON",
                "obj": "Sempre converter para objeto JavaScript"
            }
        }
    },
    "yaml": {
        "errors": {
            "dropped-object": "Carga útil não objeto ignorada",
            "dropped": "Tipo de carga útil não suportada ignorado",
            "dropped-error": "Falha ao converter carga útil"
        }
    },
    "xml": {
        "label": {
            "represent": "Nome da propriedade para atributos de tag XML",
            "prefix": "Nome da propriedade para o conteúdo do texto da tag",
            "advanced": "Opções avançadas",
            "x2o": "Opções de XML para objeto"
        },
        "errors": {
            "xml_js": "Este nó lida apenas com cadeia de caracteres xml ou objetos js."
        }
    },
    "file": {
        "label": {
            "write": "escrever arquivo",
            "read": "ler arquivo",
            "filename": "Nome do arquivo",
            "path": "caminho", 
            "action": "Ação",
            "addnewline": "Adicionar nova linha (\\n) a cada carga útil?",
            "createdir": "Criar diretório se não existir?",
            "outputas": "Gerar como",
            "breakchunks": "Quebre em pedaços",
            "breaklines": "Quebra nas linhas",
            "sendError": "Enviar mensagem em caso de erro (modo legado)",
            "encoding": "Codificação",
            "deletelabel": "excluir __file__",
            "utf8String": "cadeia de caracteres UTF8",
            "utf8String_plural": "cadeia de caracteres UTF8",
            "binaryBuffer": "armazenamento temporário binário",
            "binaryBuffer_plural": "armazenamentos temporários binários",
            "allProps": "inclui todas as propriedades existentes em cada mensagem"
        },
        "action": {
            "append": "adicionar ao arquivo",
            "overwrite": "sobrescrever file",
            "delete": "apagar file"
        },
        "output": {
            "utf8": "uma única cadeia de caracteres utf8",
            "buffer": "um único objeto de armazenamento temporário",
            "lines": "uma mensagem por linha",
            "stream": "um transmissão do armazenamento temporário"
        },
        "status": {
            "wrotefile": "escreveu no arquivo: __file__",
             "deletedfile": "arquivo excluído: __file__",
             "appendedfile": "anexado ao arquivo: __file__"
        },
        "encoding": {
            "none": "padrão",
            "setbymsg": "definido por msg.encoding",
            "native": "Nativo",
            "unicode": "Unicode",
            "japanese": "Japonês",
            "chinese": "Chinês",
            "korean": "Coreano",
            "taiwan": "Taiwan / Hong Kong",
            "windows": "Páginas de código do Windows",
            "iso": "Páginas de código ISO",
            "ibm": "Páginas de código IBM",
            "mac": "Páginas de código Mac",
            "koi8": "Páginas de código KOI8",
            "misc": "Diversos"
        },
        "errors": {
            "nofilename": "Nenhum nome de arquivo especificado",
            "invaliddelete": "Aviso: exclusão inválida. Use a opção de exclusão específica na caixa de diálogo de configuração.",
            "deletefail": "falhou ao apagar o arquivo: __error__",
            "writefail": "falha ao gravar no arquivo: __error__",
            "appendfail": "falhou ao adicionar ao final do arquivo: __error__",
            "createfail": "falhou ao criar o arquivo: __error__"
        },
        "tip": "Dica: O nome do arquivo deve ser um caminho absoluto, caso contrário, será relativo ao diretório de trabalho do processo Node-RED."
    },
    "split": {
        "split": "dividir",
         "intro": "Divida <code>msg.payload</code> com base no tipo:",
         "object": "<b>Objeto</b>",
         "objectSend": "Envia uma mensagem para cada par chave/valor",
         "strBuff": "<b>Cadeia de caracteres</b> / <b>Armazenamento Temporário</b>",
         "array": "<b>Matriz</b>",
         "splitUsing": "Dividir usando",
         "splitLength": "Comprimento fixo de",
         "stream": "Tratar como uma transmissão de mensagens",
         "addname": "Copiar chave para"
    },
    "join": {
        "join": "junte",
        "mode": {
            "mode": "Modo",
            "auto": "automático",
            "merge": "sequências de mesclagem",
            "reduce": "reduzir sequência",
            "custom": "manual"
        },
        "combine": "Combine cada",
        "completeMessage": "mensagem completa",
        "create": "para criar",
        "type": {
            "string": "uma Cadeia de caracteres",
            "array": "uma Matriz",
            "buffer": "um Armazenamento Temporário",
            "object": "um Objeto chave/valor",
            "merged": "um Objeto mesclado"
        },
        "using": "usando o valor de",
        "key": "como a chave",
        "joinedUsing": "juntou-se usando",
        "send": "Envie a mensagem:",
        "afterCount": "Depois de várias partes da mensagem",
        "count": "contar",
        "subsequent": "e todas as mensagens subsequentes.",
        "afterTimeout": "Após um tempo limite esgotado em seguida da primeira mensagem",
        "seconds": "segundos",
        "complete": "Após uma mensagem com a propriedade <code>msg.complete</code> definida",
        "tip": "Este modo assume que este nó ou está pareado com um nó de <i>divisão</i> ou as mensagens recebidas terão uma propriedade <code>msg.parts</code> devidamente configurada.",
        "too-many": "muitas mensagens pendentes no nó de junção",
        "message-prop": "propriedade da mensagem",
        "merge": {
            "topics-label": "Tópicos mesclados",
             "topics": "tópicos",
             "topic": "tópico",
             "on-change": "Enviar mensagem mesclada na chegada de um novo tópico"
        },
        "reduce": {
            "exp": "Reduzir exp",
            "exp-value": "valor da exp",
            "init": "Valor inicial",
            "right": "Avalie na ordem inversa (do último ao primeiro)",
            "fixup": "Exp de reparo"
        },
        "errors": {
            "invalid-expr": "Expressão JSONata inválida: __error__",
            "invalid-type": "Não é possível juntar __error__ ao armazenamento temporário"
        }
    },
    "sort": {
        "sort": "ordenar",
        "target": "Classificar",
        "seq": "sequência de mensagens",
        "key": "Chave",
        "elem": "valor do elemento",
        "order": "Pedido",
        "ascending": "ascendente",
        "descending": "descendente",
        "as-number": "como número",
        "invalid-exp": "Expressão JSONata inválida no nó de classificação: __message__",
        "too-many": "Muitas mensagens pendentes no nó de classificação",
        "clear": "limpar a mensagem pendente no nó de classificação"
    },
    "batch" : {
        "batch": "lote",
        "mode": {
            "label": "Modo", 
            "num-msgs": "Agrupar por número de mensagens", 
            "interval": "Agrupar por intervalo de tempo", 
            "concat": "Concatenar sequências"
        },
        "count": {
            "label": "Número de mensagens",
            "overlap": "Sobreposição",
            "count": "contar",
            "invalid": "Contagem inválida e sobreposição"
        },
        "interval": {
            "label": "Intervalo",
            "seconds": "segundos",
            "empty": "enviar mensagem vazia quando nenhuma mensagem chegar"
        },
        "concat": {
            "topics-label": "Tópicos",
            "topic": "tópico"
        },
        "too-many": "muitas mensagens pendentes no nó de lote",
         "unexpected": "modo inesperado",
         "no-parts": "sem partes de propriedades na mensagem",
         "error": {
            "invalid-count": "Contador inválido",
            "invalid-overlap": "Sobreposição inválida",
            "invalid-interval": "Intervalo inválido"
        }
    },
    "rbe": {
        "rbe": "filtro",
        "label": {
            "func": "Modo",
            "init": "Enviar valor inicial",
            "start": "Valor inicial",
            "name": "Nome",
            "septopics": "Aplicar modo separadamente para cada",
            "gap": "troca de valor",
            "property": "propriedade",
            "topic": "tópico"
        },
        "placeholder":{
            "bandgap": "por exemplo, 10 ou 5%",
            "start": "deixe em branco para usar os primeiros dados recebidos"
        },
        "opts": {
            "rbe": "bloquear a menos que o valor mude",
            "rbei": "bloquear a menos que o valor mude (ignorar o valor inicial)",
            "deadband": "bloquear a menos que a alteração do valor seja maior que",
            "deadbandEq": "bloquear a menos que a alteração do valor seja maior ou igual a",
            "narrowband": "bloquear se a alteração do valor for maior que",
            "narrowbandEq": "bloquear se a alteração do valor for maior ou igual a",
            "in": "em comparação com o último valor de entrada",
            "out": "em comparação com o último valor de saída válido"
        },
        "warn": {
            "nonumber": "nenhum número encontrado na carga útil"
        }
    }
}
