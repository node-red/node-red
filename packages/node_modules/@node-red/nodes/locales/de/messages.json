{
    "common": {
        "label": {
            "payload": "Nutzdaten (Payload)",
            "topic": "Topic",
            "name": "Name",
            "username": "Benutzername",
            "password": "Passwort",
            "property": "Eigenschaft",
            "selectNodes": "Nodes auswählen ...",
            "expand": "Erweitern"
        },
        "status": {
            "connected": "Verbunden",
            "not-connected": "Nicht verbunden ",
            "disconnected": "Verbindung getrennt",
            "connecting": "Verbindung wird hergestellt",
            "error": "Fehler",
            "ok": "OK"
        },
        "notification": {
            "error": "<strong>Fehler:</strong> __message__",
            "errors": {
                "not-deployed": "Node nicht vorhanden",
                "no-response": "Keine Antwort vom Server",
                "unexpected": "Unerwarteter Fehler (__status__) __message__"
            }
        },
        "errors": {
            "nooverride": "Warnung: Nachrichten-Eigenschaften können die Eigenschaften des festgelegten Nodes nicht mehr außer Kraft setzen. Siehe Bit.ly/nr-override-msg-props"
        }
    },
    "inject": {
        "inject": "inject",
        "repeat": "Wiederholen = __repeat__",
        "crontab": "Crontab = __crontab__",
        "stopped": "Gestoppt",
        "failed": "Injizieren fehlgeschlagen: __error__",
        "label": {
            "properties": "Eigenschaften",
            "repeat": "Wiederholung",
            "flow": "Flow Kontext",
            "global": "Globaler Kontext",
            "str": "string",
            "num": "number",
            "bool": "boolean",
            "json": "object",
            "bin": "buffer",
            "date": "timestamp",
            "env": "Umgebungsvariable",
            "object": "object",
            "string": "string",
            "boolean": "boolean",
            "number": "number",
            "Array": "array",
            "invalid": "Üngültiges JSON-Objekt"
        },
        "timestamp": "timestamp",
        "none": "Keine",
        "interval": "Intervall",
        "interval-time": "Intervall zwischen Uhrzeiten",
        "time": "Täglicher Zeitpunkt",
        "seconds": "Sekunden",
        "minutes": "Minuten",
        "hours": "Stunden",
        "between": "zwischen",
        "previous": "vorheriger Wert",
        "at": "um",
        "and": "und",
        "every": "alle",
        "days": [
            "Montag",
            "Dienstag",
            "Mittwoch",
            "Donnerstag",
            "Freitag",
            "Samstag",
            "Sonntag"
        ],
        "on": "am",
        "onstart": "Einmal injizieren nach",
        "onceDelay": "Sekunden, danach",
        "success": "Erfolgreich injiziert: __label__",
        "errors": {
            "failed": "Injizieren fehlgeschlagen, siehe Protokoll für Details",
            "toolong": "Intervall zu groß",
            "invalid-expr": "Üngültiger JSONata-Ausdruck: __error__"
        }
    },
    "catch": {
        "catch": "catch: Alle",
        "catchNodes": "catch: __number__",
        "catchUncaught": "catch: Nicht gefangen",
        "label": {
            "source": "Fehler abfangen von",
            "selectAll": "Alles auswählen",
            "uncaught": "Fehler ignorieren, die von anderen catch-Nodes behandelt wurden"
        },
        "scope": {
            "all": "allen Nodes",
            "group": "in gleicher Gruppe",
            "selected": "ausgewählten Nodes"
        }
    },
    "status": {
        "status": "status: Alle",
        "statusNodes": "status: __number__",
        "label": {
            "source": "Status melden von",
            "sortByType": "Nach Typ sortieren"
        },
        "scope": {
            "all": "allen Nodes",
            "group": "in gleicher Gruppe",
            "selected": "ausgewählten Nodes"
        }
    },
    "complete": {
        "completeNodes": "complete: __number__"
    },
    "debug": {
        "output": "Ausgabe",
        "status": "Status",
        "none": "Keine",
        "invalid-exp": "Ungültiger JSONata-Ausdruck: __error__",
        "msgprop": "Nachrichteneigenschaft",
        "msgobj": "Kompletten Nachrichten-Objekt",
        "autostatus": "Identisch mit Debug-Ausgabe",
        "to": "über",
        "debtab": "Debug-Tab",
        "tabcon": "Debug-Tab und Systemkonsole",
        "toSidebar": "Debug-Tab",
        "toConsole": "Systemkonsole",
        "toStatus": "Node-Status (max. 32 Zeichen)",
        "severity": "Stufe",
        "notification": {
            "activated": "Erfolgreich aktiviert: __label__",
            "deactivated": "Erfolgreich deaktiviert: __label__"
        },
        "sidebar": {
            "label": "Debug",
            "name": "Debug-Nachrichten",
            "filterAll": "Alle Nodes/Flows",
            "filterSelected": "Ausgewählte Nodes",
            "filterCurrent": "Aktueller Flow",
            "debugNodes": "Debug-Nodes",
            "clearLog": "Debug-Protokoll löschen",
            "filterLog": "Debug-Protokoll filtern",
            "openWindow": "In neuem Fenster öffnen",
            "copyPath": "Pfad kopieren",
            "copyPayload": "Wert kopieren",
            "pinPath": "Angezeigt lassen (pinnen)"
        },
        "messageMenu": {
            "collapseAll": "Alle Pfade ausblenden",
            "clearPinned": "Gepinnte Anzeige rücksetzen",
            "filterNode": "Diesen Node filtern",
            "clearFilter": "Filter rücksetzen"
        }
    },
    "link": {
        "linkIn": "Eingehende Verbindung",
        "linkOut": "Ausgehende Verbindung"
    },
    "tls": {
        "tls": "TLS-Konfiguration",
        "label": {
            "use-local-files": "Schlüssel und Zertifikate aus lokalen Dateien verwenden",
            "upload": "Hochladen",
            "cert": "Zertifikat",
            "key": "Privater Schlüssel",
            "passphrase": "Passphrase",
            "ca": "CA-Zertifikat",
            "verify-server-cert": "Server-Zertifikat überprüfen",
            "servername": "Server-Name"
        },
        "placeholder": {
            "cert": "Pfad zu Zertifikat (PEM-Format)",
            "key": "Pfad zum privaten Schlüssel (PEM-Format)",
            "ca": "Pfad zu CA-Zertifikat (PEM-Format)",
            "passphrase": "Passphrase des privaten Schlüssels (optional)",
            "servername": "Zur Verwendung mit SNI"
        },
        "error": {
            "missing-file": "Keine Zertifikats-/Schlüsseldatei angegeben"
        }
    },
    "exec": {
        "exec": "exec",
        "spawn": "spawn",
        "label": {
            "command": "Befehl",
            "append": "Anhängen",
            "timeout": "Zeitlimit",
            "timeoutplace": "optional",
            "return": "Ausgabe",
            "seconds": "Sekunden",
            "stdout": "Standardausgabe (stdout)",
            "stderr": "Standardfehlerausgabe (stderr)",
            "retcode": "Rückgabe-Code"
        },
        "placeholder": {
            "extraparams": "Zusätzliche Übergabeparameter"
        },
        "opt": {
            "exec": "nach Befehlsabschluss (exec)",
            "spawn": "während Befehlausführung (spawn)"
        },
        "oldrc": "Alter Ausgabestil (Kompatibilitätsmodus)"
    },
    "function": {
        "function": "",
        "label": {
            "setup": "Setup",
            "function": "Funktion",
            "initialize": "Start",
            "finalize": "Stopp",
            "outputs": "Ausgänge",
            "modules": "Module",
            "timeout": "Timeout"
        },
        "text": {
            "initialize": "// Der Code hier wird ausgeführt,\n// wenn der Node gestartet wird\n",
            "finalize": "// Der Code hier wird ausgeführt,\n// wenn der Node gestoppt wird\n"
        },
        "require": {
            "var": "Variable",
            "module": "Modul"
        },
        "error": {
            "moduleNotAllowed": "Modul __module__ nicht erlaubt",
            "moduleLoadError": "Fehler beim Laden des Moduls __module__: __error__",
            "moduleNameError": "Ungültiger Modul-Variablenname: __name__",
            "moduleNameReserved": "Reservierter Variablenname: __name__",
            "inputListener": "Es kann keine Überwachung (listener) von 'input'-Ereignissen innerhalb der Funktion hinzugefügt werden",
            "non-message-returned": "Function hat versucht, eine Nachricht vom Typ __type__ zu senden"
        }
    },
    "template": {
        "template": "template",
        "label": {
            "template": "Vorlage",
            "property": "Eigenschaft",
            "format": "Syntaxhervorhebung",
            "syntax": "Format",
            "output": "Ausgabe als",
            "mustache": "Mustache-Vorlage",
            "plain": "Klartext",
            "json": "Parsed JSON",
            "yaml": "Parsed YAML",
            "none": "keine"
        },
        "templatevalue": "Dies sind die Nutzdaten (Payload): { { payload } }!"
    },
    "delay": {
        "action": "Aktion",
        "for": "Um",
        "delaymsg": "Jede Nachricht verzögern",
        "delayfixed": "Fixe Verzögerung",
        "delayvarmsg": "Verzög. mit msg.delay überschreiben",
        "randomdelay": "Zufällige Verzögerung",
        "limitrate": "Nachrichtenrate begrenzen",
        "limitall": "Alle Nachrichten",
        "limittopic": "Für jedes msg.topic",
        "fairqueue": "Jedes Topic der Reihe nach",
        "timedqueue": "Alle Topics senden",
        "milisecs": "Milisekunden",
        "secs": "Sekunden",
        "sec": "Sekunde",
        "mins": "Minuten",
        "min": "Minute",
        "hours": "Stunden",
        "hour": "Stunde",
        "days": "Tage",
        "day": "Tag",
        "between": "Zwischen",
        "and": "&",
        "rate": "Rate",
        "msgper": "msg(s) pro",
        "dropmsg": "Zwischennachrichten löschen",
        "label": {
            "delay": "Verzögerung",
            "variable": "Variable",
            "limit": "Begrenzung",
            "limitTopic": "Begrenzung Topic",
            "random": "Zufall",
            "units": {
                "second": {
                    "plural": "Sekunden",
                    "singular": "Sekunde"
                },
                "minute": {
                    "plural": "Minuten",
                    "singular": "Minute"
                },
                "hour": {
                    "plural": "Stunden",
                    "singular": "Stunde"
                },
                "day": {
                    "plural": "Tage",
                    "singular": "Tag"
                }
            }
        },
        "error": {
            "buffer": "Puffer enthält mehr als 1.000 Nachrichten",
            "buffer1": "Puffer enthält mehr als 10.000 Nachrichten"
        }
    },
    "trigger": {
        "send": "Sende",
        "then": "dann",
        "then-send": "dann sende",
        "output": {
            "string": "die Zeichenfolge",
            "number": "die Zahl",
            "existing": "vorhandenes Nachrichtenobjekt",
            "original": "originales Nachrichtenobjekt",
            "latest": "letztes Nachrichtenobjekt",
            "nothing": "nichts"
        },
        "wait-reset": "warten auf Rücksetzung (Block)",
        "wait-for": "warte für",
        "wait-loop": "sende erneut alle",
        "for": "Behandlung",
        "bytopics": "jede",
        "alltopics": "alle Nachrichten",
        "duration": {
            "ms": "Millisekunden",
            "s": "Sekunden",
            "m": "Minuten",
            "h": "Stunden"
        },
        "extend": "Verzögerung verlängern bei Eingang neuer Nachrichten",
        "override": "Verzögerung mit msg.delay überschreiben",
        "second": "Sende zweite Nachricht über separaten Ausgang",
        "label": {
            "trigger": "Trigger",
            "trigger-block": "Trigger & Block",
            "trigger-loop": "erneut senden alle",
            "reset": "Trigger wird rückgesetzt durch:",
            "resetMessage": "msg.reset ist gesetzt",
            "resetPayload": "msg.payload ist gleich",
            "resetprompt": "optional"
        }
    },
    "comment": {
        "comment": "comment"
    },
    "unknown": {
        "label": {
            "unknown": "Unbekannt"
        },
        "tip": "<p>Dieser Node ist ein Typ, der Ihrer Node-RED-Installation unbekannt ist.</p><p><i>Wenn Sie den Node in diesem Zustand übernehmen (deploy), wird die Konfiguration beibehalten, aber der Flow wird erst gestartet, wenn der fehlende Node-Typ installiert ist.</i></p><p>Weitere Hilfe-Informationen finden Sie in der Info-Seitenleiste.</p>"
    },
    "mqtt": {
        "label": {
            "broker": "Server",
            "example": "z.B. lokaler Host",
            "output": "Ausgang",
            "qos": "QoS",
            "retain": "Retain",
            "clientid": "Client-ID",
            "port": "Port",
            "keepalive": "Keep-Alive",
            "cleansession": "Bereinigte Sitzung (clean session) verwenden",
            "autoUnsubscribe": "Abonnement bei Verbindungsende automatisch beenden",
            "cleanstart": "Verwende bereinigten Start",
            "use-tls": "TLS",
            "tls-config": "TLS-Konfiguration",
            "verify-server-cert": "Server-Zertifikat überprüfen",
            "compatmode": "MQTT 3.1 unterstützen",
            "userProperties": "Benutzereigenschaften",
            "subscriptionIdentifier": "Subscription ID",
            "flags": "Flags",
            "nl": "Keine Nachrichten vom diesem Client empfangen",
            "rap": "Retain-Flag behalten von originaler Veröffentlichung",
            "rh": "Behandlung aufbewahrter Nachrichten ",
            "rh0": "Aufbewahrte Nachrichten senden",
            "rh1": "Nur von neuen Abonnements senden",
            "rh2": "Nicht(s) senden",
            "responseTopic": "Antwort-Topic",
            "contentType": "Inhaltstyp",
            "correlationData": "Korrelationsdaten",
            "expiry": "Zeitablauf (s)",
            "sessionExpiry": "Session-Zeitablauf (s)",
            "topicAlias": "Alias",
            "payloadFormatIndicator": "Format",
            "payloadFormatIndicatorFalse": "Undefnierte Bytes (Standard)",
            "payloadFormatIndicatorTrue": "UTF-8 encodierte Nutzdaten",
            "protocolVersion": "Protokoll",
            "protocolVersion3": "MQTT V3.1 (legacy)",
            "protocolVersion4": "MQTT V3.1.1",
            "protocolVersion5": "MQTT V5",
            "topicAliasMaximum": "Alias Max",
            "maximumPacketSize": "Max. Packetgröße",
            "receiveMaximum": "Empfange Max.",
            "session": "Session",
            "delay": "Verzögerung"
        },
        "sections-label": {
            "birth-message": "Nachricht bei Verbindungsaufbau",
            "will-message": "Nachricht bei unerwarteten Verbindungsabbruch",
            "close-message": "Nachricht vor Verbindungsabbau"
        },
        "tabs-label": {
            "connection": "Verbindung",
            "security": "Sicherheit",
            "messages": "Nachrichten"
        },
        "placeholder": {
            "clientid": "Leer lassen für automatische Generierung",
            "clientid-nonclean": "Festzulegen bei non-clean sessions",
            "will-topic": "Keine Nachricht, wenn leer",
            "birth-topic": "Keine Nachricht, wenn leer",
            "close-topic": "Keine Nachricht, wenn leer"
        },
        "state": {
            "connected": "Verbindung zum Broker __broker__ aufgebaut",
            "disconnected": "Verbindung zum Broker __broker__ abgebaut",
            "connect-failed": "Verbindung zum Broker __broker__ konnte nicht hergestellt werden"
        },
        "retain": "Retain",
        "output": {
            "buffer": "Einen binären Buffer",
            "string": "Ein String",
            "base64": "Ein Base64-kodierter String",
            "auto": "Auto-Erkennung (string oder buffer)",
            "auto-detect": "Auto-Erkennung (parsed JSON-Objekt, string oder buffer)",
            "json": "Ein analysiertes (parsed) JSON-Objekt"
        },
        "true": "wahr",
        "false": "falsch",
        "tip": "Tipp: Topic, QoS oder Retain leer lassen, um diese über die msg-Eigenschaften festzulegen",
        "errors": {
            "not-defined": "Topic nicht definiert",
            "missing-config": "Fehlende Broker-Konfiguration",
            "invalid-topic": "Ungültiges Topic angegeben",
            "nonclean-missingclientid": "Keine Client-ID angegeben. Bereinigte Sitzung (clean session) wird verwendet.",
            "invalid-json-string": "Ungültiger JSON-String",
            "invalid-json-parse": "Analyse des JSON-Strings fehlgeschlagen"
        }
    },
    "httpin": {
        "label": {
            "method": "Methode",
            "url": "URL",
            "doc": "Docs",
            "return": "Rückgabe",
            "upload": "Dateiuploads akzeptieren",
            "status": "Statuscode",
            "headers": "Kopfzeilen",
            "rawBody": "Rohdaten einbeziehen?",
            "other": "andere",
            "paytoqs": {
                "ignore": "Ignorieren",
                "query": "Anfügen an query-string-Parameter",
                "body": "Senden als request-body"
            },
            "utf8String": "UTF-8-String",
            "binaryBuffer": "Binärer Buffer",
            "jsonObject": "Parsed JSON-Objekt",
            "authType": "Typ",
            "bearerToken": "Token"
        },
        "setby": "Durch msg.method festgelegt",
        "basicauth": "Basis-Authentifizierung verwenden",
        "use-tls": "Sichere Verbindung (SSL/TLS) aktivieren",
        "tls-config": "TLS-Konfiguration",
        "basic": "Basic-Authentifizierung",
        "digest": "Digest-Authentifizierung",
        "bearer": "Bearer-Authentifizierung",
        "use-proxy": "Proxy verwenden",
        "persist": "Verbindung aufrecht erhalten (keep-alive)",
        "proxy-config": "Proxy-Konfiguration",
        "use-proxyauth": "Proxy-Authentifizierung verwenden",
        "noproxy-hosts": "Hosts ignorieren",
        "utf8": "Eine UTF-8-Zeichenfolge",
        "binary": "Einen binären Buffer",
        "json": "Ein parsed JSON-Objekt",
        "tip": {
            "in": "Die URL ist relativ zu ",
            "res": "Die an diesen Node gesendeten Nachrichten <b>müssen</b> von einem http&nbsp;in-Node stammen",
            "req": "Tipp: Wenn die JSON-Syntax-Analyse fehlschlägt, wird die abgerufene Zeichenfolge zurückgegeben, wie sie ist."
        },
        "httpreq": "http request",
        "errors": {
            "not-created": "http in-Node kann nicht erstellt werden, wenn httpNodeRoot auf 'false' gesetzt ist.",
            "missing-path": "Fehlender Pfad",
            "no-response": "Kein Antwort-Objekt",
            "json-error": "JSON-Parse-Fehler",
            "no-url": "Keine URL angegeben",
            "deprecated-call": "Abgelehnter Aufruf von __method__",
            "invalid-transport": "Nicht-HTTP-Transport angefordert",
            "timeout-isnan": "Zeitlimit-Wert ignoriert, da keine gültige Zahl",
            "timeout-isnegative": "Zeitlimit-Wert ignoriert, da negative Zahl",
            "invalid-payload": "Üngültige Nutzdaten (Payload)"
        },
        "status": {
            "requesting": "Anfordernd"
        }
    },
    "websocket": {
        "label": {
            "type": "Typ",
            "path": "Pfad",
            "url": "URL",
            "subprotocol": "Subprotokoll"
        },
        "listenon": "Lauschen (listen on)",
        "connectto": "Verbinden mit",
        "sendrec": "Senden/ Empfangen",
        "payload": "Nutzdaten (Payload)",
        "message": "Gesamte Nachricht",
        "tip": {
            "path1": "Standardmäßig enthält <code>payload</code> die Daten, die über einen WebSocket gesendet oder von einem WebSocket empfangen werden. Der Empfänger (Listener) kann so konfiguriert werden, dass er das gesamte Nachrichtenobjekt als eine JSON-formatierte Zeichenfolge (string) sendet oder empfängt.",
            "path2": "Dieser Pfad ist relativ zu <code>__path__</code>.",
            "url1": "URL sollte ws:&#47;&#47; oder wss:&#47;&#47; Schema verwenden und auf einen vorhandenen WebSocket-Listener verweisen.",
            "url2": "Standardmäßig enthält <code>payload</code> die Daten, die über einen WebSocket gesendet oder von einem WebSocket empfangen werden. Der Client kann so konfiguriert werden, dass er das gesamte Nachrichtenobjekt als eine JSON-formatierte Zeichenfolge (string) sendet oder empfängt.",
            "headers": "Header werden nur während des Protokollaktualisierungsmechanismus übermittelt, von HTTP auf das WS/WSS-Protokoll."
        },
        "status": {
            "connected": "Verbunden __count__",
            "connected_plural": "Verbunden __count__"
        },
        "errors": {
            "connect-error": "Fehler dei der WS-Verbindung: ",
            "send-error": "Fehler beim Senden: ",
            "missing-conf": "Fehlende Server-Konfiguration",
            "duplicate-path": "Keine zwei WebSocket-Empfänger (Listener) möglich mit dem gleichen Pfad: __path__"
        }
    },
    "watch": {
        "watch": "watch",
        "label": {
            "files": "Datei (en)",
            "recursive": "Unterverzeichnisse rekursiv überwachen"
        },
        "placeholder": {
            "files": "Kommagetrennte Datei- bzw. Verzeichnisliste"
        },
        "tip": "Unter Windows müssen doppelte Schrägstriche \\\\ in Verzeichnisnamen verwendet werden"
    },
    "tcpin": {
        "label": {
            "type": "Typ",
            "output": "Ausgang",
            "port": "Port",
            "host": "Host",
            "payload": "Nutzdaten (Payload)",
            "delimited": "Begrenzt durch",
            "close-connection": "Verbindung nach jeder gesendeten Nachricht schließen",
            "decode-base64": "Base64-Nachricht dekodieren",
            "server": "Server",
            "return": "Rückkehr",
            "ms": "ms",
            "chars": "Zeichen"
        },
        "type": {
            "listen": "Lauschen an",
            "connect": "Verbinden mit",
            "reply": "Auf TCP antworten"
        },
        "output": {
            "stream": "Strom von",
            "single": "Einzelne",
            "buffer": "Buffer",
            "string": "Strings",
            "base64": "Base64-Strings"
        },
        "return": {
            "timeout": "nach festen Zeitlimit von",
            "character": "bei Empfang des Zeichens",
            "number": "nach fester Zeichenanzahl von",
            "never": "niemals - Verbindung wird gehalten",
            "immed": "sofort - Antwort wird nicht abgewartet"
        },
        "status": {
            "connecting": "Verbinde mit __host__:__port__",
            "connected": "Verbunden mit __host__:__port__",
            "listening-port": "Empfangsbereit an Port __port__",
            "stopped-listening": "Empfangsbereitschaft gestoppt an Port",
            "connection-from": "Verbindung von __host__:__port__",
            "connection-closed": "Verbindung geschlossen von __host__:__port__",
            "connections": "__count__ Verbindung ",
            "connections_plural": "__count__ Verbindungen"

        },
        "errors": {
            "connection-lost": "Verbindung verloren zu __host__:__port__",
            "timeout": "Aufgrund Zeitüberschreitung geschlossener Port __port__",
            "cannot-listen": "Port __port__ kann nicht empfangsbereit gesetzt werden. FEHLER: __error__",
            "error": "FEHLER: __error__",

            "socket-error": "Socket-Fehler von __host__:__port__",
            "no-host": "Host und/oder Port nicht vorgegeben",
            "connect-timeout": "Verbindungs-Zeitüberschreitung",
            "connect-fail": "Verbindung fehlgeschlagen"
        }
    },
    "udp": {
        "label": {
            "listen": "Empfang von",
            "onport": "Port",
            "using": "Protokoll",
            "output": "Ausgabe",
            "group": "Gruppe",
            "interface": "Lokal-IF",
            "send": "Senden von",
            "toport": "Port",
            "address": "Adresse",
            "decode-base64": "Dekodierung Base64-kodierter Nutzdaten (Payload)"
        },
        "placeholder": {
            "interface": "(optional) lokale Schnittstelle oder Adresse",
            "interfaceprompt": "(optional) lokale Schnittstelle oder Adresse",
            "address": "Ziel-IP"
        },
        "udpmsgs": "UDP-Nachrichten",
        "mcmsgs": "Multicast-Nachrichten",
        "udpmsg": "UDP-Nachricht",
        "bcmsg": "Broadcast-Nachricht",
        "mcmsg": "Multicast-Nachricht",
        "output": {
            "buffer": "Ein binärer Buffer",
            "string": "Ein String",
            "base64": "Ein Base64-kodierter String"
        },
        "bind": {
            "random": "Bindung an zufälligen lokalen Port",
            "local": "Bindung an lokalen Port",
            "target": "Bindung an Ziel-Port"
        },
        "tip": {
            "in": "Tipp: Stellen Sie sicher, dass Ihre Firewall die eingehende Verbindung zulässt",
            "out": "Tipp: Lassen Sie Adresse- und Port-Angabe leer, wenn Sie diese mit <code>msg.ip</code> und <code>msg.port</code> vorgeben möchten",
            "port": "Bereits verwendete Ports: "
        },
        "status": {
            "listener-at": "UDP-Empfangsbereitschaft bei __host__:__port__",
            "mc-group": "UDP-Multicast-Gruppe __group__",
            "listener-stopped": "UDP-Empfangsbereitschaft gestoppt",
            "output-stopped": "UDP-Ausgabe gestoppt",
            "mc-ready": "UDP-Multicast bereit: __iface__: __outport__-> __host__:__port__",
            "bc-ready": "UDP-Broadcast bereit: __outport__-> __host__:__port__",
            "ready": "UDP bereit: __outport__-> __host__:__port__",
            "ready-nolocal": "UDP bereit: __host__:__port__",
            "re-use": "UDP Wiederverwendung Socket: __outport__-> __host__:__port__"
        },
        "errors": {
            "access-error": "UDP-Zugriffsfehler, Sie benötigen möglicherweise Root-Zugriff für Ports unter 1024",
            "error": "FEHLER: __error__",
            "bad-mcaddress": "Ungültige Multicast-Adresse",
            "interface": "Muss IP-Adresse der erforderlichen Schnittstelle sein",
            "ip-notset": "UDP: IP-Adresse nicht angegeben",
            "port-notset": "UDP: Port nicht angegeben",
            "port-invalid": "UDP: Port-Nummer ungültig",
            "alreadyused": "UDP: Port __port__ bereits in Verwendung",
            "ifnotfound": "UDP: Interface __iface__ nicht gefunden"
        }
    },
    "switch": {
        "switch": "switch",
        "label": {
            "property": "Eigenschaft",
            "rule": "Regel",
            "repair": "Nachrichtensequenzen erzeugen"
        },
        "previous": "Vorheriger Wert",
        "and": "und",
        "checkall": "Alle Regeln abarbeiten",
        "stopfirst": "Nach erster Regel-Übereinstimmung stoppen",
        "ignorecase": "Groß-/Kleinschreibung ignorieren",
        "rules": {
            "btwn": "liegt zwischen",
            "cont": "enthält",
            "regex": "Regulärer Ausdruck",
            "true": "ist true",
            "false": "ist false",
            "null": "ist null",
            "nnull": "ist nicht null",
            "istype": "ist vom Typ",
            "empty": "ist leer",
            "nempty": "ist nicht leer",
            "head": "Anfang",
            "tail": "Ende",
            "index": "Index zwischen",
            "exp": "JSONata-Ausdruck",
            "else": "ansonsten",
            "hask": "hat Schlüssel"
        },
        "errors": {
            "invalid-expr": "Ungültiger JSONata-Ausdruck: __error__",
            "too-many": "Zu viele anstehende Nachrichten im switch-Node"
        }
    },
    "change": {
        "label": {
            "rules": "Regeln",
            "rule": "Regel",
            "set": "setze __property__",
            "change": "__property__ ändern",
            "delete": "__property__ löschen",
            "move": "bewege __property__",
            "changeCount": "change: __count__ Regeln",
            "regex": "Reguläre Ausdrücke verwenden"
        },
        "action": {
            "set": "Setze",
            "change": "Ändere",
            "delete": "Lösche",
            "move": "Verschiebe",
            "to": "auf/nach",
            "search": "Suche nach",
            "replace": "Ersetze durch"
        },
        "errors": {
            "invalid-from": "Ungültiges 'from' Merkmal: __error__",
            "invalid-json": "Ungültiges 'to' JSON Merkmal",
            "invalid-expr": "Ungültiger JSONata Ausdruck: __error__",
            "no-override": "Cannot set property of non-object type: __property__"
        }
    },
    "range": {
        "range": "range",
        "label": {
            "action": "Modus",
            "inputrange": "Eingangswertebereich",
            "resultrange": "Ausgangswertebereich",
            "from": "von",
            "to": "bis",
            "roundresult": "Runde Ergebnis auf die nächste ganze Zahl"
        },
        "placeholder": {
            "min": "z.B. 0",
            "maxin": "z.B. 99",
            "maxout": "z.B. 255"
        },
        "scale": {
            "payload": "Skalierung",
            "limit": "Skalierung und Begrenzung",
            "wrap": "Skalieren und Begrenzung mit Überlauf"
        },
        "tip": "Tipp: Dieser Node funktioniert NUR mit Zahlenwerten.",
        "errors": {
            "notnumber": "Keine Zahl"
        }
    },
    "csv": {
        "label": {
            "columns": "Spalten",
            "separator": "Trennzeichen",
            "c2o": "Optionen CSV zu Objekt",
            "o2c": "Optionen Objekt zu CSV",
            "input": "Eingang",
            "skip-s": "Überspringe erste",
            "skip-e": "Zeile(n)",
            "firstrow": "Erste Zeile enthält Spaltennamen",
            "output": "Ausgang",
            "includerow": "Spaltennamenszeile einschließen",
            "newline": "Zeilenvorschub",
            "usestrings": "Zahlenwerte ermitteln",
            "include_empty_strings": "Leere Zeichenfolgen (string) einbeziehen",
            "include_null_values": "Nullwerte einbeziehen"
        },
        "placeholder": {
            "columns": "Durch Kommas getrennte Spaltennamen"
        },
        "separator": {
            "comma": "Komma",
            "tab": "Tab",
            "space": "Leerzeichen",
            "semicolon": "Semikolon",
            "colon": "Doppelpunkt",
            "hashtag": "Raute",
            "other": "Sonstiges"
        },
        "output": {
            "row": "Eine Nachricht pro Zeile",
            "array": "Eine einzige Nachricht (array)"
        },
        "newline": {
            "linux": "Linux (\\n)",
            "mac": "Mac (\\r)",
            "windows": "Windows (\\r\\n)"
        },
        "hdrout": {
            "none": "Spaltennamen niemals senden",
            "all": "Spaltennamen immer senden",
            "once": "Spaltennamen einmal senden bis msg.reset"
        },
        "errors": {
            "csv_js": "Dieser Node verarbeitet nur CSV-Zeichenfolgen oder JS-Objekte",
            "obj_csv": "Es wurde keine Spaltennamen für Objekt/CSV-Wandlung angegeben",
            "bad_csv": "Unförmige CSV-Daten - Ausgangsdaten möglicherweise korrupt"
        }
    },
    "html": {
        "label": {
            "select": "Selektor",
            "output": "Ausgang",
            "in": "in"
        },
        "output": {
            "html": "HTML-Inhalt der Elemente",
            "text": "Nur Textinhalt der Elemente",
            "attr": "Objekt mit allen Elemente-Attributen"
        },
        "format": {
            "single": "Eine Nachricht mit einem Array",
            "multi": "Einzelne Nachrichten je Element"
        }
    },
    "json": {
        "errors": {
            "dropped-object": "Nicht-Objekt-Nutzdaten (Payload) ignoriert",
            "dropped": "Nicht unterstützte Nutzdatentyp (Payload) ignoriert",
            "dropped-error": "Fehler beim Konvertieren der Nutzdaten (Payload)",
            "schema-error": "JSON-Schema-Fehler",
            "schema-error-compile": "JSON-Schema-Fehler: Schema konnte nicht kompiliert werden"
        },
        "label": {
            "o2j": "Optionen Objekt => JSON",
            "pretty": "JSON-Zeichenfolge formatieren",
            "action": "Aktion",
            "property": "Eigenschaft",
            "actions": {
                "toggle": "Konvertierung JSON-String <=> JS-Objekt",
                "str": "Konvertierung zu JSON-Zeichenfolge",
                "obj": "Konvertierung zu JavaScript-Objekt"
            }
        }
    },
    "yaml": {
        "errors": {
            "dropped-object": "Nicht-Objekt-Nutzdaten (Payload) ignoriert",
            "dropped": "Nicht unterstützte Nutzdatentyp (Payload) ignoriert",
            "dropped-error": "Fehler beim Konvertieren der Nutzdaten (Payload)"
        }
    },
    "xml": {
        "label": {
            "represent": "Eigenschaftsname für XML-Tag-Attribute",
            "prefix": "Eigenschaftsname für Tag-Textinhalt",
            "advanced": "Erweiterte Optionen",
            "x2o": "Optionen XML zu Objekt"
        },
        "errors": {
            "xml_js": "Dieser Node verarbeitet nur XML-Zeichenfolgen oder JS-Objekte."
        }
    },
    "file": {
        "label": {
            "filename": "Dateiname",
            "action": "Aktion",
            "addnewline": "Zeilenumbruch (\\n) zu jeden Nutzdaten (Payload) hinzufügen",
            "createdir": "Verzeichnis erstellen, wenn nicht vorhanden",
            "outputas": "Ausgabe",
            "breakchunks": "In Chunks aufteilen",
            "breaklines": "In Linien aufteilen",
            "sendError": "Nachricht bei Fehler senden (herkömmlicher Modus)",
            "encoding": "Kodierung",
            "deletelabel": "lösche __file__",
            "utf8String": "UTF-8-String",
            "binaryBuffer": "Binärer Buffer"
        },
        "action": {
            "append": "an Datei anhängen",
            "overwrite": "Datei überschreiben",
            "delete": "Datei löschen"
        },
        "output": {
            "utf8": "Einzelne UTF-8-Zeichenfolge",
            "buffer": "Einzelnes Buffer-Objekt",
            "lines": "Eine Nachricht je Zeile",
            "stream": "Datenstrom von binären Buffern"
        },
        "status": {
            "wrotefile": "In Datei geschrieben: __file__",
            "deletedfile": "Datei gelöscht: __file__",
            "appendedfile": "An Datei angehängt: __file__"
        },
        "encoding": {
            "none": "Standard (default)",
            "native": "Native",
            "unicode": "Unicode",
            "japanese": "Japanisch",
            "chinese": "Chinesisch",
            "korean": "Koreanisch",
            "taiwan": "Taiwan/Hong Kong",
            "windows": "Windows codepages",
            "iso": "ISO Codeseiten",
            "ibm": "IBM Codeseiten",
            "mac": "Mac Codeseiten",
            "koi8": "KOI8 Codeseiten",
            "misc": "Sonstige"
        },
        "errors": {
            "nofilename": "Kein Dateiname angegeben",
            "invaliddelete": "Warnung: Ungültiges Löschen. Bitte verwenden Sie im Konfigurationsdialog eine bestimmte Löschoption.",
            "deletefail": "Fehler beim Löschen der Datei: __error__",
            "writefail": "Fehler beim Schreiben in Datei: __error__",
            "appendfail": "Fehler beim Anhängen an Datei: __error__",
            "createfail": "Fehler beim Erstellen der Datei: __error__"
        },
        "tip": "Tipp: Der Dateiname sollte ein absoluter Pfad sein. Andernfalls wird er relativ zum Arbeitsverzeichnis des Node-RED-Prozesses angewandt."
    },
    "split": {
        "split": "split",
        "intro": "Aufteilung von <code>msg.payload</code> entsprechend dem Typ:",
        "object": "<b>object</b>",
        "objectSend": "Sende eine Nachricht für jedes Schlüssel/Wert-Paar",
        "strBuff": "<b>string</b> / <b>buffer</b>",
        "array": "<b>array</b>",
        "splitThe": "Split",
        "splitUsing": "Aufteilung",
        "splitLength": "feste Längen von",
        "stream": "Als Nachrichtenstrom behandeln (Streaming-Modus)",
        "addname": " Schlüssel kopieren zu"
    },
    "join": {
        "join": "join",
        "mode": {
            "mode": "Modus",
            "auto": "Automatisch",
            "merge": "Sequenzen zusammenführen",
            "reduce": "Sequenz reduzieren",
            "custom": "Manuell"
        },
        "combine": "Verbinde jede",
        "completeMessage": "vollständige Nachricht",
        "create": "und erstelle",
        "type": {
            "string": "ein String",
            "array": "ein Array",
            "buffer": "einen binären Buffer",
            "object": "ein Schlüssel/Wert-Objekt",
            "merged": "ein zusammengeführtes Objekt"
        },
        "using": "mit dem Wert von",
        "key": "als Schlüssel",
        "joinedUsing": "verbunden mit",
        "send": "Senden der Nachricht:",
        "afterCount": "Nach einer Anzahl von Nachrichtenteilen",
        "count": "Anzahl",
        "subsequent": "und bei jeder nachfolgenden Nachricht",
        "afterTimeout": "Bei Zeitablauf nach erster Nachricht von",
        "seconds": "Sekunden",
        "complete": "Nach Nachricht mit <code>msg.complete</code>-Eigenschaft",
        "tip": "Dieser Modus setzt voraus, dass dieser Node entweder mit einem split-Node kombiniert ist oder dass die empfangenen Nachrichten über eine ordnungsgemäß konfigurierte <code>msg.parts</code>-Eigenschaft verfügen.",
        "too-many": "Zu viele anstehende Nachrichten im join-Node",
        "merge": {
            "topics-label": "Zusammengeführte Topics",
            "topics": "Topics",
            "topic": "Topic",
            "on-change": "Sende Zusammenführungs-Nachricht bei Ankunft eines neuen Topics"
        },
        "reduce": {
            "exp": "Reduktions-Ausdruck",
            "exp-value": "Ausdruck",
            "init": "Anfangswert",
            "right": "In umgekehrter Reihenfolge auswerten (von letzten zu ersten)",
            "fixup": "Fix-up-Ausdruck"
        },
        "errors": {
            "invalid-expr": "Ungültiger JSONata-Ausdruck: __error__",
            "invalid-type": "Zusammenführung von __error__ zu buffer nicht möglich"
        }
    },
    "sort": {
        "sort": "sort",
        "target": "Sortierung",
        "seq": "Nachrichtensequenz",
        "key": "Schlüssel",
        "elem": "Elementwert",
        "order": "Reihenfolge",
        "ascending": "aufsteigend",
        "descending": "absteigend",
        "as-number": "als Zahlenwert",
        "invalid-exp": "Ungültiger JSONata-Ausdruck in sort-Node: __message__",
        "too-many": "Zu viele anstehende Nachrichten in sort-Node",
        "clear": "Anstehende Nachricht in sort-Node löschen"
    },
    "batch": {
        "batch": "batch",
        "mode": {
            "label": "Modus",
            "num-msgs": "Gruppierung anhand Nachrichtenanzahl",
            "interval": "Gruppierung anhand Zeitintervall",
            "concat": "Verknüpfung von Sequenzen"
        },
        "count": {
            "label": "Nachrichtenanzahl",
            "overlap": "Überlappung",
            "count": "Anzahl",
            "invalid": "Ungültige Anzahl und Überlappung"
        },
        "interval": {
            "label": "Intervall",
            "seconds": "Sekunden",
            "empty": "Leere Nachricht senden, wenn keine Nachricht eingeht"
        },
        "concat": {
            "topics-label": "Topics",
            "topic": "Topic"
        },
        "too-many": "Zu viele anstehende Nachrichten im batch-Node",
        "unexpected": "Unerwarteter Modus",
        "no-parts": "Keine parts-Eigenschaft in Nachricht"
    },
    "rbe": {
        "rbe": "filter",
        "label": {
            "func": "Modus",
            "init": "Sende Anfangswert",
            "start": "Startwert",
            "name": "Name",
            "septopics": "Modus für jedes msg.topic separat anwenden"
        },
        "placeholder":{
            "bandgap": "z.B. 10 oder 5%",
            "start": "Leer lassen, um erste empfangenen Daten zu nutzen"
        },
        "opts": {
            "rbe": "Blockieren bis Wertänderung",
            "rbei": "Blockieren bis Wertänderung (Anfangswert ignorieren)",
            "deadband": "Blockieren bis Wertänderung ist größer als",
            "deadbandEq": "Blockieren bis Wertänderung ist größer-gleich",
            "narrowband": "Blockieren wenn Wertänderung ist größer als",
            "narrowbandEq": "Blockieren wenn Wertänderung ist größer-gleich",
            "in": "verglichen mit letzten Eingangswert",
            "out": "verglichen mit letzten gültigen Ausgangswert"
        },
        "warn": {
            "nonumber": "Keine Zahl gefunden in den Nutzdaten (Payload)"
        }
    }
}
