{
    "common": {
        "label": {
            "payload": "Данные",
            "topic": "Тема",
            "name": "Имя",
            "username": "Имя польз.",
            "password": "Пароль",
            "property": "Свойство",
            "selectNodes": "Выберите узлы...",
            "expand": "Развернуть"
        },
        "status": {
            "connected": "подключен",
            "not-connected": "не подключен",
            "disconnected": "соединение разорвано",
            "connecting": "идет подключение",
            "error": "ошибка",
            "ok": "OK"
        },
        "notification": {
            "error": "<strong>Ошибка</strong>: __message__",
            "errors": {
                "not-deployed": "узел не развернут",
                "no-response": "нет ответа от сервера",
                "unexpected": "непредвиденная ошибка (__status__) __message__"
            }
        },
        "errors": {
            "nooverride": "Предупреждение: свойства msg больше не могут переопределять установленные свойства узла. Смотрите bit.ly/nr-override-msg-props"
        }
    },
    "inject": {
        "inject": "запустить",
        "repeat": "повторы = __repeat__",
        "crontab": "crontab = __crontab__",
        "stopped": "остановлено",
        "failed": "Не удалось запустить: __error__",
        "label": {
            "properties": "Свойства",
            "repeat": "Повторять",
            "flow": "контекст потока",
            "global": "глобальный контекст",
            "str": "строка",
            "num": "число",
            "bool": "логический тип",
            "json": "объект",
            "bin": "буфер",
            "date": "метка времени",
            "env": "переменная среды",
            "object": "объект",
            "string": "строка",
            "boolean": "логический тип",
            "number": "число",
            "Array": "массив",
            "invalid": "Неверный объект JSON"
        },
        "timestamp": "метка времени",
        "none": "нет",
        "interval": "с интервалом",
        "interval-time": "с интервалом в промежутке",
        "time": "в определенное время",
        "seconds": "сек",
        "minutes": "мин",
        "hours": "час",
        "between": "между",
        "previous": "предыдущее значение",
        "at": "в",
        "and": "и",
        "every": "каждые",
        "days": [
            "пн",
            "вт",
            "ср",
            "чт",
            "пт",
            "сб",
            "вс"
        ],
        "on": "по",
        "onstart": "Отправить через",
        "onceDelay": "сек, затем",
        "success": "Успешно отправлено: __label__",
        "errors": {
            "failed": "запуск не удался, смотрите подробности в журнале",
            "toolong": "Интервал слишком большой",
            "invalid-expr": "Неверное выражение JSONata: __error__"
        }
    },
    "catch": {
        "catch": "ловить: все",
        "catchNodes": "ловить: __number__",
        "catchUncaught": "ловить: непойманные",
        "label": {
            "source": "Ловить ошибки",
            "selectAll": "выбрать все",
            "uncaught": "Игнорировать ошибки, пойманные другими узлами Catch"
        },
        "scope": {
            "all": "всех узлов",
            "selected": "выбранных узлов"
        }
    },
    "status": {
        "status": "статус: все",
        "statusNodes": "статус: __number__",
        "label": {
            "source": "Получать статус",
            "sortByType": "сортировать по типу"
        },
        "scope": {
            "all": "всех узлов",
            "selected": "выбранных узлов"
        }
    },
    "complete": {
        "completeNodes": "завершение: __number__"
    },
    "debug": {
        "output": "Выводить",
        "status": "статус",
        "none": "Нет",
        "invalid-exp": "Неверное выражение JSONata: __error__",
        "msgprop": "свойство сообщения",
        "msgobj": "весь msg объект сообщения",
        "autostatus": "то, что выводит этот узел",
        "to": "В",
        "debtab": "вкладка отладки",
        "tabcon": "вкладка отладки и консоль",
        "toSidebar": "окно отладки",
        "toConsole": "системную консоль",
        "toStatus": "статус узла (32 символа)",
        "severity": "Уровень",
        "notification": {
            "activated": "Успешно активирован: __label__",
            "deactivated": "Успешно деактивирован: __label__"
        },
        "sidebar": {
            "label": "отладка",
            "name": "Отладочные сообщения",
            "filterAll": "все узлы",
            "filterSelected": "выбранные узлы",
            "filterCurrent": "текущий поток",
            "debugNodes": "Отладочные узлы",
            "clearLog": "Очистить журнал",
            "filterLog": "Фильтровать журнал",
            "openWindow": "Открыть в новом окне",
            "copyPath": "Копировать путь",
            "copyPayload": "Копировать значение",
            "pinPath": "Закрепить видимость"
        },
        "messageMenu": {
            "collapseAll": "Свернуть все пути",
            "clearPinned": "Очистить закреп. пути",
            "filterNode": "Фильтровать этот узел",
            "clearFilter": "Очистить фильтр"
        }
    },
    "link": {
        "linkIn": "связь (вход)",
        "linkOut": "связь (выход)"
    },
    "tls": {
        "tls": "Конфигурация TLS",
        "label": {
            "use-local-files": "Использовать ключ и сертификаты из локальных файлов",
            "upload": "Загрузить",
            "cert": "Сертификат",
            "key": "Закрытый ключ",
            "passphrase": "Пароль",
            "ca": "CA сертификат",
            "verify-server-cert":"Проверить сертификат сервера",
            "servername": "Имя сервера"
        },
        "placeholder": {
            "cert":"путь к сертификату (формат PEM)",
            "key":"путь к закрытому ключу (формат PEM)",
            "ca":"путь к сертификату CA (формат PEM)",
            "passphrase":"пароль закрытого ключа (необязательно)",
            "servername":"для использования с SNI"
        },
        "error": {
            "missing-file": "Файл сертификата/ключа не предоставлен"
        }
    },
    "exec": {
        "exec": "выполнить",
        "spawn": "выполнить в новом процессе",
        "label": {
            "command": "Команда",
            "append": "Добавить",
            "timeout": "Тайм-аут",
            "timeoutplace": "необяз",
            "return": "Вывод",
            "seconds": "сек",
            "stdout": "стандартный вывод",
            "stderr": "стандартный вывод ошибок",
            "retcode": "код возврата"
        },
        "placeholder": {
            "extraparams": "дополнительные параметры"
        },
        "opt": {
            "exec": "когда команда завершена - exec режим",
            "spawn": "пока команда работает - spawn режим"
        },
        "oldrc": "Использовать вывод в старом стиле (режим совместимости)"
    },
    "function": {
        "function": "",
        "label": {
            "function": "Функция",
            "initialize": "Настройка",
            "finalize": "Закрытие",
            "outputs": "Выходы",
            "timeout":"Время ожидания"
        },
        "text": {
            "initialize": "// Добавленный здесь код будет исполняться\n// однократно при развертывании узла.\n",
            "finalize": "// Добавленный здесь код будет исполняться при\n// остановке узла или повторном развертывании.\n"
        },
        "error": {
            "inputListener":"Невозможно добавить слушателя к событию 'input' в функции",
            "non-message-returned":"Функция пыталась отправить сообщение типа __type__"
        }
    },
    "template": {
        "template": "шаблон",
        "label": {
            "template": "Шаблон",
            "property": "Свойство",
            "format": "Подсветка синтаксиса",
            "syntax": "Формат",
            "output": "Вывести как",
            "mustache": "Mustache шаблон",
            "plain": "Простой текст",
            "json": "JSON",
            "yaml": "YAML",
            "none": "нет"
        },
        "templatevalue": "А вот и данные: {{payload}} !"
    },
    "delay": {
        "action": "Действие",
        "for": "На",
        "delaymsg": "Задержка каждого сообщения",
        "delayfixed": "Фиксированная задержка",
        "delayvarmsg": "Переопределять задержку с msg.delay",
        "randomdelay": "Случайная задержка",
        "limitrate": "Ограничение скорости",
        "limitall": "Все сообщения",
        "limittopic": "Для каждого msg.topic",
        "fairqueue": "Отправлять темы по очереди",
        "timedqueue": "Отправлять все темы",
        "milisecs": "мсек",
        "secs": "сек",
        "sec": "сек",
        "mins": "мин",
        "min": "мин",
        "hours": "час",
        "hour": "час",
        "days": "сут",
        "day": "сут",
        "between": "Между",
        "and": "и",
        "rate": "Скорость",
        "msgper": "сообщений в",
        "dropmsg": "без промежуточных сообщений",
        "label": {
            "delay": "задержка",
            "variable": "переменная",
            "limit": "ограничение",
            "limitTopic": "ограничение темы",
            "random": "случайный",
            "units" : {
                "second": {
                    "plural" : "сек",
                    "singular": "сек"
                },
                "minute": {
                    "plural" : "мин",
                    "singular": "мин"
                },
                "hour": {
                    "plural" : "час",
                    "singular": "час"
                },
                "day": {
                    "plural" : "сут",
                    "singular": "сут"
                }
            }
        },
        "error": {
            "buffer": "буфер превысил 1000 сообщений",
            "buffer1": "буфер превысил 10000 сообщений"
        }
    },
    "trigger": {
        "send": "Отправить",
        "then": "затем",
        "then-send": "затем отправить",
        "output": {
            "string": "строку",
            "number": "число",
            "existing": "существующий объект сообщения",
            "original": "оригинальный объект сообщения",
            "latest": "последний объект сообщения",
            "nothing": "ничего"
        },
        "wait-reset": "ждать сброс",
        "wait-for": "ждать",
        "wait-loop": "переотправлять его каждые",
        "for": "Обрабатывать",
        "bytopics": "каждый",
        "alltopics": "все сообщения",
        "duration": {
            "ms": "мсек",
            "s": "сек",
            "m": "мин",
            "h": "час"
        },
        "extend": " продлить при поступлении нового сообщения",
        "override": "заменить задержку через msg.delay",
        "second": " отправить второе сообщение на отдельный выход",
        "label": {
            "trigger": "триггер",
            "trigger-block": "триггер & блок",
            "trigger-loop": "переотправлять каждые",
            "reset": "Сбрасывать триггер, если:",
            "resetMessage":"установлен msg.reset",
            "resetPayload":"msg.payload равен",
            "resetprompt": "необязательно"
        }
    },
    "comment": {
        "comment": "комментарий"
    },
    "unknown": {
        "label": {
            "unknown": "неизвестный"
        },
        "tip": "<p>Тип этого узла неизвестен Вашей установке Node-RED.</p><p><i>Если Вы развернете узел в этом состоянии, его конфигурация будет сохранена, но поток не будет запущен, пока отсутствующий тип не будет установлен.</i></p><p>Дополнительную справку смотрите в информационной вкладке на боковой панели</p>"
    },
    "mqtt": {
        "label": {
            "broker": "Сервер",
            "example": "например, localhost",
            "output": "Выход",
            "qos": "QoS",
            "retain": "Хранить",
            "clientid": "ID клиента",
            "port": "Порт",
            "keepalive": "Keep-alive время (сек)",
            "cleansession": "Использовать чистую сессию",
            "use-tls": "TLS",
            "tls-config":"Конфигурация TLS",
            "verify-server-cert":"Проверить сертификат сервера",
            "compatmode": "Использовать устаревшую поддержку MQTT 3.1"
        },
        "sections-label":{
            "birth-message": "Сообщение отправляемое при подключении (birth сообщение)",
            "will-message":"Сообщение отправляемое при неожиданном отключении (will message)",
            "close-message":"Сообщение отправляемое перед отключением (close сообщение)"
        },
        "tabs-label": {
            "connection": "Соединение",
            "security": "Безопасность",
            "messages": "Сообщения"
        },
        "placeholder": {
            "clientid": "Оставьте пустым для автоматически сгенерированного",
            "clientid-nonclean":"Должен быть установлен для не чистых сессий",
            "will-topic": "Оставьте пустым, чтобы отключить will сообщение",
            "birth-topic": "Оставьте пустым, чтобы отключить birth сообщение",
            "close-topic": "Оставьте пустым, чтобы отключить close сообщение"
        },
        "state": {
            "connected": "Подключен к брокеру: __broker__",
            "disconnected": "Отключен от брокера: __broker__",
            "connect-failed": "Не удалось подключиться к брокеру: __broker__"
        },
        "retain": "Хранить",
        "output": {
            "buffer": "буфер",
            "string": "строка",
            "base64": "строка в кодировке Base64",
            "auto": "автоопределение (строка или буфер)",
            "auto-detect": "автоопределение (разобрать объект JSON, строка или буфер)",
            "json": "объект JSON"
        },
        "true": "да",
        "false": "нет",
        "tip": "Совет: Оставьте тему, qos или хранение пустыми, если Вы хотите устанавливать их через свойства msg.",
        "errors": {
            "not-defined": "тема не определена",
            "missing-config": "отсутствует конфигурация брокера",
            "invalid-topic": "Указана неверная тема",
            "nonclean-missingclientid": "ID клиента не установлен, используется чистая сессия",
            "invalid-json-string": "Неверная строка JSON",
            "invalid-json-parse": "Не удалось проанализировать строку JSON"
        }
    },
    "httpin": {
        "label": {
            "method": "Метод",
            "url": "URL",
            "doc": "Docs",
            "return": "Возврат",
            "upload": "Принимать загрузки файлов?",
            "status": "Код состояния",
            "headers": "Заголовки",
            "other": "другое",
            "paytoqs": {
                "ignore": "Игнорировать",
                "query": "Добавлять к параметрам строки запроса",
                "body": "Отправлять как тело запроса"
            },
            "utf8String": "Строка UTF8",
            "binaryBuffer": "двоичный буфер",
            "jsonObject": "объект JSON",
            "authType": "Тип",
            "bearerToken": "Токен"
        },
        "setby": "- устанавливается через msg.method -",
        "basicauth": "Использовать аутентификацию",
        "use-tls": "Включить безопасное (SSL/TLS) соединение",
        "tls-config":"Конфигурация TLS",
        "basic": "basic аутентификация",
        "digest": "digest аутентификация",
        "bearer": "bearer authentication",
        "use-proxy": "Использовать прокси",
        "persist": "Включить keep-alive соединение",
        "proxy-config": "Конфигурация прокси",
        "use-proxyauth": "Использовать прокси-аутентификацию",
        "noproxy-hosts": "Игнор. хосты",
        "utf8": "строка UTF-8",
        "binary": "двоичный буфер",
        "json": "объект JSON",
        "tip": {
            "in": "URL будет относительно ",
            "res": "Сообщения, отправляемые на этот узел <b>должны</b> отправляться с узла <i>http input</i>",
            "req": "Совет: Если анализ JSON не удается, полученная строка возвращается как есть."
        },
        "httpreq": "http запрос",
        "errors": {
            "not-created": "Невозможно создать узел http-in, когда httpNodeRoot установлено в false",
            "missing-path": "пропущен путь",
            "no-response": "Нет объекта ответа",
            "json-error": "Ошибка анализа JSON",
            "no-url": "URL не указан",
            "deprecated-call":"Устаревший вызов __method__",
            "invalid-transport":"запрошен не-http транспорт",
            "timeout-isnan": "Значение тайм-аута не является действительным числом, проигнорировано",
            "timeout-isnegative": "Значение тайм-аута отрицательно, проигнорировано",
            "invalid-payload": "Неверные данные"
        },
        "status": {
            "requesting": "запрос"
        }
    },
    "websocket": {
        "label": {
            "type": "Тип",
            "path": "Путь",
            "url": "URL",
            "subprotocol": "Подпротокол"
        },
        "listenon": "Слушать на ...",
        "connectto": "Присоединиться к ...",
        "sendrec": "Отправить/Получить",
        "payload": "msg.payload данные",
        "message": "весь msg объект сообщение",
        "tip": {
            "path1": "По умолчанию <code>payload</code> будет содержать данные, которые будут отправлены или получены из websocket. Слушатель может быть настроен на отправку или получение всего объекта сообщения в виде строки в формате JSON.",
            "path2": "Путь будет относительно <code>__path__</code>.",
            "url1": "URL должен использовать схему ws:&#47;&#47; или wss:&#47;&#47; и указывать на существующего слушателя websocket.",
            "url2": "По умолчанию <code>payload</code> будет содержать данные, которые будут отправлены или получены из websocket. Клиент может быть настроен на отправку или получение всего объекта сообщения в виде строки в формате JSON."
        },
        "status": {
            "connected": "подключен __count__",
            "connected_plural_2": "подключено __count__",
            "connected_plural_5": "подключено __count__"
        },
        "errors": {
            "connect-error": "Произошла ошибка в соединении ws: ",
            "send-error": "Произошла ошибка при отправке: ",
            "missing-conf": "Отсутствует конфигурация сервера",
            "duplicate-path": "Не может быть двух слушателей WebSocket по одному пути: __path__"
        }
    },
    "watch": {
        "watch": "наблюдение",
        "label": {
            "files": "Файл(ы)",
            "recursive": "Наблюдать за подкаталогами рекурсивно"
        },
        "placeholder": {
            "files": "Разделенный запятыми список файлов и/или каталогов"
        },
        "tip": "В Windows Вы должны использовать двойную обратную косую черту \\\\ в любых именах каталогов."
    },
    "tcpin": {
        "label": {
            "type": "Тип",
            "output": "Вывод",
            "port": "порт",
            "host": "к хосту",
            "payload": "данные",
            "delimited": "разделены с",
            "close-connection": "Закрывать соединение после отправки каждого сообщения?",
            "decode-base64": "Расшифровать сообщение Base64?",
            "server": "Сервер",
            "return": "Возврат",
            "ms": "мсек",
            "chars": "симв."
        },
        "type": {
            "listen": "Слушать",
            "connect": "Подключиться",
            "reply": "Ответить на TCP"
        },
        "output": {
            "stream": "поток",
            "single": "одиночный",
            "buffer": "буфер",
            "string": "строка",
            "base64": "строка Base64"
        },
        "return": {
            "timeout": "по истечении времени ожидания",
            "character": "когда получен символ",
            "number": "по получении N символов",
            "never": "никогда - держать соединение открытым",
            "immed": "немедленно - не ждать ответа"
        },
        "status": {
            "connecting": "подключение к __host__:__port__",
            "connected": "подключен к __host__:__port__",
            "listening-port": "прослушивание порта __port__",
            "stopped-listening": "прослушивание порта остановлено",
            "connection-from": "соединение от __host__:__port__",
            "connection-closed": "закрыто соединение от __host__:__port__",
            "connections": "__count__ соединение",
            "connections_plural_2": "__count__ соединения",
            "connections_plural_5": "__count__ соединений"
        },
        "errors": {
            "connection-lost": "потеряно соединение с __host__:__port__",
            "timeout": "сокет на порту __port__ закрыт из-за превышения времени ожидания",
            "cannot-listen": "невозможно прослушивать порт __port__, ошибка: __error__",
            "error": "ошибка: __error__",

            "socket-error": "ошибка сокета от __host__:__port__",
            "no-host": "Хост и/или порт не установлены",
            "connect-timeout": "превышено время ожидания подключения",
            "connect-fail": "подключение не удалось"
        }
    },
    "udp": {
        "label": {
            "listen": "Слушать",
            "onport": "на порте",
            "using": "используя",
            "output": "Выход",
            "group": "Группа",
            "interface": "Локал. IF",
            "send": "Отправлять",
            "toport": "на порт",
            "address": "Адрес",
            "decode-base64": "Декодировать данные кодированные в Base64?"
        },
        "placeholder": {
            "interface": "(необяз) локальный интерфейс или адрес для привязки",
            "interfaceprompt": "(необяз) локальный интерфейс или адрес для привязки",
            "address": "IP-адрес назначения"
        },
        "udpmsgs": "UDP сообщения",
        "mcmsgs": "многоадресные сообщения",
        "udpmsg": "UDP сообщение",
        "bcmsg": "широковещательное сообщение",
        "mcmsg": "многоадресное сообщение",
        "output": {
            "buffer": "буфер",
            "string": "строка",
            "base64": "строка Base64"
        },
        "bind": {
            "random": "привязать к случайному локальному порту",
            "local": "привязать к локальному порту",
            "target": "привязать к целевому порту"
        },
        "tip": {
            "in": "Совет: убедитесь, что Ваш брандмауэр разрешит вхождение данных.",
            "out": "Совет: оставьте адрес и порт пустыми, если вы хотите установить их, используя <code>msg.ip</code> и <code>msg.port</code>.",
            "port": "Уже используемые порты: "
        },
        "status": {
            "listener-at": "слушатель udp на __host__:__port__",
            "mc-group": "группа многоадресной рассылки udp __group__",
            "listener-stopped": "слушатель udp остановлен",
            "output-stopped": "выход udp остановлен",
            "mc-ready": "многоадресная рассылка udp готова: __iface__:__outport__ -> __host__:__port__",
            "bc-ready": "широковещательная рассылка udp готова: __outport__ -> __host__:__port__",
            "ready": "udp готов: __outport__ -> __host__:__port__",
            "ready-nolocal": "udp готов: __host__:__port__",
            "re-use": "сокет повторного использования udp: __outport__ -> __host__:__port__"
        },
        "errors": {
            "access-error": "Ошибка доступа UDP, Вам может потребоваться доступ с правами root для портов ниже 1024",
            "error": "ошибка: __error__",
            "bad-mcaddress": "Неверный адрес многоадресной рассылки",
            "interface": "Должен быть IP-адрес требуемого интерфейса",
            "ip-notset": "UDP: IP-адрес не установлен",
            "port-notset": "UDP: порт не установлен",
            "port-invalid": "UDP: номер порта недействителен",
            "alreadyused": "UDP: порт __port__ уже используется",
            "ifnotfound": "UDP: интерфейс __iface__ не найден"
        }
    },
    "switch": {
        "switch": "направить",
        "label": {
            "property": "Свойство",
            "rule": "правило",
            "repair": "воссоздать последовательность сообщений"
        },
        "previous": "предыдущее значение",
        "and": "и",
        "checkall": "проверка всех правил",
        "stopfirst": "остановка после первого совпадения",
        "ignorecase": "игнорировать регистр",
        "rules": {
            "btwn": "между",
            "cont": "содержит",
            "regex": "подходит под регул. выраж.",
            "true": "равно true",
            "false": "равно false",
            "null": "равно null",
            "nnull": "не равно null",
            "istype": "является типом",
            "empty": "пустое",
            "nempty": "не пустое",
            "head": "первые N",
            "tail": "последние N",
            "index": "индекс между",
            "exp": "выраж. JSONata",
            "else": "иначе",
            "hask": "имеет ключ"
        },
        "errors": {
            "invalid-expr": "Неверное выражение JSONata: __error__",
            "too-many": "слишком много ожидающих сообщений в узле switch"
        }
    },
    "change": {
        "label": {
            "rules": "Правила",
            "rule": "правило",
            "set": "установить __property__",
            "change": "изменить __property__",
            "delete": "удалить __property__",
            "move": "переместить __property__",
            "changeCount": "изменить: __count__ правило",
            "changeCount_plural_2": "изменить: __count__ правила",
            "changeCount_plural_5": "изменить: __count__ правил",
            "regex": "Использовать регул. выражение"
        },
        "action": {
            "set": "Установить",
            "change": "Изменить",
            "delete": "Удалить",
            "move": "Переместить",
            "to": "в",
            "search": "Искать",
            "replace": "Заменить на"
        },
        "errors": {
            "invalid-from": "Неверное свойство 'from': __error__",
            "invalid-json": "Неверное свойство JSON 'to'",
            "invalid-expr": "Неверное выражение JSONata: __error__",
            "no-override": "Невозможно установить свойство необъектного типа: __property__"
        }
    },
    "range": {
        "range": "Диапазон",
        "label": {
            "action": "Действие",
            "inputrange": "Сопоставить входной диапазон",
            "resultrange": "с целевым диапазоном",
            "from": "от",
            "to": "до",
            "roundresult": "Округлять результат до ближайшего целого числа?"
        },
        "placeholder": {
            "min": "напр. 0",
            "maxin": "напр. 99",
            "maxout": "напр. 255"
        },
        "scale": {
            "payload": "Масштабировать msg-свойство",
            "limit": "Масштабировать и ограничить целевым диапазоном",
            "wrap": "Масштабировать и обернуть в целевой диапазон"
        },
        "tip": "Совет: этот узел работает ТОЛЬКО с числами.",
        "errors": {
            "notnumber": "Не число"
        }
    },
    "csv": {
        "label": {
            "columns": "Столбцы",
            "separator": "Разделитель",
            "c2o": "Опции CSV -> Объект",
            "o2c": "Опции Объект -> CSV",
            "input": "Вход",
            "skip-s": "Пропускать первые",
            "skip-e": "строк(и)",
            "firstrow": "первый ряд содержит имена столбцов",
            "output": "Выход",
            "includerow": "включать ряд с именами столбцов",
            "newline": "Новая строка",
            "usestrings": "разбирать числовые значения",
            "include_empty_strings": "включать пустые строковые значения",
            "include_null_values": "включать null-значения"
        },
        "placeholder": {
            "columns": "имена столбцов через запятую"
        },
        "separator": {
            "comma": "запятая",
            "tab": "табуляция",
            "space": "пробел",
            "semicolon": "точка с запятой",
            "colon": "двоеточие",
            "hashtag": "хэштег",
            "other": "другой..."
        },
        "output": {
            "row": "сообщение для каждой строки",
            "array": "одно сообщение [массив]"
        },
        "newline": {
            "linux": "Linux (\\n)",
            "mac": "Mac (\\r)",
            "windows": "Windows (\\r\\n)"
        },
        "hdrout": {
            "none": "никогда не отправлять заголовки столбцов",
            "all": "всегда отправлять заголовки столбцов",
            "once": "отправлять заголовки один раз, до msg.reset"
        },
        "errors": {
            "csv_js": "Этот узел обрабатывает только CSV-строки или объекты js.",
            "obj_csv": "Не указан шаблон столбцов для Объект -> CSV.",
            "bad_csv": "Неверно сформированный CSV-файл - возможно, выход поврежден."
        }
    },
    "html": {
        "label": {
            "select": "Селектор",
            "output": "Выход",
            "in": "в"
        },
        "output": {
            "html": "html-контент элементов",
            "text": "только текстовый контент элементов",
            "attr": "объект любых атрибутов элементов"
        },
        "format": {
            "single": "одним сообщением [массив]",
            "multi": "по сообщению для каждого элемента"
        }
    },
    "json": {
        "errors": {
            "dropped-object": "Данные не-объектного типа проигнорированы",
            "dropped": "Данные неподдерживаемого типа проигнорированы",
            "dropped-error": "Не удалось преобразовать данные",
            "schema-error": "Ошибка схемы JSON",
            "schema-error-compile": "Ошибка схемы JSON: не удалось скомпилировать схему"
        },
        "label": {
            "o2j": "Опции Объект -> JSON",
            "pretty": "Форматировать строку JSON",
            "action": "Действие",
            "property": "Свойство",
            "actions": {
                "toggle": "Преобразовывать в любую сторону",
                "str":"Всегда преобразовывать в строку JSON",
                "obj":"Всегда преобразовывать в объект JavaScript"
            }
        }
    },
    "yaml": {
        "errors": {
            "dropped-object": "Данные не-объектного типа проигнорированы",
            "dropped": "Данные неподдерживаемого типа проигнорированы",
            "dropped-error": "Не удалось преобразовать данные"
        }
    },
    "xml": {
        "label": {
            "represent": "Имя свойства для атрибутов XML-тега",
            "prefix": "Имя свойства для текстового содержимого тега",
            "advanced": "Расширенные опции",
            "x2o": "Опции XML -> Объект"
        },
        "errors": {
            "xml_js": "Этот узел обрабатывает только строки XML или объекты JS."
        }
    },
    "file": {
        "label": {
            "filename": "Имя файла",
            "action": "Действие",
            "addnewline": "Добавлять новую строку (\\n) к данным?",
            "createdir": "Создать каталог, если он не существует?",
            "outputas": "Выход",
            "breakchunks": "Разбить файл на части",
            "breaklines": "Разбить на строки",
            "sendError": "Отправлять сообщение при ошибке (устаревший режим)",
            "encoding": "Кодировка",
            "deletelabel": "удалить __file__",
            "utf8String": "строка UTF8",
            "binaryBuffer": "двоичный буфер"
        },
        "action": {
            "append": "добавить в файл",
            "overwrite": "перезаписать файл",
            "delete": "удалить файл"
        },
        "output": {
            "utf8": "одна ut8-строка",
            "buffer": "один объект буфера",
            "lines": "сообщение для каждой строчки",
            "stream": "поток буферов"
        },
        "status": {
            "wrotefile": "записано в файл: __file__",
            "deletedfile": "удален файл: __file__",
            "appendedfile": "добавлено в файл: __file__"
        },
        "encoding": {
            "none": "по умолчанию",
            "native": "Нативная",
            "unicode": "Юникод",
            "japanese": "Японская",
            "chinese": "Китайская",
            "korean": "Корейская",
            "taiwan": "Тайвань/Гонконг",
            "windows": "Кодовые страницы Windows",
            "iso": "Кодовые страницы ISO",
            "ibm": "Кодовые страницы IBM",
            "mac": "Кодовые страницы Mac",
            "koi8": "Кодовые страницы KOI8",
            "misc": "Разные"
        },
        "errors": {
            "nofilename": "Не указано имя файла",
            "invaliddelete": "Предупреждение: неверное удаление. Пожалуйста, используйте конкретную опцию удаления в диалоге конфигурации.",
            "deletefail": "не удалось удалить файл: __error__",
            "writefail": "не удалось записать в файл: __error__",
            "appendfail": "не удалось добавить в файл: __error__",
            "createfail": "не удалось создать файл: __error__"
        },
        "tip": "Подсказка: имя файла должно быть абсолютным путем, иначе он будет относительно рабочего каталога процесса Node-RED."
    },
    "split": {
        "split": "разделить",
        "intro":"Разделить <code>msg.payload</code> в зависимости от типа:",
        "object":"<b>Объект</b>",
        "objectSend":"Отправлять сообщение для каждой пары ключ/значение",
        "strBuff":"<b>Строка</b> / <b>Буфер</b>",
        "array":"<b>Массив</b>",
        "splitUsing":"С помощью",
        "splitLength":"Фикс. длина",
        "stream":"Обрабатывать как поток сообщений",
        "addname":" Копировать ключ в "
    },
    "join": {
        "join": "соединить",
        "mode": {
            "mode": "Режим",
            "auto": "автоматический",
            "merge": "объединение последовательности",
            "reduce": "агрегация последовательности",
            "custom": "ручной"
        },
        "combine": "Объединить каждый",
        "completeMessage": "полное сообщение",
        "create": "чтобы создать",
        "type": {
            "string": "строку",
            "array": "массив",
            "buffer": "буфер",
            "object": "объект ключей/значений",
            "merged": "объединенный объект"
        },
        "using": "используя значение",
        "key": "как ключ",
        "joinedUsing": "соединяя с помощью",
        "send": "Отправить сообщение:",
        "afterCount": "после ряда частей сообщения",
        "count": "кол-во",
        "subsequent": "и каждое последующее сообщение.",
        "afterTimeout": "по истечении времени с 1го сообщения",
        "seconds": "сек",
        "complete": "после сообщения с установленным свойством <code>msg.complete</code>",
        "tip": "В этом режиме предполагается, что этот узел либо связан с узлом <i>split</i>, либо полученные сообщения будут иметь правильно настроенное свойство <code>msg.parts</code>.",
        "too-many": "слишком много ожидающих сообщений в узле join",
        "merge": {
            "topics-label": "Объединенные темы",
            "topics": "темы",
            "topic": "тема",
            "on-change": "Отправлять объединенное сообщение по прибытии новой темы"
        },
        "reduce": {
            "exp": "Агрегирующее выражение",
            "exp-value": "выражение",
            "init": "Начальное значение",
            "right": "Выполнять в обратном порядке (от последнего к первому)",
            "fixup": "Исправляющее выражение"
        },
        "errors": {
            "invalid-expr": "Неверное выражение JSONata: __error__",
            "invalid-type": "Невозможно присоединить __error__ к буферу"
        }
    },
    "sort" : {
        "sort": "сортировать",
        "target" : "Сортировать",
        "seq" : "последовательность сообщений",
        "key" : "Ключ",
        "elem" : "значение элемента",
        "order" : "Порядок",
        "ascending" : "восходящий",
        "descending" : "нисходящий",
        "as-number" : "как число",
        "invalid-exp" : "Неверное выражение JSONata в узле sort: __message__",
        "too-many" : "Слишком много ожидающих сообщений в узле sort",
        "clear" : "очистить ожидающее сообщение в узле sort"
    },
    "batch" : {
        "batch": "группировать",
        "mode": {
            "label" : "Режим",
            "num-msgs" : "Группировать по количеству сообщений",
            "interval" : "Группировать по интервалу времени",
            "concat" : "Объединять последовательности"
        },
        "count": {
            "label" : "Количество сообщений",
            "overlap" : "Совпадения",
            "count" : "кол-во",
            "invalid" : "Неверные количество и совпадения"
        },
        "interval": {
            "label" : "Интервал",
            "seconds" : "сек",
            "empty" : "отправить пустое сообщение, когда сообщение не приходит"
        },
        "concat": {
            "topics-label": "Темы",
            "topic" : "тема"
        },
        "too-many" : "Слишком много ожидающих сообщений в узле batch",
        "unexpected" : "неожиданный режим",
        "no-parts" : "в сообщении нет свойства parts"
    }
}
