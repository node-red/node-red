{
    "common": {
        "label": {
            "payload": "Carga",
            "topic": "Tema",
            "name": "Nombre",
            "username": "Usuario",
            "password": "Contraseña",
            "property": "Propiedad",
            "selectNodes": "Selecciona nodos...",
            "expand": "Expandir"
        },
        "status": {
            "connected": "conectado",
            "not-connected": "no conectado",
            "disconnected": "desconectado",
            "connecting": "conectando",
            "error": "error",
            "ok": "Vale"
        },
        "notification": {
            "error": "<strong>Error</strong>: __message__",
            "errors": {
                "not-deployed": "nodo no instanciado",
                "no-response": "sin respuesta del servidor",
                "unexpected": "error inesperado (__status__) __message__"
            }
        },
        "errors": {
            "nooverride": "Advertencia: las propiedades de mensaje ya no pueden anular las propiedades del nodo establecido. Consulta bit.ly/nr-override-msg-props"
        }
    },
    "inject": {
        "inject": "inyectar",
        "injectNow": "inyectar ahora",
        "repeat": "repetir = __repeat__",
        "crontab": "crontab = __crontab__",
        "stopped": "detenido",
        "failed": "Inyección fallida: __error__",
        "label": {
            "properties": "Propiedades",
            "repeat": "Repetir",
            "flow": "contexto de flujo ",
            "global": "contexto global",
            "str": "texto",
            "num": "número",
            "bool": "booleano",
            "json": "objeto",
            "bin": "buffer",
            "date": "marca tiempo",
            "env": "variable entorno",
            "object": "objeto",
            "string": "texto",
            "boolean": "booleano",
            "number": "número",
            "Array": "matriz",
            "invalid": "Objeto JSON no válido"
        },
        "timestamp": "marca tiempo",
        "none": "ninguno",
        "interval": "intervalo",
        "interval-time": "intervalo entre tiempos",
        "time": "en un momento determinado",
        "seconds": "segundos",
        "minutes": "minutos",
        "hours": "horas",
        "between": "entre",
        "previous": "valor anterior",
        "at": "en",
        "and": "y",
        "every": "cada",
        "days": [
            "Lunes",
            "Martes",
            "Miércoles",
            "Jueves",
            "Viernes",
            "Sábado",
            "Domingo"
        ],
        "on": "en",
        "onstart": "Inyectar una vez después de",
        "onceDelay": "segundos, entonces",
        "success": "Inyectado con éxito: __label__",
        "errors": {
            "failed": "inyección fallida, ver registro para más detalles",
            "toolong": "Intervalo demasiado grande",
            "invalid-expr": "Expresión JSONata no válida: __error__",
            "invalid-jsonata": "__prop__: expresión de propiedad no válida: __error__",
            "invalid-prop": "__prop__: expresión de propiedad no válida: __error__",
            "invalid-json": "__prop__: datos JSON no válidos: __error__",
            "invalid-repeat": "Valor de repetición no válido"
        }
    },
    "catch": {
        "catch": "captura: todos",
        "catchGroup": "captura: grupo",
        "catchNodes": "captura: __number__",
        "catchUncaught": "captura: no capturado",
        "label": {
            "source": "Capturar errores de",
            "selectAll": "selecciona todos",
            "uncaught": "Ignorar los errores gestionados por otros nodos capturados"
        },
        "scope": {
            "all": "todos los nodos",
            "group": "en el mismo grupo",
            "selected": "nodos seleccionados"
        }
    },
    "status": {
        "status": "estado: todo",
        "statusGroup": "estado: grupo",
        "statusNodes": "estado: __number__",
        "label": {
            "source": "Informar estado de",
            "sortByType": "ordenar por tipo"
        },
        "scope": {
            "all": "todos los nodos",
            "group": "en el mismo grupo",
            "selected": "nodos seleccionados"
        }
    },
    "complete": {
        "completeNodes": "completado: __number__",
        "errors": {
            "scopeUndefined": "ámbito indefinido"
        }
    },
    "debug": {
        "output": "Salida",
        "status": "estado",
        "none": "Ninguno",
        "invalid-exp": "Expresión JSONata no válida: __error__",
        "msgprop": "propiedad del mensaje",
        "msgobj": "mensaje completo",
        "autostatus": "igual que la salida de depuración",
        "messageCount": "recuento de mensajes",
        "to": "A",
        "debtab": "pestaña depuración",
        "tabcon": "pestaña depuración y consola",
        "toSidebar": "ventana depuración",
        "toConsole": "consola sistema",
        "toStatus": "estado nodo (32 caracteres)",
        "severity": "Nivel",
        "node": "nodo",
        "notification": {
            "activated": "Activado correctamente: __label__",
            "deactivated": "desactivado correctamente: __label__"
        },
        "sidebar": {
            "label": "depuración",
            "name": "Mensajes de depuración",
            "filterAll": "todos los nodos",
            "filterSelected": "nodos seleccionados",
            "filterCurrent": "flujo actual",
            "debugNodes": "Nodos depuración",
            "clearLog": "Vaciar mensajes",
            "clearFilteredLog": "Vaciar mensajes filtrados",
            "filterLog": "Filtrar mensajes",
            "openWindow": "Abrir en nueva ventana",
            "copyPath": "Copiar ruta",
            "copyPayload": "Copiar valor",
            "pinPath": "Fijos abierto",
            "selectAll": "seleccionar todo",
            "selectNone": "seleccionar ninguno",
            "all": "todo",
            "filtered": "filtrado"
        },
        "messageMenu": {
            "collapseAll": "Colapsar todas las rutas",
            "clearPinned": "Colapsar las rutas fijadas",
            "filterNode": "Filtrar este nodo",
            "clearFilter": "Limpiar filtro"
        }
    },
    "link": {
        "linkIn": "enlace de entrada",
        "linkOut": "enlace de salida",
        "linkCall": "llamada a enlace",
        "linkOutReturn": "resultado enlace",
        "outMode": "Modo",
        "sendToAll": "Enviar a todos los nodos de enlace conectados",
        "returnToCaller": "Volver al nodo de enlace de llamada",
        "timeout": "tiempo de espera",
        "linkCallType": "Tipo Enlace",
        "staticLinkCall": "Destino fijo",
        "dynamicLinkCall": "Destino Dinámico (msg.target)",
        "dynamicLinkLabel": "Dinámico",
        "errors": {
            "missingReturn": "Falta información del nodo de retorno",
            "linkUndefined": "enlace indefinido"
        }
    },
    "tls": {
        "tls": "Configuración TLS",
        "label": {
            "use-local-files": "Utilizar claves y certificados de archivos locales",
            "upload": "Cargar",
            "cert": "Certificado",
            "key": "Clave Privada",
            "passphrase": "Frase de contraseña",
            "ca": "Certificado CA",
            "verify-server-cert": "Verificar el certificado del servidor",
            "servername": "Nombre del servidor",
            "alpnprotocol": "Protocolo ALPN"
        },
        "placeholder": {
            "cert": "ruta a certificado (formato PEM)",
            "key": "ruta a clave privada (formato PEM)",
            "ca": "ruta a certificado CA (formato PEM)",
            "passphrase": "frase de contraseña de clave privada (opcional)",
            "servername": "para uso con SNI",
            "alpnprotocol": "para uso con ALPN"
        },
        "error": {
            "missing-file": "No se ha indicado ningún archivo de certificado/clave",
            "invalid-cert": "Certificado no especificado",
            "invalid-key": "Clave privada no especificada"
        }
    },
    "exec": {
        "exec": "ejecutar",
        "spawn": "generar",
        "label": {
            "command": "Comando",
            "append": "Adjuntar",
            "timeout": "Tiempo Espera",
            "timeoutplace": "opcional",
            "return": "Salida",
            "seconds": "segundos",
            "stdout": "stdout",
            "stderr": "stderr",
            "retcode": "código resultado",
            "winHide": "Esconder terminal"
        },
        "placeholder": {
            "extraparams": "parámetros de entrada adicionales"
        },
        "opt": {
            "exec": "cuando se completa el comando - modo ejecución",
            "spawn": "mientras se ejecuta el comando - modo de generación"
        },
        "oldrc": "Usar salida de estilo antiguo (modo de compatibilidad)"
    },
    "function": {
        "function": "",
        "label": {
            "setup": "Configuración",
            "function": "En mensaje",
            "initialize": "Al inicio",
            "finalize": "Al final",
            "outputs": "Salidas",
            "modules": "Módulos",
            "timeout": "Tiempo Espera"
        },
        "text": {
            "initialize": "// El código añadido aquí se ejecutará una vez\n// cuando el nodo es iniciado.\n",
            "finalize": "// El código añadido aquí se ejecutará cuando el nodo\n// se detenga o se vuelva a instanciar.\n"
        },
        "require": {
            "var": "variable",
            "module": "módulo",
            "moduleName": "Nombre módulo",
            "importAs": "Importar como"
        },
        "error": {
            "externalModuleNotAllowed": "El nodo de función no puede cargar módulos externos",
            "moduleNotAllowed": "Módulo __module__ no permitido",
            "externalModuleLoadError": "El nodo de función no pudo cargar módulos externos",
            "moduleLoadError": "No se pudo cargar el módulo __module__: __error__",
            "moduleNameError": "Nombre de variable de módulo no válido: __name__",
            "moduleNameReserved": "Nombre de variable reservada: __name__",
            "inputListener": "No se puede agregar un oyente al evento 'entrada' dentro de la función",
            "non-message-returned": "La función intentó enviar un mensaje de tipo __type__",
            "invalid-js": "Error en el código JavaScript",
            "missing-module": "Falta el módulo __module__"
        }
    },
    "template": {
        "template": "plantilla",
        "label": {
            "template": "Plantilla",
            "property": "Propiedad",
            "format": "Resaltado de sintaxis",
            "syntax": "Formato",
            "output": "Salida como",
            "mustache": "Mustache template",
            "plain": "Texto normal",
            "json": "JSON",
            "yaml": "YAML",
            "none": "ninguno"
        },
        "templatevalue": "Esta es la carga: {{payload}} !"
    },
    "delay": {
        "action": "Acción",
        "for": "Para",
        "delaymsg": "Retrasar cada mensaje",
        "delayfixed": "Retraso fijo",
        "delayvarmsg": "Utilizar el retraso en msg.delay",
        "randomdelay": "Retraso aleatorio",
        "limitrate": "Límite frequencia",
        "limitall": "Todos los mensajes",
        "limittopic": "Para cada msg.topic",
        "fairqueue": "Envía cada tema por turno",
        "timedqueue": "Enviar todos los temas",
        "milisecs": "Millisegundos",
        "secs": "Segundos",
        "sec": "Segundo",
        "mins": "Minutos",
        "min": "Minuto",
        "hours": "Horas",
        "hour": "Hora",
        "days": "Días",
        "day": "Día",
        "between": "Entre",
        "and": "y",
        "rate": "Frecuencia",
        "msgper": "msg(s) por",
        "queuemsg": "Encolar mensajes intermedios",
        "dropmsg": "Eliminar mensajes intermedios",
        "sendmsg": "Enviar mensajes intermedios a la segunda salida.",
        "allowrate": "permitir que msg.rate (en ms) indique la frecuencia",
        "label": {
            "delay": "retraso",
            "variable": "variable",
            "limit": "límite",
            "limitTopic": "limitar tema",
            "random": "aleatorio",
            "rate": "frecuencia",
            "random-first": "primer valor aleatorio",
            "random-last": "último valor aleatorio",
            "units": {
                "second": {
                    "plural": "Segundos",
                    "singular": "Segundo"
                },
                "minute": {
                    "plural": "Minutos",
                    "singular": "Minuto"
                },
                "hour": {
                    "plural": "Horas",
                    "singular": "Hora"
                },
                "day": {
                    "plural": "Días",
                    "singular": "Día"
                }
            }
        },
        "errors": {
            "too-many": "demasiados mensajes pendientes en el nodo de retraso",
            "invalid-timeout": "Valor de retraso no válido",
            "invalid-rate": "Valor de frecuencia no válido",
            "invalid-rate-unit": "Unidad de frecuencia no válido",
            "invalid-random-first": "Primer valor aleatorio no válido",
            "invalid-random-last": "Ultimo valor aleatorio no válido"
        }
    },
    "trigger": {
        "send": "Enviar",
        "then": "entonces",
        "then-send": "entonces envía",
        "output": {
            "string": "el texto",
            "number": "el número",
            "existing": "el objeto de mensaje existente",
            "original": "el objeto de mensaje original",
            "latest": "el último objeto de mensaje",
            "nothing": "nada"
        },
        "wait-reset": "espera a ser reiniciado",
        "wait-for": "espera a",
        "wait-loop": "reenviarlo cada",
        "for": "Manejando",
        "bytopics": "cada",
        "alltopics": "todos los mensajes",
        "duration": {
            "ms": "Millisegundos",
            "s": "Segundos",
            "m": "Minutos",
            "h": "Horas"
        },
        "extend": " extender el retraso si llega un nuevo mensaje",
        "override": "indicar el retraso con msg.delay",
        "second": " enviar el segundo mensaje a una salida separada",
        "label": {
            "trigger": "iniciar",
            "trigger-block": "iniciar y bloquear",
            "trigger-loop": "reenviar cada",
            "reset": "Reinicia el disparador si:",
            "resetMessage": "msg.reset es verdadero",
            "resetPayload": "msg.payload es igual a",
            "resetprompt": "opcional",
            "duration": "duración",
            "topic": "tema"
        }
    },
    "comment": {
        "comment": "comentario"
    },
    "unknown": {
        "label": {
            "unknown": "desconocido"
        },
        "tip": "<p>Este nodo es de un tipo desconocido para tu instalación de Node-RED.</p><p><i>Si instancia con el nodo en este estado, tu configuración se conservará, pero el flujo no comenzará hasta el tipo que falta esté instalado.</i></p><p>Consulta la barra lateral de información para obtener más ayuda</p>"
    },
    "mqtt": {
        "label": {
            "broker": "Servidor",
            "example": "e.g. localhost",
            "output": "Salida",
            "qos": "CdS",
            "retain": "Retener",
            "clientid": "ID Cliente",
            "port": "Puerto",
            "keepalive": "Mantener activo",
            "cleansession": "Usar sesión limpia",
            "autoUnsubscribe": "Darse de baja automáticamente al desconectarse",
            "cleanstart": "Usar inicio limpio",
            "use-tls": "Utilizar TLS",
            "tls-config": "Configuración TLS",
            "verify-server-cert": "Verificar el certificado del servidor",
            "compatmode": "Utiliza el soporte compatible de MQTT 3.1",
            "userProperties": "Propiedades de usuario",
            "subscriptionIdentifier": "ID Subscripción",
            "flags": "Indicadores",
            "nl": "No recibir mensajes publicados por este cliente",
            "rap": "Mantener retención de publicación original",
            "rh": "Manejo de mensajes retenidos",
            "rh0": "Enviar mensajes retenidos",
            "rh1": "Enviar solo para nuevas suscripciones",
            "rh2": "No enviar",
            "responseTopic": "Tema de respuesta",
            "contentType": "Tipo de contenido",
            "correlationData": "Datos de correlación",
            "expiry": "Caducidad (s)",
            "sessionExpiry": "Caducidad de la sesión (s)",
            "topicAlias": "Alias",
            "payloadFormatIndicator": "Formato",
            "payloadFormatIndicatorFalse": "bytes no especificados (predeterminado)",
            "payloadFormatIndicatorTrue": "Carga codificada en UTF-8",
            "protocolVersion": "Protocolo",
            "protocolVersion3": "MQTT V3.1 (legacy)",
            "protocolVersion4": "MQTT V3.1.1",
            "protocolVersion5": "MQTT V5",
            "topicAliasMaximum": "Máximo alias",
            "maximumPacketSize": "Tamaño máximo de paquete",
            "receiveMaximum": "Máximo recepción",
            "session": "Sesión",
            "delay": "Retraso",
            "action": "Acción",
            "staticTopic": "Suscríbete a un solo tema",
            "dynamicTopic": "Suscripción dinámica",
            "auto-connect": "Conectar automáticamente",
            "auto-mode-depreciated": "Esta opción está descontinuada. Utiliza el nuevo modo de detección automática.",
            "none": "ninguno",
            "other": "otro"
        },
        "sections-label": {
            "birth-message": "Mensaje enviado al conectarse (mensaje de inicio)",
            "will-message": "Mensaje enviado ante una desconexión inesperada (mensaje de voluntad)",
            "close-message": "Mensaje enviado antes de desconectar (mensaje de cierre)"
        },
        "tabs-label": {
            "connection": "Conexión",
            "security": "Seguridad",
            "messages": "Mensajes"
        },
        "placeholder": {
            "clientid": "Dejar en blanco para auto generado",
            "clientid-nonclean": "Debe configurarse para sesiones no limpias",
            "will-topic": "Dejar en blanco para desactivar el mensaje de voluntad",
            "birth-topic": "Déjelo en blanco para desactivar el mensaje de inicio.",
            "close-topic": "Déjelo en blanco para desactivar el mensaje de cierre."
        },
        "state": {
            "connected": "Conectado al servidor: __broker__",
            "disconnected": "Desconectado del servidor: __broker__",
            "connect-failed": "Fallo en la conexión al servidor: __broker__",
            "broker-disconnected": "Servidor __broker__ desconectado del cliente: __reasonCode__ __reasonString__"
        },
        "retain": "Retener",
        "output": {
            "buffer": "un Buffer",
            "string": "un Texto",
            "base64": "un texto codificado Base64",
            "auto": "auto-detectar (texto o buffer)",
            "auto-detect": "auto-detectar (objeto JSON, texto o buffer)",
            "json": "un objeto JSON"
        },
        "true": "verdadero",
        "false": "falso",
        "tip": "Consejo: Deja el tema, CdS o manténgalo en blanco si quieres configurarlos a través de las propiedades del mensaje.",
        "errors": {
            "not-defined": "tema no definido",
            "missing-config": "falta configuración del servidor",
            "invalid-topic": "Tema especificado no válido",
            "nonclean-missingclientid": "No se ha establecido ningún ID de cliente, se utiliza una sesión limpia",
            "invalid-json-string": "Cadena JSON no válida",
            "invalid-json-parse": "No se pudo analizar la cadena JSON",
            "invalid-action-action": "Acción no válida especificada",
            "invalid-action-alreadyconnected": "Desconectar del servidor antes de conectar",
            "invalid-action-badsubscription": "msg.topic falta o no es válido",
            "invalid-client-id": "Falta ID de cliente"
        }
    },
    "httpin": {
        "label": {
            "method": "Método",
            "url": "URL",
            "doc": "Docs",
            "return": "Return",
            "upload": "Accept file uploads?",
            "status": "Status code",
            "headers": "Headers",
            "other": "otro",
            "paytoqs": {
                "ignore": "Ignore",
                "query": "Append to query-string parameters",
                "body": "Send as request body"
            },
            "utf8String": "texto UTF8",
            "binaryBuffer": "buffer binario",
            "jsonObject": "objeto JSON",
            "authType": "Tipo",
            "bearerToken": "Token"
        },
        "setby": "- set by msg.method -",
        "basicauth": "Use authentication",
        "use-tls": "Enable secure (SSL/TLS) connection",
        "tls-config": "TLS Configuration",
        "basic": "basic authentication",
        "digest": "digest authentication",
        "bearer": "bearer authentication",
        "use-proxy": "Use proxy",
        "persist": "Enable connection keep-alive",
        "proxy-config": "Proxy Configuration",
        "use-proxyauth": "Use proxy authentication",
        "noproxy-hosts": "Ignore hosts",
        "senderr": "Only send non-2xx responses to Catch node",
        "utf8": "a UTF-8 string",
        "binary": "a binary buffer",
        "json": "a parsed JSON object",
        "tip": {
            "in": "The url will be relative to ",
            "res": "The messages sent to this node <b>must</b> originate from an <i>http input</i> node",
            "req": "Tip: If the JSON parse fails the fetched string is returned as-is."
        },
        "httpreq": "http request",
        "errors": {
            "not-created": "Cannot create http-in node when httpNodeRoot set to false",
            "missing-path": "missing path",
            "no-response": "No response object",
            "json-error": "JSON parse error",
            "no-url": "No url specified",
            "deprecated-call": "Deprecated call to __method__",
            "invalid-transport": "non-http transport requested",
            "timeout-isnan": "Timeout value is not a valid number, ignoring",
            "timeout-isnegative": "Timeout value is negative, ignoring",
            "invalid-payload": "Invalid payload",
            "invalid-url": "Invalid url"
        },
        "status": {
            "requesting": "requesting"
        },
        "insecureHTTPParser": "Disable strict HTTP parsing"
    },
    "websocket": {
        "label": {
            "type": "Tipo",
            "path": "Ruta",
            "url": "URL",
            "subprotocol": "Subprotocolo"
        },
        "listenon": "Listen on",
        "connectto": "Connect to",
        "sendrec": "Send/Receive",
        "payload": "payload",
        "message": "entire message",
        "sendheartbeat": "Send heartbeat",
        "tip": {
            "path1": "By default, <code>payload</code> will contain the data to be sent over, or received from a websocket. The listener can be configured to send or receive the entire message object as a JSON formatted string.",
            "path2": "This path will be relative to <code>__path__</code>.",
            "url1": "URL should use ws:&#47;&#47; or wss:&#47;&#47; scheme and point to an existing websocket listener.",
            "url2": "By default, <code>payload</code> will contain the data to be sent over, or received from a websocket. The client can be configured to send or receive the entire message object as a JSON formatted string."
        },
        "status": {
            "connected": "connected __count__",
            "connected_plural": "connected __count__"
        },
        "errors": {
            "connect-error": "An error occurred on the ws connection: ",
            "send-error": "An error occurred while sending: ",
            "missing-conf": "Missing server configuration",
            "duplicate-path": "Cannot have two WebSocket listeners on the same path: __path__",
            "missing-server": "Missing server configuration",
            "missing-client": "Missing client configuration"
        }
    },
    "watch": {
        "watch": "watch",
        "label": {
            "files": "File(s)",
            "recursive": "Watch sub-directories recursively"
        },
        "placeholder": {
            "files": "Comma-separated list of files and/or directories"
        },
        "tip": "On Windows you must use double back-slashes \\\\ in any directory names."
    },
    "tcpin": {
        "label": {
            "type": "Tipo",
            "output": "Salida",
            "port": "puerto",
            "host": "en servidor",
            "payload": "carga(s)",
            "delimited": "delimitado por",
            "close-connection": "¿Cerrar la conexión después de enviar cada mensaje?",
            "decode-base64": "¿Decodificar mensaje Base64?",
            "server": "Servidor",
            "return": "Devolver",
            "ms": "ms",
            "chars": "caracteres",
            "close": "Cerrar",
            "optional": "(opcional)",
            "reattach": "volver a adjuntar delimitador"
        },
        "type": {
            "listen": "Escuchar",
            "connect": "Conectar a",
            "reply": "Responder a TCP"
        },
        "output": {
            "stream": "corriente de",
            "single": "único",
            "buffer": "Buffer",
            "string": "Cadena",
            "base64": "Cadena Base64"
        },
        "return": {
            "timeout": "después de un tiempo de espera fijo de",
            "character": "cuando el carácter recibido es",
            "number": "después de un número fijo de caracteres",
            "never": "nunca - mantener la conexión abierta",
            "immed": "inmediatamente - no esperar respuesta"
        },
        "status": {
            "connecting": "conectando a __host__:__port__",
            "connected": "conectado a __host__:__port__",
            "listening-port": "escuchando en el puerto __port__",
            "stopped-listening": "dejó de escuchar en el puerto",
            "connection-from": "conexión desde __host__:__port__",
            "connection-closed": "conexión cerrada desde __host__:__port__",
            "connections": "__count__ conexión",
            "connections_plural": "__count__ conexiones"
        },
        "errors": {
            "connection-lost": "conexión perdida a __host__:__port__",
            "timeout": "puerto de socket __port__ cerrado por tiempo de espera",
            "cannot-listen": "incapaz de escuchar en el puerto __port__, error: __error__",
            "error": "error: __error__",
            "socket-error": "error de socket desde __host__:__port__",
            "no-host": "Servidor y/o puerto no configurado",
            "connect-timeout": "tiempo de espera de conexión",
            "connect-fail": "conexión fallida",
            "bad-string": "no se pudo convertir a cadena",
            "invalid-host": "Servidor no válido",
            "invalid-port": "Puerto no válido"
        }
    },
    "udp": {
        "label": {
            "listen": "Escuchar",
            "onport": "en Puerto",
            "using": "utilizando",
            "output": "Salida",
            "group": "Grupo",
            "interface": "SI local",
            "send": "Enviar un",
            "toport": "al puerto",
            "address": "Dirección",
            "decode-base64": "¿Decodificar la carga codificada en Base64?",
            "port": "puerto"
        },
        "placeholder": {
            "interface": "(opcional) interfaz local o dirección a la que vincularse",
            "interfaceprompt": "(opcional) interfaz local o dirección a la que vincularse",
            "address": "IP de destino"
        },
        "udpmsgs": "mensajes udp",
        "mcmsgs": "mensajes multidifusión",
        "udpmsg": "mensajes udp",
        "bcmsg": "mensajes transmisión",
        "mcmsg": "mensajes multidifusión",
        "output": {
            "buffer": "un Buffer",
            "string": "un Texto",
            "base64": "un texto codificado Base64"
        },
        "bind": {
            "random": "enlazar a puerto local aleatorio",
            "local": "enlazar al puerto local",
            "target": "enlazar al puerto de destino"
        },
        "tip": {
            "in": "Consejo: asegúrate de que tu firewall permita la entrada de datos.",
            "out": "Consejo: deja la dirección y el puerto en blanco si quieres configurar usando <code>msg.ip</code> y <code>msg.port</code>.",
            "port": "Puertos ya en uso: "
        },
        "status": {
            "listener-at": "udp escuchando en __host__:__port__",
            "mc-group": "udp grupo multidifusión __group__",
            "listener-stopped": "udp escucha detenida",
            "output-stopped": "udp salida detenida",
            "mc-ready": "udp multidifusión lista: __iface__:__outport__ -> __host__:__port__",
            "bc-ready": "udp transmisión lista: __outport__ -> __host__:__port__",
            "ready": "udp lista: __outport__ -> __host__:__port__",
            "ready-nolocal": "udp lista: __host__:__port__",
            "re-use": "udp reutilizar el socket: __outport__ -> __host__:__port__"
        },
        "errors": {
            "access-error": "Error de acceso UDP, es posible que necesites acceso de root para puertos inferiores a 1024",
            "error": "error: __error__",
            "bad-mcaddress": "Dirección de multidifusión incorrecta",
            "interface": "Debe ser la dirección IP de la interfaz requerida.",
            "ip-notset": "udp: dirección IP no configurada",
            "port-notset": "udp: puerto no configurado",
            "port-invalid": "udp: número de puerto no válido",
            "alreadyused": "udp: puerto __port__ ya en uso",
            "ifnotfound": "udp: interfaz __iface__ no encontrada",
            "invalid-group": "grupo de multidifusión no válido"
        }
    },
    "switch": {
        "switch": "conmutador",
        "label": {
            "property": "Propiedad",
            "rule": "regla",
            "repair": "recrear secuencias de mensajes",
            "value-rules": "reglas de valor",
            "sequence-rules": "reglas de secuencia"
        },
        "previous": "valor anterior",
        "and": "y",
        "checkall": "revisando todas las reglas",
        "stopfirst": "parando después de la primer coincidencia",
        "ignorecase": "ignorar capitalización",
        "rules": {
            "btwn": "está entre",
            "cont": "contiene",
            "regex": "matches regex",
            "true": "es verdadero",
            "false": "es falso",
            "null": "es nulo",
            "nnull": "es no nulo",
            "istype": "es de tipo",
            "empty": "es vacío",
            "nempty": "es no vacío",
            "head": "cabeza",
            "tail": "cola",
            "index": "índice entre",
            "exp": "espresión JSONata",
            "else": "de lo contrario",
            "hask": "tiene índice"
        },
        "errors": {
            "invalid-expr": "Expresión JSONata no válida: __error__",
            "too-many": "Demasiados mensajes pendientes en el nodo de conmutación."
        }
    },
    "change": {
        "label": {
            "rules": "Reglas",
            "rule": "regla",
            "set": "establece __property__",
            "change": "cambia __property__",
            "delete": "elimina __property__",
            "move": "mueve __property__",
            "changeCount": "cambia: __count__ reglas",
            "regex": "Usa expresiones regulares",
            "deepCopy": "Copia profunda"
        },
        "action": {
            "set": "Establece",
            "change": "Cambia",
            "delete": "Elimina",
            "move": "Mueve",
            "toValue": "al valor",
            "to": "a",
            "search": "Buscar",
            "replace": "Reemplazar con"
        },
        "errors": {
            "invalid-from": "Propiedad 'from' inválida: __error__",
            "invalid-json": "Propiedad JSON 'to' inválida",
            "invalid-expr": "Expresión JSONata inválida: __error__",
            "no-override": "No se puede establecer una propiedad que no sea de tipo objeto: __property__",
            "invalid-prop": "Expresión de propiedad inválida: __property__",
            "invalid-json-data": "Datos JSON inválidos: __error__"
        }
    },
    "range": {
        "range": "rango",
        "label": {
            "action": "Acción",
            "inputrange": "Mapear el rango de entrada",
            "resultrange": "al rango objetivo",
            "from": "de",
            "to": "a",
            "roundresult": "¿Redondear el resultado al número entero más cercano?",
            "minin": "entrada de",
            "maxin": "entrada a",
            "minout": "destino de",
            "maxout": "destino a"
        },
        "placeholder": {
            "min": "e.g. 0",
            "maxin": "e.g. 99",
            "maxout": "e.g. 255"
        },
        "scale": {
            "payload": "Escalar la propiedad del mensaje",
            "limit": "Escalar y limitar al rango objetivo",
            "wrap": "Escalar y ajustar dentro del rango objetivo",
            "drop": "Escalar, pero eliminar el mensaje si está fuera del rango de entrada"
        },
        "tip": "Consejo: Este nodo SÓLO funciona con números.",
        "errors": {
            "notnumber": "No es un número"
        }
    },
    "csv": {
        "label": {
            "columns": "Columnas",
            "separator": "Separador",
            "c2o": "Opciones de CSV a objeto",
            "o2c": "Opciones de objeto a CSV",
            "input": "Entrada",
            "skip-s": "Saltar primero",
            "skip-e": "líneas",
            "firstrow": "la primera fila contiene nombres de columnas",
            "output": "Salida",
            "includerow": "incluir fila de nombre de columna",
            "newline": "Nueva línea",
            "usestrings": "analizar valores numéricos",
            "include_empty_strings": "incluir cadenas vacías",
            "include_null_values": "incluir valores nulos"
        },
        "placeholder": {
            "columns": "nombres de columnas separados por comas"
        },
        "separator": {
            "comma": "coma",
            "tab": "tabulación",
            "space": "espacio",
            "semicolon": "semicoma",
            "colon": "dos puntos",
            "hashtag": "almohadilla",
            "other": "otro..."
        },
        "output": {
            "row": "un mensaje por fila",
            "array": "un solo mensaje [array]"
        },
        "newline": {
            "linux": "Linux (\\n)",
            "mac": "Mac (\\r)",
            "windows": "Windows (\\r\\n)"
        },
        "hdrout": {
            "none": "nunca enviar encabezados de columna",
            "all": "enviar siempre encabezados de columna",
            "once": "enviar encabezados una vez, hasta msg.reset"
        },
        "errors": {
            "csv_js": "Este nodo solo maneja cadenas CSV u objetos JS.",
            "obj_csv": "No se ha especificado ninguna plantilla de columnas para el objeto -> CSV.",
            "bad_csv": "Datos CSV con formato incorrecto: la salida probablemente esté corrupta."
        }
    },
    "html": {
        "label": {
            "select": "Selector",
            "output": "Salida",
            "in": "en"
        },
        "output": {
            "html": "el contenido HTML de los elementos",
            "text": "sólo el contenido textual de los elementos",
            "attr": "un objeto de cualquier atributo de los elementos"
        },
        "format": {
            "single": "como un mensaje único que contiene una matriz",
            "multi": "como mensajes múltiples, uno para cada elemento"
        }
    },
    "json": {
        "errors": {
            "dropped-object": "Carga sin objeto ignorada",
            "dropped": "Tipo de carga no compatible ignorado",
            "dropped-error": "No se pudo convertir la carga",
            "schema-error": "Error de esquema JSON",
            "schema-error-compile": "Error de esquema JSON: no se pudo compilar el esquema"
        },
        "label": {
            "o2j": "Opciones de objeto a JSON",
            "pretty": "Formatear cadena JSON",
            "action": "Acción",
            "property": "Propiedad",
            "actions": {
                "toggle": "Convertir entre cadena JSON y objeto",
                "str": "Convierta siempre a cadena JSON",
                "obj": "Convertir siempre a objeto JavaScript"
            }
        }
    },
    "yaml": {
        "errors": {
            "dropped-object": "Carga sin objeto ignorada",
            "dropped": "Tipo de carga no admitida ignorada",
            "dropped-error": "No se pudo convertir la carga"
        }
    },
    "xml": {
        "label": {
            "represent": "Propiedad para atributos XML",
            "prefix": "Propiedad para el contenido de la etiqueta",
            "advanced": "Opciones avanzadas",
            "x2o": "Opciones de XML a objeto"
        },
        "errors": {
            "xml_js": "Este nodo solo maneja cadenas XML u objetos JS."
        }
    },
    "file": {
        "label": {
            "write": "escribir archivo",
            "read": "leer archivo",
            "filename": "Nombre del archivo",
            "path": "ruta",
            "action": "Acción",
            "addnewline": "Añadir nueva línea (\\n) a cada carga?",
            "createdir": "¿Crear directorio si no existe?",
            "outputas": "Salida",
            "breakchunks": "Romper en trozos",
            "breaklines": "Romper en filas",
            "sendError": "Enviar mensaje en caso de error (modo compatible)",
            "encoding": "Codificación",
            "deletelabel": "eliminar __file__",
            "utf8String": "texto UTF8",
            "utf8String_plural": "textos UTF8",
            "binaryBuffer": "buffer binario",
            "binaryBuffer_plural": "buffers binarios",
            "allProps": "incluir todas las propiedades existentes en cada mensaje"
        },
        "action": {
            "append": "adjuntar al archivo",
            "overwrite": "sobrescribir archivo",
            "delete": "borrar archivo"
        },
        "output": {
            "utf8": "una sola cadena UTF8",
            "buffer": "un único objeto Buffer",
            "lines": "un mensaje por línea",
            "stream": "una corriente de buffers"
        },
        "status": {
            "wrotefile": "escrito al archivo: __file__",
            "deletedfile": "archivo eliminado: __file__",
            "appendedfile": "adjuntado al archivo: __file__"
        },
        "encoding": {
            "none": "predeterminado",
            "setbymsg": "definido por msg.encoding",
            "native": "Nativo",
            "unicode": "Unicode",
            "japanese": "Japanese",
            "chinese": "Chinese",
            "korean": "Korean",
            "taiwan": "Taiwan/Hong Kong",
            "windows": "Windows codepages",
            "iso": "ISO codepages",
            "ibm": "IBM codepages",
            "mac": "Mac codepages",
            "koi8": "KOI8 codepages",
            "misc": "Misceláneas"
        },
        "errors": {
            "nofilename": "No se ha especificado ningún nombre de archivo",
            "invaliddelete": "Advertencia: eliminación no válida. Utiliza la opción de eliminación específica en el cuadro de diálogo de configuración.",
            "deletefail": "no se pudo eliminar el archivo: __error__",
            "writefail": "no se pudo escribir en el archivo: __error__",
            "appendfail": "no se pudo adjuntar al archivo: __error__",
            "createfail": "no se pudo crear el archivo: __error__"
        },
        "tip": "Consejo: El nombre del archivo debe ser una ruta absoluta; de lo contrario, será relativo al directorio de trabajo del proceso Node-RED."
    },
    "split": {
        "split": "dividir",
        "intro": "Dividir <code>msg.payload</code> basado en tipo:",
        "object": "<b>Objeto</b>",
        "objectSend": "Enviar un mensaje para cada par clave/valor",
        "strBuff": "<b>Texto</b> / <b>Buffer</b>",
        "array": "<b>Array</b>",
        "splitUsing": "Dividir usando",
        "splitLength": "Longitud fija de",
        "stream": "Manejar como un flujo de mensajes",
        "addname": " Copiar clave a "
    },
    "join": {
        "join": "unir",
        "mode": {
            "mode": "Modo",
            "auto": "automático",
            "merge": "fusionar secuencias",
            "reduce": "reducir secuencia",
            "custom": "manual"
        },
        "combine": "Combinar cada",
        "completeMessage": "mensaje completo",
        "create": "a crear",
        "type": {
            "string": "un Texto",
            "array": "un Array",
            "buffer": "un Buffer",
            "object": "un Objeto clave/valor",
            "merged": "un Objeto combinado"
        },
        "using": "usando el valor de",
        "key": "como la clave",
        "joinedUsing": "se unió usando",
        "send": "Enviar el mensaje:",
        "afterCount": "Después de varias partes del mensaje",
        "count": "contar",
        "subsequent": "y cada mensaje posterior.",
        "afterTimeout": "Después de un tiempo de espera trás el primer mensaje",
        "seconds": "segundos",
        "complete": "Después de un mensaje con la propiedad <code>msg.complete</code> establecida",
        "tip": "Este modo supone que este nodo está emparejado con un nodo <i>dividir</i> o que los mensajes recibidos tendrán una propiedad <code>msg.parts</code> configurada correctamente.",
        "too-many": "demasiados mensajes pendientes en el nodo de unión.",
        "message-prop": "propiedad de mensaje",
        "merge": {
            "topics-label": "Temas Fusionados",
            "topics": "temas",
            "topic": "tema",
            "on-change": "Enviar mensaje combinado al llegar un nuevo tema"
        },
        "reduce": {
            "exp": "Expresión de reducción",
            "exp-value": "expresión",
            "init": "Valor inicial",
            "right": "Evaluar en orden inverso (último a primero)",
            "fixup": "Expresión de reparación"
        },
        "errors": {
            "invalid-expr": "Expresión JSONata no válida: __error__",
            "invalid-type": "No se puede juntar __error__ al buffer"
        }
    },
    "sort": {
        "sort": "ordenar",
        "target": "Ordenar",
        "seq": "secuencia de mensajes",
        "key": "Clave",
        "elem": "valor del elemento",
        "order": "Orden",
        "ascending": "ascendente",
        "descending": "descendente",
        "as-number": "como número",
        "invalid-exp": "Expresión JSONata no válida en nodo de ordenación: __message__",
        "too-many": "Demasiados mensajes pendientes en el nodo de clasificación",
        "clear": "borrar mensaje pendiente en nodo de clasificación"
    },
    "batch": {
        "batch": "lote",
        "mode": {
            "label": "Modo",
            "num-msgs": "Agrupar por número de mensajes",
            "interval": "Agrupar por intervalo de tiempo",
            "concat": "Concatenar secuencias"
        },
        "count": {
            "label": "Número de mensajes",
            "overlap": "Solapamiento",
            "count": "Contar",
            "invalid": "Recuento y solapamiento no válidos"
        },
        "interval": {
            "label": "Intervalo",
            "seconds": "segundos",
            "empty": "enviar mensaje vacío cuando no llega ningún mensaje"
        },
        "concat": {
            "topics-label": "Temas",
            "topic": "tema"
        },
        "too-many": "demasiados mensajes pendientes en el nodo de lotes",
        "unexpected": "modo inesperado",
        "no-parts": "ninguna propiedad 'parte' en el mensaje",
        "error": {
            "invalid-count": "Recuento no válido",
            "invalid-overlap": "Solapamiento no válido",
            "invalid-interval": "Intervalo no válido"
        }
    },
    "rbe": {
        "rbe": "filtrar",
        "label": {
            "func": "Modo",
            "init": "Enviar valor inicial",
            "start": "Valor inicial",
            "name": "Nombre",
            "septopics": "Aplicar el modo por separado para cada ",
            "gap": "cambio de valor",
            "property": "propiedad",
            "topic": "tema"
        },
        "placeholder": {
            "bandgap": "e.g. 10 ó 5%",
            "start": "dejar en blanco para utilizar el primer dato recibido"
        },
        "opts": {
            "rbe": "bloquear a menos que cambie el valor",
            "rbei": "bloquear a menos que cambie el valor (ignorar el valor inicial)",
            "deadband": "bloquear a menos que el cambio de valor sea mayor que",
            "deadbandEq": "bloquear a menos que el cambio de valor sea mayor o igual que",
            "narrowband": "bloquear si el cambio de valor es mayor que",
            "narrowbandEq": "bloquear si el cambio de valor es mayor o igual que",
            "in": "comparado con el último valor introducido",
            "out": "comparado con el último valor de salida válido"
        },
        "warn": {
            "nonumber": "no hay un número en la carga"
        }
    },
    "global-config": {
        "label": {
            "open-conf": "Abrir Ajustes"
        }
    }
}
