<script type="text/html" data-template-name="neuron-p2p">
    <div class="form-row">
        <label for="node-input-name"><span>Name</span></label>
        <input type="text" id="node-input-name" placeholder="Neuron P2P">
    </div>
    <div class="form-row">
        <label for="node-input-selectedNode"> <span>Selected Node</span></label>
        <input type="hidden" id="node-input-selectedNode" />
        <input type="text" id="node-input-selectedNodeDisplay" placeholder="No node selected" readonly disabled>
        <button type="button" id="node-input-selectNode-btn" class="red-ui-button" style="margin-left: 5px; background-color: #489cb5; color: white;">
            Select node
        </button>
        <button type="button" id="node-input-clearNode-btn" class="red-ui-button" style="margin-left: 5px;" title="Clear selection">
            Clear
        </button>
    </div>
    <div class="form-row">
        <label for="node-input-description"><span>Description</span></label>
        <input type="text" id="node-input-description" placeholder="Optional description">
    </div>
</script>

<script type="text/javascript">
    RED.nodes.registerType('neuron-p2p', {
        category: 'Neuron',
        color: '#489cb5',
        defaults: {
            name: { value: "" },
            selectedNode: { value: "" },
            description: { value: "" }
        },
        inputs: 1,
        outputs: 1,
        icon: "radio-antenna.svg",
        label: function() {
            return this.name || "Neuron P2P Out";
        },
        oneditprepare: function() {
            const node = this;
            const selectedNodeInput = $('#node-input-selectedNode'); // Hidden field for ID
            const selectedNodeDisplayInput = $('#node-input-selectedNodeDisplay'); // Visible field for name
            
            // Add custom styles
            $('<style>')
                .text(`
                    .node-table {
                        width: 100%;
                        border-collapse: collapse;
                        margin-bottom: 10px;
                    }
                    .node-table th {
                        padding: 8px;
                        text-align: left;
                        border-bottom: 2px solid #ddd;
                        font-weight: bold;
                    }
                    .node-table td {
                        padding: 8px;
                        border-bottom: 1px solid #ddd;
                        vertical-align: middle;
                    }
                    .node-table tr:hover {
                        background-color: #f5f5f5;
                        color: black;
                        cursor: pointer;
                    }
                    .node-table .select-btn {
                        padding: 4px 8px;
                        background-color: #489cb5;
                        color: white;
                        border: none;
                        border-radius: 3px;
                        cursor: pointer;
                        opacity: 0;
                        transition: opacity 0.2s;
                    }
                    .node-table tr:hover .select-btn {
                        opacity: 1;
                    }
                    .node-table .select-btn:hover {
                        background-color: #3a7a8c;
                    }
                    .node-table .node-name {
                        font-weight: 500;
                    }
                    .node-table .node-type {
                        color: #666;
                        font-size: 0.9em;
                    }
                `)
                .appendTo('head');
            
            // Function to update the input field with selected node info
            function updateNodeInput(nodeId, nodeName) {
                selectedNodeInput.val(nodeId); // Store the actual node ID in hidden field
                selectedNodeDisplayInput.val(nodeName); // Show the friendly name to user in visible field
            }

            // Set initial values
            if (node.name) {
                $('#node-input-name').val(node.name);
            }
            if (node.description) {
                $('#node-input-description').val(node.description);
            }
            
            // Initialize selected node display
            if (node.selectedNode) {
                const selectedNode = RED.nodes.node(node.selectedNode);
                if (selectedNode) {
                    updateNodeInput(selectedNode.id, selectedNode.name || selectedNode.id);
                } else {
                    // Node no longer exists, clear the selection
                    selectedNodeInput.val('');
                    selectedNodeDisplayInput.val('Node not found');
                }
            }

            // Handle the search button click
            $('#node-input-selectNode-btn').click(function() {
                console.log('Select node button clicked'); // Debug log
                
                const dialog = $('<div>').dialog({
                    title: 'Select Node',
                    width: 600,
                    height: 400,
                    modal: true,
                    buttons: [
                        {
                            text: "Cancel",
                            click: function() {
                                $(this).dialog("close");
                            }
                        }
                    ]
                });

                // Create a table to show available nodes
                const table = $('<table>').addClass('node-table');
                const thead = $('<thead>').append(
                    $('<tr>').append(
                        $('<th>').text("Name").css('width', '70%'),
                        $('<th>').text("Type").css('width', '20%'),
                        $('<th>').css('width', '10%')
                    )
                );
                table.append(thead);

                const tbody = $('<tbody>');
                
                // Find all buyer and seller nodes in the workspace and sort them by name
                const nodes = [];
                RED.nodes.eachNode(function(n) {
                    if (n.type === 'buyer config' || n.type === 'seller config') {
                        nodes.push(n);
                    }
                });
                
                // Sort nodes by name
                nodes.sort((a, b) => {
                    const nameA = (a.name || a.id).toLowerCase();
                    const nameB = (b.name || b.id).toLowerCase();
                    return nameA.localeCompare(nameB);
                });

                // Add sorted nodes to table
                nodes.forEach(function(n) {
                    const row = $('<tr>').append(
                        $('<td>').addClass('node-name').text(n.name || n.id),
                        $('<td>').addClass('node-type').text(n.type),
                        $('<td>').append(
                            $('<button>')
                                .addClass('select-btn')
                                .text('Select')
                                .click(function(e) {
                                    e.stopPropagation();
                                    updateNodeInput(n.id, n.name || n.id);
                                    dialog.dialog("close");
                                })
                        )
                    );
                    
                    // Add click handler for the entire row
                    row.click(function() {
                        updateNodeInput(n.id, n.name || n.id);
                        dialog.dialog("close");
                    });
                    
                    tbody.append(row);
                });

                table.append(tbody);
                dialog.append(table);
                dialog.dialog('open'); // Open the dialog
            });

            // Handle clear button click
            $('#node-input-clearNode-btn').click(function() {
               // console.log('Clear node button clicked'); // Debug log
                selectedNodeInput.val('');
                selectedNodeDisplayInput.val('No node selected');
            });

            // Make the display input field read-only and disabled (not the hidden field)
            selectedNodeDisplayInput.prop('readonly', true);
            selectedNodeDisplayInput.prop('disabled', true);
            
            // Add help text
            const helpText = $('<div>')
                .addClass('form-row')
                .html(`
                    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; margin-top: 10px;">
                        <strong>Quick Reference:</strong><br>
                        This node enables peer-to-peer communication through the Neuron network.<br><br>
                        <strong>Input:</strong> Send data to network peers via selected buyer/seller node<br>
                        <strong>Output:</strong> Receive data from network peers<br><br>
                        <strong>Targeting:</strong><br>
                        • Without <code>msg.to</code> - Broadcasts to all peers in selected node's peer list<br>
                        • With <code>msg.to</code> - Sends only to specified Hedera admin-key address<br><br>
                        <strong>Note:</strong> <code>msg.to</code> uses Hedera admin-key, not EVM address.
                    </div>
                `);
            
            $('.form-row').last().after(helpText);
        },
        oneditsave: function() {
            this.name = $('#node-input-name').val();
            this.selectedNode = $('#node-input-selectedNode').val(); // Read from hidden field
            this.description = $('#node-input-description').val();
        }
    });
</script>

<script type="text/x-red" data-help-name="neuron-p2p">
    <p>A peer-to-peer communication node that enables message transmission and reception through the Neuron network.</p>
    
    <h3>Overview</h3>
    <p>The Neuron P2P node provides bidirectional communication with other devices in the Neuron network. It connects to a selected buyer or seller node to access the network and exchange messages with peers.</p>
    
    <h3>Inputs</h3>
    <dl class="message-properties">
        <dt>payload <span class="property-type">any</span></dt>
        <dd>The message content to transmit to network peers</dd>
        <dt class="optional">to or target <span class="property-type">string</span></dt>
        <dd>Target peer's Hedera admin-key address. If specified, peer list is ignored and message goes only to this address. If multiple addresses are specified, message is sent to all of them. (same as <code>msg.target</code>)</dd>
        <dt class="optional">publicKey <span class="property-type">string</span></dt>
        <dd>Alternative field for specifying (comma separated) target peers (same as <code>msg.to</code>)</dd>
        <dt class="optional">type <span class="property-type">string</span></dt>
        <dd>Message type identifier (default: "p2p")</dd>
        <dt class="optional">timestamp <span class="property-type">number</span></dt>
        <dd>Message timestamp (default: current time)</dd>
    </dl>
    
    <h3>Outputs</h3>
    <dl class="message-properties">
        <dt>payload <span class="property-type">any</span></dt>
        <dd>Message content received from network peers</dd>
        <dt>publicKey <span class="property-type">string</span></dt>
        <dd>Sender's public key/admin-key address</dd>
        <dt>timestamp <span class="property-type">number</span></dt>
        <dd>Message timestamp from sender</dd>
        <dt>topic <span class="property-type">string</span></dt>
        <dd>Always set to "incoming" for received messages</dd>
        <dt>raw <span class="property-type">object</span></dt>
        <dd>Original raw message for debugging purposes</dd>
    </dl>
    
    <h3>Configuration</h3>
    <ul>
        <li><b>Name</b>: Optional name for the node</li>
        <li><b>Selected Node</b>: Choose a buyer or seller config node to connect through</li>
        <li><b>Description</b>: Optional description for documentation</li>
    </ul>
    
    <h3>Message Routing</h3>
    <h4>Broadcast Mode (No msg.to specified)</h4>
    <ul>
        <li>Messages are sent to all peers in the selected node's peer list</li>
        <li>For buyer nodes: Sends to all connected seller nodes</li>
        <li>For seller nodes: Sends to all connected buyer nodes</li>
        <li>Uses the admin-key lists configured in the buyer/seller node</li>
    </ul>
    
    <h4>Direct Mode (msg.to specified)</h4>
    <ul>
        <li>Peer list is completely ignored</li>
        <li>Message is sent only to the address specified in <code>msg.to</code></li>
        <li><b>Important:</b> <code>msg.to</code> must be a Hedera admin-key, not an EVM address</li>
        <li>Admin-keys are the public keys used for device authentication in Hedera</li>
    </ul>
    
    <h3>WebSocket Connection</h3>
    <p>The node automatically establishes WebSocket connections using:</p>
    <ul>
        <li><b>URL Format:</b> <code>ws://localhost:{wsPort}/{nodeType}/p2p</code></li>
        <li><b>Port:</b> Extracted from selected node's device information</li>
        <li><b>Endpoint:</b> "/buyer/p2p" or "/seller/p2p" based on selected node type</li>
        <li><b>Auto-reconnection:</b> Attempts to reconnect if connection is lost</li>
    </ul>
    
    <h3>Message Format</h3>
    <h4>Outgoing Messages</h4>
    <pre>
{
    "type": "p2p",
    "data": msg.payload,
    "timestamp": 1234567890,
    "from": "sender_public_key",
    "target": "target_admin_key" // Optional, for direct messaging
}
    </pre>
    
    <h4>Incoming Messages</h4>
    <pre>
{
    "topic": "incoming",
    "payload": "message_content",
    "publicKey": "sender_admin_key",
    "timestamp": 1234567890,
    "raw": { /* original message */ }
}
    </pre>
    
    <h3>Status Indicators</h3>
    <ul>
        <li><span style="color:yellow">●</span> Connecting...: Establishing WebSocket connection</li>
        <li><span style="color:green">●</span> Connected: Active connection to network</li>
        <li><span style="color:green">●</span> Message sent: Successfully transmitted message</li>
        <li><span style="color:red">●</span> No connection: WebSocket connection failed</li>
        <li><span style="color:red">●</span> Send failed: Message transmission error</li>
    </ul>
    
    <h3>Prerequisites</h3>
    <ul>
        <li>A deployed buyer or seller config node must be selected</li>
        <li>Selected node must be successfully initialized with device credentials</li>
        <li>Neuron SDK process must be running (spawned by buyer/seller node)</li>
        <li>Target peers must be reachable on the network</li>
    </ul>
    
    <h3>Usage Examples</h3>
    <h4>Broadcast to All Peers</h4>
    <pre>
msg.payload = "Hello to all peers!";
// No msg.to field - broadcasts to peer list
return msg;
    </pre>
    
    <h4>Direct Message to Specific Peer</h4>
    <pre>
msg.payload = "Direct message";
msg.to = "0x1234567890abcdef..."; // Hedera admin-key
return msg;
    </pre>
    
    <h3>Troubleshooting</h3>
    <ul>
        <li><b>No connection:</b> Ensure selected node is deployed and running</li>
        <li><b>Message not delivered:</b> Check if target admin-key is correct and peer is online</li>
        <li><b>Empty peer list:</b> Verify buyer/seller node has configured peer addresses</li>
        <li><b>WebSocket errors:</b> Check if Neuron SDK process is running on selected node</li>
    </ul>
    
    <h3>Important Notes</h3>
    <ul>
        <li><b>Address Types:</b> Always use Hedera admin-keys, never EVM addresses for <code>msg.to</code></li>
        <li><b>Network Layer:</b> This node operates at the P2P communication layer, not blockchain transactions</li>
        <li><b>Real-time:</b> Messages are transmitted in real-time via WebSocket connections</li>
        <li><b>Persistence:</b> Messages are not stored; they're transmitted live between peers</li>
    </ul>
</script> 