<script type="text/html" data-template-name="buyer config">
<div class="neuron-buyer-config">

    <div class="form-row">
        <label for="node-input-name"> <span>Name</span></label>
        <input type="text" id="node-input-name" placeholder="Node name">
    </div>

    <div class="form-row">
        <label for="node-input-smartContract"><i class="fa fa-file-contract"></i> <span>Smart Contract</span></label>
        <select id="node-input-smartContract">
            <option value="jetvision" selected>JETVISION DEMO</option>
            <option value="chat">P2P CHAT DEMO</option>
            <option value="challenges">DEVELOPER OPEN CHALLENGES</option>
           <!-- <option value="Weather">Weather</option> -->

        </select>
    </div>

    <div class="form-row">
        <label for="node-input-deviceType"><span>Device Type</span></label>
        <input type="text" id="node-input-deviceType" placeholder="Enter Device Type e.g Cloud, Edge">
    </div>
    <!-- Replace the existing seller selection section with this inline version -->
    <span><i>Sellers I want data from (Should be in selected Smart Contract above )</i></span>
    <div class="form-row">
        <div style="margin-top: 10px;">
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="text" id="evm-address-input" placeholder="Enter EVM address (0x...)" 
                       style="flex: 1; font-family: monospace; font-size: 12px;">
                <button type="button" id="add-device-btn" class="red-ui-button">
                    <i class="fa fa-plus"></i> Add Seller
                </button>
            </div>
            
            <div id="devices-table-container" style="margin-top: 10px; border: 1px solid #555; border-radius: 5px; padding: 10px;">
                <table id="devices-table" style="width: 100%; border-collapse: collapse; display: none;">
                    <thead>
                        <tr style="background-color: #2d2d2d; color: white;">
                            <th style="padding: 8px; border: 1px solid #555; text-align: left;">EVM Address</th>
                            <th style="padding: 8px; border: 1px solid #555; text-align: center; width: 100px;">Status</th>
                            <th style="padding: 8px; border: 1px solid #555; text-align: center; width: 100px;">Last Seen</th>
                            <th style="padding: 8px; border: 1px solid #555; text-align: center; width: 60px;">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="devices-table-body">
                    </tbody>
                </table>
                
                <div id="no-devices-message" style="text-align: center; color: #888; padding: 20px; font-style: italic;">
                    No devices added yet. Enter an EVM address above to add a device.
                </div>
                
                <div id="devices-summary" style="margin-top: 10px; font-size: 12px; color: #666;">
                    <span id="device-count">0</span> device(s) configured
                </div>
            </div>
        </div>
        
        <!-- Keep the hidden input for data storage -->
        <input type="hidden" id="node-input-sellerEvmAddress" />
    </div>
    <div class="form-row">
        <label for="node-input-description"> <span>Description</span></label>
        <input type="text" id="node-input-description" placeholder="Description (optional)">
    </div>
    <i style="color: #ffc107;">Click <span style="color: red">Done</span> then click <span style="color: red">Deploy</span> to create/update device</i>
    
    <div id="no-device-message" style="margin: 15px 0; padding: 10px; background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 5px; color: #6c757d; font-style: italic;">
        <i class="fa fa-info-circle" style="margin-right: 5px;"></i>
        Runtime information will appear here after the device is created (after first deployment).
    </div>
    
    <!-- Separator line between configuration and runtime information -->
    <hr style="margin: 15px 0; border: none; border-top: 1px solid #ccc;">
    
    <!-- Runtime Information Section -->
    <div id="runtime-information-section" style="display: none;">
        <h4 style="margin: 10px 0; color:#28a745;">Runtime Information</h4>

        <div class="form-row">
            <label for="node-input-evmAddress"><span>EVM Address</span></label>
            <input type="text" id="node-input-evmAddress" placeholder="EVM address will appear here after initialization" readonly>
        </div>

        <div class="form-row">
            <label for="node-input-balance"><span>Balance</span></label>
            <input type="text" id="node-input-balance" placeholder="Account balance will appear here after initialization" readonly>
            <small><a href="https://portal.hedera.com/faucet" target="_blank" style="color:#4d90fe; text-decoration: underline;">Â Top up account</a></small>
        </div>

        <div class="form-row">
            <label for="node-input-publicKey"><span>Public Key</span></label>
            <input type="text" id="node-input-publicKey" placeholder="Public key will appear here after initialization" readonly>
        </div>

        <!-- Add these three new topic fields -->
        <div class="form-row">
            <label for="node-input-stdInTopic"><span>StdIn Topic</span></label>
            <input type="text" id="node-input-stdInTopic" placeholder="StdIn topic will appear here after initialization" readonly>
        </div>

        <div class="form-row">
            <label for="node-input-stdOutTopic"><span>StdOut Topic</span></label>
            <input type="text" id="node-input-stdOutTopic" placeholder="StdOut topic will appear here after initialization" readonly>
        </div>

        <div class="form-row">
            <label for="node-input-stdErrTopic"><span>StdErr Topic</span></label>
            <input type="text" id="node-input-stdErrTopic" placeholder="StdErr topic will appear here after initialization" readonly>
        </div>
    </div>

    <!-- Connection Status Section - moved to bottom -->
   <!-- <div class="form-row">
        <label><span>Connection Status</span></label>
        <div id="connection-status-indicator" style="display: inline-block; margin-left: 10px;">
            <span id="status-dot" style="display: inline-block; width: 12px; height: 12px; border-radius: 50%; background-color: #ccc; margin-right: 5px;"></span>
            <span id="status-text" style="color: white;">Unknown</span>
        </div>
        <button type="button" id="refresh-connections-btn" class="red-ui-button" style="margin-left: 10px;">
            <i class="fa fa-refresh"></i> Refresh
        </button>
    </div>-->
    
    <!--<div class="form-row">
        <label><span>Connected Peers</span></label>
        <div id="connected-peers-container" style="margin-top: 10px;">
            <div id="peers-loading" style="text-align: center; color: black; padding: 20px;">
                <i class="fa fa-spinner fa-spin"></i> Loading connection status...
            </div>
            <div id="peers-content" style="display: none;">
                <div id="peers-summary" style="margin-bottom: 10px; font-weight: bold; color: white;">
                    <span id="connected-count">0</span> connected, <span id="total-count">0</span> total peers
                </div>
                <div id="peers-list" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px; background-color: #f9f9f9;">
                    <div id="no-peers-message" style="text-align: center; color: black; font-style: italic;">
                        No peers connected
                    </div>
                    <table id="peers-table" style="width: 100%; display: none; color: black;">
                        <thead>
                            <tr>
                                <th style="text-align: left; padding: 5px; border-bottom: 1px solid #ddd; color: black;">Public Key</th>
                                <th style="text-align: center; padding: 5px; border-bottom: 1px solid #ddd; color: black;">Status</th>
                                <th style="text-align: center; padding: 5px; border-bottom: 1px solid #ddd; color: black;">Last Update</th>
                            </tr>
                        </thead>
                        <tbody id="peers-table-body">
                        </tbody>
                    </table>
                </div>
                <div id="last-update-info" style="margin-top: 5px; font-size: 12px; color: black;">
                    Last updated: <span id="last-update-time">Never</span>
                </div>
            </div>
        </div>
    </div>-->


    <!-- The seller-modal div is no longer needed -->
</div>
</script>



<script type="text/javascript">
    // Move shared variables/functions outside the IIFE


    RED.nodes.registerType('buyer config', {
        category: 'Neuron',
        color: '#9799b2',
        editDialogSize: {
            width: '600px',
            height: 'auto'
        },
        defaults: {
            name: { value: "Buyer" },
            sellerEvmAddress: { value: [] },
            sellerDevices: { value: [] },
            smartContract: { value: "jetvision" }, // Ensure this has a default value
            deviceType: { value: null, required: true },
            description: { value: "" },
            evmAddress: { value: "" },
            balance: { value: "" },
            publicKey: { value: "" },
            // Add these three new fields
            stdInTopic: { value: "" },
            stdOutTopic: { value: "" },
            stdErrTopic: { value: "" }
        },
        inputs: 0,
        outputs: 1,
        icon: "serial.svg",
        label: function () {
            return this.name || "Neuron Buyer";
        },
        labelStyle: function () {
            return this.name ? "node_label_italic" : "";
        },
        oneditprepare: function () {
            const node = this;
            node.devicesList = []; // Store device objects

            // Timer for updates
            let autoUpdateInterval = null;

            // Cleanup function
            this._cleanup = function () {
                if (autoUpdateInterval) {
                    clearInterval(autoUpdateInterval);
                    autoUpdateInterval = null;
                    console.log('[DEBUG] Auto-update interval cleared');
                }
            };

            console.log('[SCOPE TEST] node defined at start:', typeof node);

            // Initialize devices from existing configuration
            function initializeDevices() {
                console.log('[SCOPE TEST] node in initializeDevices:', typeof node);

                let storedDevices = node.sellerDevices || node.sellerEvmAddress || [];
                node.devicesList = [];

                if (Array.isArray(storedDevices)) {
                    if (storedDevices.length > 0) {
                        if (typeof storedDevices[0] === 'string') {
                            node.devicesList = storedDevices.map(addr => ({
                                evmAddress: addr,
                                deviceName: 'Legacy Device',
                                deviceType: 'Unknown',
                                stdInTopic: 'Unknown',
                                stdOutTopic: 'Unknown',
                                stdErrTopic: 'Unknown'
                            }));
                        } else if (storedDevices[0] && storedDevices[0].evmAddress) {
                            node.devicesList = [...storedDevices];
                        }
                    }
                }

                updateDevicesTable();
                updateDevicesSummary();
            }

            // Update devices table display - WITH SIMPLE 1-SEC REPEAT
            function updateDevicesTable() {
                console.log('[DEBUG] updateDevicesTable called, node available:', typeof node);

                const tableBody = $('#devices-table-body');
                const table = $('#devices-table');
                const noDevicesMsg = $('#no-devices-message');

                tableBody.empty();

                if (node.devicesList.length === 0) {
                    table.hide();
                    noDevicesMsg.show();
                    // Clear any existing interval if no devices
                    if (autoUpdateInterval) {
                        clearInterval(autoUpdateInterval);
                        autoUpdateInterval = null;
                    }
                    return;
                }

                table.show();
                noDevicesMsg.hide();

                node.devicesList.forEach((device, index) => {
                    const row = $(`
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555; font-family: monospace; font-size: 11px; word-break: break-all;">
                                ${device.evmAddress}
                            </td>
                           
                            <td id="status-cell-${index}" style="padding: 8px; border: 1px solid #555; text-align: center; font-size: 11px;">
                                <i class="fa fa-spinner fa-spin" style="color: #888;"></i>
                            </td>
                            <td id="lastseen-cell-${index}" style="padding: 8px; border: 1px solid #555; text-align: center; font-size: 11px;">
                                <i class="fa fa-spinner fa-spin" style="color: #888;"></i>
                            </td>
                            <td style="padding: 8px; border: 1px solid #555; text-align: center;">
                                <button type="button" class="red-ui-button red-ui-button-small remove-device-btn" 
                                        data-index="${index}" style="padding: 2px 6px;">
                                    <i class="fa fa-trash"></i>
                                </button>
                                        </td>
                                    </tr>
                                `);
                    tableBody.append(row);
                });

                // Attach remove button handlers
                $('.remove-device-btn').click(function () {
                    const index = parseInt($(this).data('index'));
                    removeDevice(index);
                });

                console.log('[DEBUG] Table updated, starting 1-second repeat calls');

                // Start simple 1-second repeat if node.id is available
                if (node.id && node.devicesList.length > 0) {
                    startSimpleRepeats();
                }
            }

            // Simple function to start 1-second repeats - INSIDE oneditprepare
            function startSimpleRepeats() {
                // Clear any existing interval
                if (autoUpdateInterval) {
                    clearInterval(autoUpdateInterval);
                }


                // Do initial call
                autoCheckAllDevices();

                // Set up simple interval for every 5 second
                autoUpdateInterval = setInterval(() => {
                    if (node.devicesList.length > 0) {
                        autoCheckAllDevices();
                    } else {
                        // No devices, clear interval
                        clearInterval(autoUpdateInterval);
                        autoUpdateInterval = null;
                    }
                }, 30000); // 5 second
            }

            // Auto-check function - INSIDE oneditprepare
            async function autoCheckAllDevices() {
                if (!node.id) {
                    return;
                }

                try {
                    // Get connection status for this buyer node
                    const connectionResponse = await fetch(`/buyer/connection-status/${node.id}`);
                    if (!connectionResponse.ok) {
                        throw new Error(`Connection API returned ${connectionResponse.status}`);
                    }

                    const connectionData = await connectionResponse.json();

                    // Create a map of public keys to connection status
                    const statusMap = new Map();
                    if (connectionData.peers && Array.isArray(connectionData.peers)) {
                        connectionData.peers.forEach(peer => {
                            if (peer.publicKey) {
                                statusMap.set(peer.publicKey, peer.connectionStatus || 'No connection');
                            }
                        });
                    }

                    // Process each device
                    for (let index = 0; index < node.devicesList.length; index++) {
                        const device = node.devicesList[index];
                        checkDeviceStatusAuto(device, index, statusMap);
                        checkLastSeenAuto(device, index);
                    }

                } catch (error) {
                    console.error('[DEBUG] Error in autoCheckAllDevices:', error);
                    // Set all cells to error
                    for (let index = 0; index < node.devicesList.length; index++) {
                        $(`#status-cell-${index}`).html('<span style="color: #dc3545;">Not initialised</span>');
                        $(`#lastseen-cell-${index}`).html('<span style="color: #dc3545;">Not initialised</span>');
                    }
                }
            }

            // Auto status check function - INSIDE oneditprepare
            async function checkDeviceStatusAuto(device, index, statusMap) {
                const statusCell = $(`#status-cell-${index}`);

                try {
                    console.log('[DEBUG] Getting public key for device', index, ':', device.evmAddress);

                    // Get public key from EVM address
                    const evmResponse = await fetch(`/buyer/evm-to-publickey/${device.evmAddress}`);
                    const evmData = await evmResponse.json();

                    if (!evmData.success) {
                        console.log('[DEBUG] Failed to get public key for device', index);
                        statusCell.html('<span style="color: #dc3545;">Key Error</span>');
                        return;
                    }

                    const publicKey = evmData.publicKey;
                    const status = statusMap.get(publicKey) || 'No connection';

                    console.log('[DEBUG] Device', index, 'PublicKey:', publicKey, 'Status:', status);

                    // Color code the result
                    let color = '#dc3545'; // red for disconnected
                    if (status === 'connected') {
                        color = '#28a745'; // green
                    } else if (status === 'connecting') {
                        color = '#ffc107'; // yellow
                    }

                    statusCell.html(`<span style="color: ${color};">${status}</span>`);

                } catch (error) {
                    console.error('[DEBUG] Error checking status for device', index, ':', error);
                    statusCell.html('<span style="color: #dc3545;">Error</span>');
                }
            }

            // Auto last seen check function - INSIDE oneditprepare
            async function checkLastSeenAuto(device, index) {
                const lastSeenCell = $(`#lastseen-cell-${index}`);

                try {
                    if (!device.stdOutTopic || device.stdOutTopic === 'Unknown') {
                        lastSeenCell.html('<span style="color: #888;">No Topic</span>');
                        return;
                    }

                    //console.log('[DEBUG] Getting last seen for device', index, 'topic:', device.stdOutTopic);

                    const normalizedTopic = normalizeTopicFormat(device.stdOutTopic);
                    const response = await fetch(`/buyer/last-seen/${normalizedTopic}`);
                    const data = await response.json();

                    if (data.success) {
                        if (data.lastSeen !== null) {
                            // Color code based on how recent the activity is
                            let color = '#888'; // default gray
                            if (data.lastSeen < 300) { // less than 5 minutes
                                color = '#28a745'; // green
                            } else if (data.lastSeen < 3600) { // less than 1 hour
                                color = '#ffc107'; // yellow
                            } else if (data.lastSeen < 86400) { // less than 1 day
                                color = '#fd7e14'; // orange
                            } else {
                                color = '#dc3545'; // red
                            }

                            lastSeenCell.html(`<span style="color: ${color};">${data.lastSeenFormatted}</span>`);
                        } else {
                            lastSeenCell.html('<span style="color: #888;">Never</span>');
                        }
                    } else {
                        // console.log('[DEBUG] Last seen API error for device', index, ':', data.error);
                        lastSeenCell.html('<span style="color: #dc3545;">API Error</span>');
                    }

                } catch (error) {
                    console.error('[DEBUG] Error checking last seen for device', index, ':', error);
                    lastSeenCell.html('<span style="color: #dc3545;">Error</span>');
                }
            }

            // Helper function for truncating topics - INSIDE oneditprepare
            function truncateTopic(topic) {
                if (!topic || topic.length <= 15) return topic;
                return topic.substring(0, 12) + '...';
            }

            // Validate EVM address format
            function isValidEvmAddress(address) {
                return /^0x[a-fA-F0-9]{40}$/.test(address);
            }

            // Add device functionality
            async function addDevice() {
                const evmInput = $('#evm-address-input');
                const addBtn = $('#add-device-btn');
                const evmAddress = evmInput.val().trim();

                // Validation
                if (!evmAddress) {
                    alert('Please enter an EVM address');
                    return;
                }

                if (!isValidEvmAddress(evmAddress)) {
                    alert('Please enter a valid EVM address (0x followed by 40 hex characters)');
                    return;
                }

                // Check for duplicates
                if (node.devicesList.some(d => d.evmAddress.toLowerCase() === evmAddress.toLowerCase())) {
                    alert('This device is already added');
                    return;
                }

                // Show loading state
                addBtn.prop('disabled', true);
                addBtn.html('<i class="fa fa-spinner fa-spin"></i> Fetching Device...');

                try {
                    // console.log(`[DEBUG] Fetching device for EVM: ${evmAddress}, Node ID: ${node.id}, Smart Contract: ${node.smartContract}`);

                    const response = await fetch(`/buyer/fetch-device-by-evm/${evmAddress}?nodeId=${node.id}&smartContract=${node.smartContract}`);
                    const data = await response.json();

                    // console.log(`[DEBUG] Response received:`, data);

                    if (data.success && data.device) {
                        // Add device to list
                        node.devicesList.push(data.device);
                        updateDevicesTable();
                        updateDevicesSummary();
                        evmInput.val(''); // Clear input

                        // console.log('[DEBUG] Device added successfully:', data.device);
                    } else {
                        // console.error('[DEBUG] Device fetch failed:', data);
                        alert(`Device not found: ${data.error || 'Unknown error'}`);
                    }

                } catch (error) {
                    // console.error('[DEBUG] Error fetching device:', error);
                    alert('Error fetching device information. Please check the console for details.');
                } finally {
                    // Restore button state
                    addBtn.prop('disabled', false);
                    addBtn.html('<i class="fa fa-plus"></i> Add Device');
                }
            }

            // Remove device functionality
            function removeDevice(index) {
                if (confirm('Are you sure you want to remove this device?')) {
                    node.devicesList.splice(index, 1);
                    updateDevicesTable();
                    updateDevicesSummary();
                }
            }

            // Update summary display
            function updateDevicesSummary() {
                $('#device-count').text(node.devicesList.length);

                // Update hidden input for storage
                const addressList = node.devicesList.map(d => d.evmAddress);
                $('#node-input-sellerEvmAddress').val(JSON.stringify(addressList));
            }

            // Event handlers
            $('#add-device-btn').click(addDevice);

            // Enter key in input field
            $('#evm-address-input').keypress(function (e) {
                if (e.which === 13) { // Enter key
                    addDevice();
                }
            });

            // Real-time validation styling
            $('#evm-address-input').on('input', function () {
                const value = $(this).val().trim();
                if (value && !isValidEvmAddress(value)) {
                    $(this).css('border-color', '#ff6b6b');
                } else {
                    $(this).css('border-color', '');
                }
            });

            // Initialize the interface
            initializeDevices();

            // Initialize connection status display
            if (node.id) {
                initializeBuyerConnectionStatus(node.id);
            }

            // Fetch and populate EVM address, publicKey, and topics if available
            function updateEvmAddressAndPublicKeyAndTopics() {
                if (node.id) {
                    // console.log(`Fetching device info for node ID: ${node.id}`);
                    $.get(`/buyer/device-info/${node.id}`)
                        .done(function (data) {
                            // console.log(`Device info received for ${node.id}:`, data);

                            // Handle EVM Address
                            if (data.evmAddress) {
                                $('#node-input-evmAddress').val(data.evmAddress);
                            } else {
                                $('#node-input-evmAddress').val('Not initialized yet');
                            }

                            // Handle publicKey
                            if (data.publicKey) {
                                $('#node-input-publicKey').val(data.publicKey);
                            } else {
                                $('#node-input-publicKey').val('Not initialized yet');
                            }

                            // Handle Topics
                            if (data.stdInTopic) {
                                $('#node-input-stdInTopic').val(data.stdInTopic);
                            } else {
                                $('#node-input-stdInTopic').val('Not initialized yet');
                            }

                            if (data.stdOutTopic) {
                                $('#node-input-stdOutTopic').val(data.stdOutTopic);
                            } else {
                                $('#node-input-stdOutTopic').val('Not initialized yet');
                            }

                            if (data.stdErrTopic) {
                                $('#node-input-stdErrTopic').val(data.stdErrTopic);
                            } else {
                                $('#node-input-stdErrTopic').val('Not initialized yet');
                            }
                        })
                        .fail(function (xhr, status, error) {
                            // console.error(`Failed to fetch device info for ${node.id}:`, error);
                            $('#node-input-evmAddress').val('EVM address not intialised');
                            $('#node-input-publicKey').val('Public key not intialised');
                            $('#node-input-stdInTopic').val('StdIn topic not intialised');
                            $('#node-input-stdOutTopic').val('StdOut topic not intialised');
                            $('#node-input-stdErrTopic').val('StdErr topic not intialised');
                        });
                } else {
                    $('#node-input-evmAddress').val('New node - EVM address will be generated after deployment');
                    $('#node-input-publicKey').val('New node - Public key will be generated after deployment');
                    $('#node-input-stdInTopic').val('New node - StdIn topic will be generated after deployment');
                    $('#node-input-stdOutTopic').val('New node - StdOut topic will be generated after deployment');
                    $('#node-input-stdErrTopic').val('New node - StdErr topic will be generated after deployment');
                }
            }

            // Fetch and populate device balance if available
            function updateDeviceBalance() {
                if (node.id) {
                    $.get(`/buyer/device-balance/${node.id}`)
                        .done(function (data) {
                            if (data.success && data.balance) {
                                $('#node-input-balance').val(data.balance + ' USDC');
                            } else {
                                $('#node-input-balance').val('Not initialized yet');
                            }
                        })
                        .fail(function () {
                            $('#node-input-balance').val('Error loading balance');
                        });
                } else {
                    $('#node-input-balance').val('New node - balance will be available after deployment');
                }
            }

            // Check if device exists and show/hide runtime information section
            function checkDeviceExistsAndShowRuntime() {
                if (node.id) {
                    console.log(`[DEVICE EXISTS] Checking device file for node ID: ${node.id}`);
                    $.get(`/buyer/device-exists/${node.id}`)
                        .done(function (data) {
                            console.log(`[DEVICE EXISTS] Response for ${node.id}:`, data);
                            
                            if (data.success && data.exists) {
                                // Device file exists, show runtime information section and hide message
                                $('#runtime-information-section').show();
                                $('#no-device-message').hide();
                                console.log(`[DEVICE EXISTS] Device file found, showing runtime information`);
                            } else {
                                // Device file doesn't exist, hide runtime information section and show message
                                $('#runtime-information-section').hide();
                                $('#no-device-message').show();
                                console.log(`[DEVICE EXISTS] Device file not found, hiding runtime information`);
                            }
                        })
                        .fail(function (xhr, status, error) {
                            console.error(`[DEVICE EXISTS] Failed to check device file for ${node.id}:`, error);
                            // On error, hide the runtime section and show message
                            $('#runtime-information-section').hide();
                            $('#no-device-message').show();
                        });
                } else {
                    // No node ID available, hide runtime information section and show message
                    $('#runtime-information-section').hide();
                    $('#no-device-message').show();
                    console.log(`[DEVICE EXISTS] No node ID available, hiding runtime information`);
                }
            }

            checkDeviceExistsAndShowRuntime();

            // Update EVM address and public key ONCE on dialog open
            updateEvmAddressAndPublicKeyAndTopics();

            // Update balance ONCE on dialog open
            updateDeviceBalance();
        },


        oneditcancel: function () {
            // Clean up intervals when dialog is cancelled/closed
            if (this._cleanup) {
                this._cleanup();
            }
        },

        oneditsave: function () {
            // Clean up intervals when dialog is saved/closed
            if (this._cleanup) {
                this._cleanup();
            }

            // Save devices in new format
            this.sellerEvmAddress = this.devicesList.map(d => d.evmAddress);
            this.sellerDevices = this.devicesList; // Store full device objects

            // Save the current runtime information
            this.evmAddress = $('#node-input-evmAddress').val();
            this.balance = $('#node-input-balance').val();
            this.publicKey = $('#node-input-publicKey').val();
            // Save the new topic fields
            this.stdInTopic = $('#node-input-stdInTopic').val();
            this.stdOutTopic = $('#node-input-stdOutTopic').val();
            this.stdErrTopic = $('#node-input-stdErrTopic').val();
        }
    });

    // Connection status initialization function
    function initializeBuyerConnectionStatus(nodeId) {
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const refreshBtn = document.getElementById('refresh-connections-btn');
        // const peersLoading = document.getElementById('peers-loading');
        //const peersContent = document.getElementById('peers-content');
        //const connectedCount = document.getElementById('connected-count');
        //const totalCount = document.getElementById('total-count');
        //const noPeersMessage = document.getElementById('no-peers-message');
        //const peersTable = document.getElementById('peers-table');
        // const peersTableBody = document.getElementById('peers-table-body');
        //const lastUpdateTime = document.getElementById('last-update-time');

        let isRefreshing = false;

        function updateStatusIndicator(status) {
            // Remove all status classes
            statusDot.classList.remove('connection-status-connected', 'connection-status-disconnected', 'connection-status-connecting', 'connection-status-unknown');

            if (status.isConnected) {
                if (status.connectedPeers > 0) {
                    statusDot.classList.add('connection-status-connected');
                } else {
                    statusDot.classList.add('connection-status-connecting');
                }
                statusText.textContent = `Connected (${status.connectedPeers}/${status.totalPeers} peers)`;

            } else if (status.reconnectAttempts > 0) {
                statusDot.classList.add('connection-status-connecting');
                statusText.textContent = `Connecting... (${status.reconnectAttempts} attempts)`;
            } else {
                statusDot.classList.add('connection-status-disconnected');
                statusText.textContent = 'Disconnected';
            }
        }

        /*  function updatePeersDisplay(status) {
              const peers = status.peers || [];
              const connectedPeers = peers.filter(p => p.connectionStatus === 'connected');
              
              // Update summary
              connectedCount.textContent = connectedPeers.length;
              totalCount.textContent = peers.length;
              
              // Show/hide content
              peersLoading.style.display = 'none';
              peersContent.style.display = 'block';
              
              if (peers.length === 0) {
                  noPeersMessage.style.display = 'block';
                  peersTable.style.display = 'none';
              } else {
                  noPeersMessage.style.display = 'none';
                  peersTable.style.display = 'table';
                  
                  // Clear existing rows
                  peersTableBody.innerHTML = '';
                  
                  // Add peer rows
                  peers.forEach(peer => {
                      const row = document.createElement('tr');
                      row.className = 'peers-table-row';
                      
                      const publicKeyCell = document.createElement('td');
                      publicKeyCell.className = 'peers-table-cell peer-public-key';
                      publicKeyCell.textContent = peer.publicKey || 'Unknown';
                      publicKeyCell.title = peer.publicKey || 'Unknown';
                      
                      const statusCell = document.createElement('td');
                      statusCell.className = 'peers-table-cell';
                      statusCell.style.textAlign = 'center';
                      const statusSpan = document.createElement('span');
                      statusSpan.textContent = peer.connectionStatus || 'unknown';
                      statusSpan.className = `peer-status-${peer.connectionStatus || 'unknown'}`;
                      statusCell.appendChild(statusSpan);
                      
                      const lastUpdateCell = document.createElement('td');
                      lastUpdateCell.className = 'peers-table-cell';
                      lastUpdateCell.style.textAlign = 'center';
                      lastUpdateCell.textContent = peer.lastUpdate ? new Date(peer.lastUpdate).toLocaleTimeString() : 'N/A';
                      
                      row.appendChild(publicKeyCell);
                      row.appendChild(statusCell);
                      row.appendChild(lastUpdateCell);
                      peersTableBody.appendChild(row);
                  });
              }
              
              // Update last update time
              if (status.lastUpdate) {
                  lastUpdateTime.textContent = new Date(status.lastUpdate).toLocaleString();
              } else {
                  lastUpdateTime.textContent = 'Never';
              }
          }*/

        async function loadConnectionStatus() {
            try {
                const response = await fetch(`/buyer/connection-status/${nodeId}`);
                if (response.ok) {
                    const status = await response.json();
                    updateStatusIndicator(status);
                    //updatePeersDisplay(status);
                } else {
                    //console.error('Failed to load connection status:', response.statusText);
                    statusText.textContent = 'Error loading status';
                    statusDot.classList.add('connection-status-unknown');
                }
            } catch (error) {
                console.error('Error loading connection status:', error);
                statusText.textContent = 'Error loading status';
                statusDot.classList.add('connection-status-unknown');
            }
        }

        /*async function refreshConnections() {
            if (isRefreshing) return;
            
           // console.log('[DEBUG] Starting refresh connections...');
            isRefreshing = true;
            
            // Get button element directly and show spinner immediately
            const btn = document.getElementById('refresh-connections-btn');
            if (btn) {
               // console.log('[DEBUG] Button found, showing spinner');
                btn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Refreshing...';
                btn.style.opacity = '0.6';
                btn.disabled = true;
            } else {
                console.log('[DEBUG] Button NOT found');
            }
            
            try {
                // Add delay so you can see the spinner
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                const response = await fetch(`/buyer/refresh-connections/${nodeId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    updateStatusIndicator(result.status);
                    //updatePeersDisplay(result.status);
                   // console.log('[DEBUG] Refresh completed successfully');
                } else {
                    console.error('Failed to refresh connections:', response.statusText);
                }
            } catch (error) {
                console.error('Error refreshing connections:', error);
            } finally {
                // Restore button
                const btn = document.getElementById('refresh-connections-btn');
                if (btn) {
                    btn.innerHTML = '<i class="fa fa-refresh"></i> Refresh';
                    btn.style.opacity = '1';
                    btn.disabled = false;
                   // console.log('[DEBUG] Button restored');
                }
                isRefreshing = false;
               // console.log('[DEBUG] Refresh process completed');
            }
        }*/

        // Set up event listeners
        // refreshBtn.addEventListener('click', refreshConnections);

        // Load initial status (single call only)
        /* loadConnectionStatus();
 
         // Remove the periodic refresh - no more polling
         // const statusInterval = setInterval(loadConnectionStatus, 30000);
 
         // Cleanup function (no interval to clear)
         return () => {
             refreshBtn.removeEventListener('click', refreshConnections);
         };
         */
    }

    // Function to fetch and display last seen data
    async function fetchLastSeen(device, index) {
        try {
            // Much simpler - just need the topic ID
            const response = await fetch(`/buyer/last-seen/${device.stdOutTopic}`);
            const data = await response.json();

            const lastSeenCell = $(`#lastseen-cell-${index}`);

            if (data.success) {
                if (data.lastSeen !== null) {
                    // Color code based on how recent the activity is
                    let color = '#888'; // default gray
                    if (data.lastSeen < 300) { // less than 5 minutes
                        color = '#28a745'; // green
                    } else if (data.lastSeen < 3600) { // less than 1 hour
                        color = '#ffc107'; // yellow
                    } else if (data.lastSeen < 86400) { // less than 1 day
                        color = '#fd7e14'; // orange
                    } else {
                        color = '#dc3545'; // red
                    }

                    lastSeenCell.html(`<span style="color: ${color};">${data.lastSeenFormatted}</span>`);
                } else {
                    lastSeenCell.html('<span style="color: #888;">Never</span>');
                }
            } else {
                lastSeenCell.html('<span style="color: #dc3545;"></span>');
            }
        } catch (error) {
            console.error(`Error fetching last seen for device ${index}:`, error);
            $(`#lastseen-cell-${index}`).html('<span style="color: #dc3545;">Not initialised</span>');
        }
    }

    // Function to update all device statuses and last seen - INSIDE oneditprepare
    async function updateAllDeviceStatuses() {
        // console.log('[DEBUG] === Starting updateAllDeviceStatuses ===');
        //  console.log('[DEBUG] node.id:', node.id);
        // console.log('[DEBUG] devicesList length:', node.devicesList.length);

        if (!node.id) {
            // console.log('[DEBUG] No node.id available');
            node.devicesList.forEach((device, index) => {
                $(`#status-cell-${index}`).html('<span style="color: #dc3545;">No Node ID</span>');
                $(`#lastseen-cell-${index}`).html('<span style="color: #dc3545;">No Node ID</span>');
            });
            return;
        }

        try {
            // Get connection status
            // console.log('[DEBUG] Fetching connection status...');
            const connectionResponse = await fetch(`/buyer/connection-status/${node.id}`);

            if (!connectionResponse.ok) {
                throw new Error(`Connection API returned ${connectionResponse.status}`);
            }

            const connectionData = await connectionResponse.json();
            // console.log('[DEBUG] Connection data:', connectionData);

            // Create status map
            const statusMap = new Map();
            if (connectionData.data && Array.isArray(connectionData.data)) {
                connectionData.data.forEach(peer => {
                    if (peer.publicKey) {
                        statusMap.set(peer.publicKey, peer.connectionStatus || 'Not connected');
                    }
                });
            }

            // console.log('[DEBUG] Status map has', statusMap.size, 'entries');

            // Update each device
            for (let index = 0; index < node.devicesList.length; index++) {
                const device = node.devicesList[index];
                // console.log('[DEBUG] Processing device', index, ':', device.evmAddress);

                // Update status
                updateDeviceStatus(device, index, statusMap);

                // Update last seen
                updateLastSeen(device, index);
            }

            // console.log('[DEBUG] All devices processed');

        } catch (error) {
            // console.error('[DEBUG] Error in updateAllDeviceStatuses:', error);
            node.devicesList.forEach((device, index) => {
                $(`#status-cell-${index}`).html('<span style="color: #dc3545;">Not initialised</span>');
                $(`#lastseen-cell-${index}`).html('<span style="color: #dc3545;">Not initialised</span>');
            });
        }
    }

    // Function to update device status - INSIDE oneditprepare
    async function updateDeviceStatus(device, index, statusMap) {
        try {
            // console.log('[DEBUG] Getting public key for:', device.evmAddress);

            const evmResponse = await fetch(`/buyer/evm-to-publickey/${device.evmAddress}`);
            const evmData = await evmResponse.json();

            const statusCell = $(`#status-cell-${index}`);

            if (evmData.success) {
                const publicKey = evmData.publicKey;
                const connectionStatus = statusMap.get(publicKey) || 'Disconnected';

                // console.log('[DEBUG] Device', index, 'PublicKey:', publicKey, 'Status:', connectionStatus);

                let color = '#dc3545'; // red
                if (connectionStatus === 'Connected') {
                    color = '#28a745'; // green
                } else if (connectionStatus === 'Connecting') {
                    color = '#ffc107'; // yellow
                }

                statusCell.html(`<span style="color: ${color};">${connectionStatus}</span>`);
            } else {
                // console.log('[DEBUG] Failed to get public key for device', index);
                statusCell.html('<span style="color: #dc3545;">Key Error</span>');
            }
        } catch (error) {
            //  console.error('[DEBUG] Error updating status for device', index, ':', error);
            $(`#status-cell-${index}`).html('<span style="color: #dc3545;">Not initialised</span>');
        }
    }

    // Function to update last seen - INSIDE oneditprepare
    async function updateLastSeen(device, index) {
        try {
            if (!device.stdOutTopic || device.stdOutTopic === 'Unknown') {
                $(`#lastseen-cell-${index}`).html('<span style="color: #888;">No Topic</span>');
                return;
            }

            // console.log('[DEBUG] Getting last seen for topic:', device.stdOutTopic);

            const normalizedTopic = normalizeTopicFormat(device.stdOutTopic);
            const response = await fetch(`/buyer/last-seen/${normalizedTopic}`);
            const data = await response.json();

            const lastSeenCell = $(`#lastseen-cell-${index}`);

            if (data.success) {
                if (data.lastSeen !== null) {
                    let color = '#888';
                    if (data.lastSeen < 300) color = '#28a745';
                    else if (data.lastSeen < 3600) color = '#ffc107';
                    else if (data.lastSeen < 86400) color = '#fd7e14';
                    else color = '#dc3545';

                    lastSeenCell.html(`<span style="color: ${color};">${data.lastSeenFormatted}</span>`);
                } else {
                    lastSeenCell.html('<span style="color: #888;">Never</span>');
                }
            } else {
                lastSeenCell.html('<span style="color: #dc3545;">API Error</span>');
            }
        } catch (error) {
            // console.error('[DEBUG] Error updating last seen for device', index, ':', error);
            $(`#lastseen-cell-${index}`).html('<span style="color: #dc3545;">Not initialised</span>');
        }
    }

    // Function to handle peers that are connected but not in our device list
    async function handleAdditionalPeers(peersData, statusMap) {
        if (!peersData || !Array.isArray(peersData)) return;

        const tableBody = $('#devices-table-body');
        const existingPublicKeys = new Set();

        // Collect public keys from existing rows
        tableBody.find('tr').each(function () {
            const publicKey = $(this).data('publicKey');
            if (publicKey) {
                existingPublicKeys.add(publicKey);
            }
        });

        // Add rows for peers not in our device list
        peersData.forEach((peer, peerIndex) => {
            if (peer.publicKey && !existingPublicKeys.has(peer.publicKey)) {
                const newIndex = node.devicesList.length + peerIndex;
                const row = $(`
                    <tr data-publickey="${peer.publicKey}" data-index="additional-${peerIndex}" style="background-color: #f8f9fa;">
                        <td style="padding: 8px; border: 1px solid #555; font-family: monospace; font-size: 11px; color: #888;">
                            Unknown EVM
                        </td>
                        <td style="padding: 8px; border: 1px solid #555; color: #888;">-</td>
                        <td style="padding: 8px; border: 1px solid #555; color: #888;">-</td>
                        <td style="padding: 8px; border: 1px solid #555; color: #888;">-</td>
                        <td style="padding: 8px; border: 1px solid #555; text-align: center; font-size: 11px;">
                            <span style="color: #28a745;">${peer.connectionStatus || 'Connected'}</span>
                        </td>
                        <td style="padding: 8px; border: 1px solid #555; text-align: center; color: #888;">-</td>
                        <td style="padding: 8px; border: 1px solid #555; text-align: center;">
                            <span style="color: #888; font-size: 10px;">External</span>
                        </td>
                    </tr>
                `);
                tableBody.append(row);
            }
        });
    }

    // Helper to normalize Hedera topic format to 0.0.xxxxxxx
    function normalizeTopicFormat(topic) {
        if (typeof topic !== 'string') return topic;
        if (/^0\.0\.\d+$/.test(topic)) return topic;
        if (/^0\.0\d+$/.test(topic)) return topic.replace(/^0\.0(\d+)$/, '0.0.$1');
        if (/^\d+$/.test(topic)) return `0.0.${topic}`;
        return topic;
    }
</script>

<style>
.neuron-buyer-config .form-row {
    display: flex;
    margin-bottom: 8px;
    align-items: center;
    min-width: 430px;
}
.neuron-buyer-config #devices-table-container {
    padding: 8px;
    width: 100%;
    box-sizing: border-box;
    overflow-x: auto;
    min-width: 430px;
}
.neuron-buyer-config #devices-table {
    table-layout: auto;
    width: 100%;
}
.neuron-buyer-config #devices-table th {
    background-color: #2d2d2d !important;
    color: white !important;
    padding: 4px 6px;
}
.neuron-buyer-config #devices-table td {
    background-color: #3c3c3c;
    color: white;
    padding: 4px 6px;
}
.neuron-buyer-config #devices-table tbody tr:hover {
    background-color: #4a4a4a;
}
.neuron-buyer-config #evm-address-input {
    border: 1px solid #ccc;
    border-radius: 3px;
    padding: 6px 8px;
}
.neuron-buyer-config #evm-address-input:focus {
    border-color: #4d90fe;
    outline: none;
    box-shadow: 0 0 3px rgba(77, 144, 254, 0.3);
}
.neuron-buyer-config .remove-device-btn {
    background-color: #ff6b6b !important;
    border-color: #ff6b6b !important;
}
.neuron-buyer-config .remove-device-btn:hover {
    background-color: #ff5252 !important;
    border-color: #ff5252 !important;
}
.neuron-buyer-config .connection-status-connected { background-color: #4CAF50 !important; }
.neuron-buyer-config .connection-status-disconnected { background-color: #f44336 !important; }
.neuron-buyer-config .connection-status-connecting { background-color: #ff9800 !important; }
.neuron-buyer-config .connection-status-unknown { background-color: #9e9e9e !important; }
@keyframes fa-spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
.neuron-buyer-config .fa-spin {
    animation: fa-spin 1s infinite linear !important;
}
.neuron-buyer-config #devices-summary {
    padding-top: 8px;
    margin-top: 8px;
    font-size: 12px;
}
.neuron-buyer-config #no-device-message {
    background-color: #f8f9fa !important;
    border: 1px solid #dee2e6 !important;
    color: #6c757d !important;
}
@media (prefers-color-scheme: dark) {
    .neuron-buyer-config #no-device-message {
        background-color: #2d2d2d !important;
        border-color: #555 !important;
        color: #adb5bd !important;
    }
}
</style>


<script type="text/x-red" data-help-name="buyer config">
    <p>A configuration node that creates and manages a buyer device in the Neuron network with Hedera blockchain integration.</p>
    
    <h3>Overview</h3>
    <p>The Buyer Node is a configuration node that allows you to specify device details for a buyer device. When deployed, it automatically:</p>
    <ul>
        <li>Creates a Hedera account for the device</li>
        <li>Creates 3 Hedera topics for communication</li>
        <li>Registers the device to the specified smart contract</li>
        <li>Spawns the Neuron SDK process</li>
    </ul>
    
    <h3>Outputs</h3>
    <dl class="message-properties">
        <dt>payload <span class="property-type">object</span></dt>
        <dd>Contains the device configuration and connection details</dd>
        <dt>payload.deviceInfo <span class="property-type">object</span></dt>
        <dd>The complete device credentials and account details created by Hedera</dd>
        <dt>payload.connection <span class="property-type">string</span></dt>
        <dd>Status message indicating connection to the Neuron network</dd>
    </dl>
    
    <h3>Configuration</h3>
    <ul>
        <li><b>Name</b>: A unique identifier for this buyer node</li>
        <li><b>Smart Contract</b>: The target smart contract to register with (JetVision Demo, P2P Chat Demo, or Developer Open Challenges)</li>
        <li><b>Device Type</b>: Type of device (e.g., Cloud, Edge)</li>
        <li><b>Seller EVM Addresses</b>: Select which seller devices this buyer can interact with</li>
        <li><b>Description</b>: Optional description for the device</li>
    </ul>
    
    <h3>Runtime Information</h3>
    <p>After successful deployment, the node displays:</p>
    <ul>
        <li><b>EVM Address</b>: The Ethereum Virtual Machine address of the created account</li>
        <li><b>Balance</b>: Current HBAR balance of the device account</li>
        <li><b>Connection Status</b>: Real-time connection status to the Neuron network</li>
        <li><b>Connected Peers</b>: List of currently connected seller nodes</li>
    </ul>
    
    <h3>Device Credentials Output</h3>
    <p>The node outputs complete Hedera account details including:</p>
    <ul>
        <li>Account ID and private key</li>
        <li>Three Hedera topic IDs for communication</li>
        <li>Smart contract address</li>
        <li>Device metadata (name, type, serial number)</li>
        <li>Public key for peer-to-peer communication</li>
    </ul>
    
    <h3>Network Communication</h3>
    <p>To listen and write to the Neuron network after deployment:</p>
    <ul>
        <li>Use the <b>Neuron P2P</b> node for peer-to-peer communication</li>
        <li>The buyer node automatically spawns the Neuron SDK process</li>
        <li>WebSocket connections are established for real-time messaging</li>
        <li><b>Port Configuration</b>: Ensure ports 61336-61346 are forwarded on your router/firewall</li>
        <li><b>Network Access</b>: Other devices need to reach these ports for P2P connectivity</li>
    </ul>
    
    <h3>Status Indicators</h3>
    <ul>
        <li><span style="color:blue">â</span> Creating new device: Initial setup in progress</li>
        <li><span style="color:green">â</span> Process spawned: Neuron SDK process is running</li>
        <li><span style="color:yellow">â</span> Loading device info: Reading persisted device data</li>
        <li><span style="color:red">â</span> Error states: Configuration error, account creation failed, etc.</li>
    </ul>
    
    <h3>Prerequisites</h3>
    <ul>
        <li>Valid Hedera credentials must be configured</li>
        <li>Selected smart contract must be deployed and accessible</li>
        <li>Network connectivity for Hedera testnet/mainnet</li>
        <li><b>Port Forwarding</b>: Ports 61336 to 61346 must be forwarded for proper network communication</li>
    </ul>
    
    <h3>Network Setup</h3>
    <p>For the buyer node to communicate with other devices in the Neuron network:</p>
    <ul>
        <li><b>Port Range</b>: Forward ports 61336 to 61346 (inclusive) on your router</li>
        <li><b>Protocol</b>: Both TCP and UDP should be forwarded for these ports</li>
        <li><b>Target</b>: Forward to the IP address of the machine running Node-RED</li>
        <li><b>Firewall</b>: Ensure local firewall allows incoming connections on these ports</li>
        <li><b>Testing</b>: Use port scanning tools to verify ports are accessible externally</li>
    </ul>
    
    <h3>Usage Notes</h3>
    <ul>
        <li>Device information is automatically persisted and reloaded on restart</li>
        <li>The node can be deployed multiple times safely - existing devices are reused</li>
        <li>Monitor the connection status to ensure proper network connectivity</li>
        <li>Use refresh button to update peer connection information</li>
    </ul>
</script>